#!/usr/bin/env python3

# K4-Companion is an application written in python3 that can remotely
# control and Elecraft K4 tranceiver via TCP/IP.  It currently controls
# the main K4 features and is very useable as is, but new features are
# being added all the time.  K4-Companion is very configurable.
# 
# K4-Companion began life as a simple macro-sending program called
# K4Macro-Python, created by Charles Powell, NK8O. It has now grown far
# beyond a simple macro-sending program into a full-fledged remote control
# program for the K4.
# 
# Please send problem reports either: by sending an email, by entering
# an issue on github, or by making a pull request. Problem reports and
# suggesions are greatly appreciated.
#
# Configuration information is maintained in a separate YAML file named,
# by default, k4companion.yaml.
# 
# Dale Farnsworth, W7DA
# dale@farnsworth.org
#
# Copyright (C) 2025  Dale Farnsworth
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

import configparser
import ctypes
import hashlib
import math
import numpy
import opuslib
import os
import pyaudio
import pydub
import queue
import re
import select
import socket
import sys
import tempfile
import textwrap
import threading
import time
import tkinter as tk
import tkinter.ttk as ttk
import tkinter.font as tkFont
import yaml

from optparse import OptionParser
from tkinter import simpledialog

appname = 'k4companion'
version = "1.1.10"

class Default():
# may be overriden by values in the config file
    bg = 'maroon1'
    abg = 'red'
    fg = 'black'
    afg = None        # None means same as fg
    selectcolor = 'red'
    label_font =  { 'family': 'Helvetica', 'size': 10, 'weight': 'normal' }
    button_font = { 'family': 'Helvetica', 'size': 10, 'weight': 'normal' }

    def __init__(self, config_info):
        required = ['item']
        options = ['bg', 'abg', 'fg', 'afg', 'selectcolor', 'label_font', 'button_font']
        validate_config_options(config_info, required, options)

        Default.bg = config_info.get('bg', Default.bg)
        Default.abg = config_info.get('abg', Default.abg)
        Default.fg = config_info.get('fg', Default.fg)
        Default.afg = config_info.get('afg', Default.afg)
        Default.selectcolor = config_info.get('selectcolor', Default.selectcolor)
        Default.label_font = config_info.get('label_font', Default.label_font)
        Default.button_font = config_info.get('button_font', Default.button_font)

class Server():
    server_dict = {}
    default_server_name = None

    receive_poll_interval = 1           # poll every 1 mS
    ping_poll_interval = 2000           # poll every 2 seconds
    packet_header_len = 8
    packet_trailer_len = 4
    cat_packet_header_len = 3
    begin_packet_marker = bytes((0xFE, 0xFD, 0xFC,  0xFB))
    end_packet_marker = bytes((0xFB, 0xFC, 0xFD, 0xFE))
    cat_packet_type = 0
    cat_version_number = 0
    cat_sequence_number = 0
    cat_packet_header = bytes((cat_packet_type, cat_version_number, cat_sequence_number))

    k4_get_cmd_bases = [         # For future use
        '#A',
        'AC',
        'ACM',
        'ACN',
        'ACs',
        'ACT',
        'AF',
        'AG$',
        'AI',
        'AL',
        'AN',
        'AP$',
        '#AR',
        'AR$',
        'AT',
        '#AVG',
        'BG',
        'BI',
        'BL',
        'BN$',
        'BR',
        'BS',
        'BW$',
        '#C',
        'CC',
        '#CUR$',
        'CW',
        '#D',
        'DA',
        'DB$',
        'DN',
        'DO',
        '#DPM',
        'DR$',
        '#DSM',
        'DT$',
        'DV',
        'DW',
        'ER',
        'ES',
        '#F',
        'FA',
        'FB',
        'FC$',
        'FI$',
        'FP$',
        '#FPS',
        'FR',
        '#FRZ',
        'FT',
        'FX',
        '#FXA',
        '#FXT',
        'GT$',
        '#H',
        'HD',
        '#HDPM',
        '#HDSM',
        '#HREF$',
        '#HWBS',
        '#HWFC',
        'ID',
        'IF',
        'IP',
        'IS$',
        'K4',
        'KCL',
        'KP',
        'KS',
        'KZ',
        'KZF',
        'LB',
        'LI',
        'LK$',
        'LN',
        'LO',
        '#M',
        'MA$',
        'MD$',
        'ME',
        'MEDF',
        'MG',
        'MI',
        'ML',
        '#MP$',
        'MS',
        'MX',
        '#N',
        'NA$',
        '#NB$',
        'NB$',
        '#NBL$',
        'NM$',
        'NR$',
        'OM',
        'OV$',
        '#P',
        'PA$',
        'PC',
        'PING',
        'PK',
        '#PKM',
        'PL$',
        'PONG',
        'PP',
        '#R',
        'RA$',
        'RE',
        '#REF$',
        'RG$',
        'RL',
        'RO$',
        'RP',
        'RR',
        'RRC',
        'RRP',
        'RS',
        'RT$',
        'RV',
        '#S',
        'SB',
        'SC',
        '#SCL',
        'SD',
        '#SFL',
        'SL',
        'SM$',
        'SMH',
        'SMH$',
        'SN',
        '#SPM',
        '#SPN$',
        'SQ$',
        'SW',
        'TA',
        'TB$',
        'TD$',
        'TE',
        'TG',
        'TQ',
        'TS',
        'TX',
        'UP',
        'UT',
        '#V',
        'VC',
        '#VFA',
        '#VFB',
        'VG',
        'VI',
        'VO$',
        'VT$',
        'VX',
        '#W',
        '#WBS',
        '#WFC',
        'WM',
        'XT',
        'XV',
        'XV$',
    ]
    k4_long_cmd_bases = {
        '#A': ['#AR', '#AVG'],
        'AC': ['ACM', 'ACS', 'ACT', 'ACN'],
        '#C': ['#CAL', '#CUR'],
        '#D': ['#DPM', '#DSM'],
        'DN': ['DNB'],
        '#F': ['#FPS', '#FRZ', '#FXA', '#FXT'],
        '#H': ['#HDPM', '#HDSM', '#HREF', '#HWBS', '#HWFC', '#HWFH'],
        'KZ': ['KZL', 'KZF'],
        'LO': ['LOG'],
        'ME': ['MEDF'],
        '#M': ['#MP'],
        '#N': ['#NBL', '#NB'],
        'PC': ['PCX'],
        'PI': ['PING'],
        'PO': ['PONG'],
        '#P': ['#PKM'],
        '#R': ['#REF'],
        'RR': ['RRT', 'RRC', 'RRP'],
        'SM': ['SMH'],
        '#S': ['#SCL', '#SFL', '#SPM', '#SPN'],
        'SW': ['SWT', 'SWH'],
        'UP': ['UPB'],
        '#V': ['#VFA', '#VFB'],
        '#W': ['#WBS', '#WFC', '#WFH'],
        'XV': ['XVN', 'XVM', 'XVR', 'XVI', 'XVO', 'XVP '],
    }

    # commands that end in +, -, /, \, ^, > are also pseudo set-only commands
    k4_set_only_cmd_bases = {
        'AB': True,
        'DE': True,
        'DM': True,
        'DNB': True,
        'DN': True,
        'EC': True,
        'LI': True,     # where total length of cmd is <= 6 characters
        'MS': True,     # where total length of cmd is <= 4 characters
        'PING': True,
        'RC$': True,
        'RC': True,
        'RD$': True,
        'RD': True,
        'RU$': True,
        'RU': True,
        'RX': True,
        'SI': True,
        'SP$': True,
        'SP': True,
        'SWH': True,
        'SW': True,
        'SWT': True,
        'TX': True,
        'UPB': True,
        'UP': True,
    }

    set_only_suffixes = {
        '+': True,
        '-': True,
        '/': True,
        '\\': True,
        '+': True,
        '-': True,
    }

    k4_get_only_cmd_bases = {
        'BG': True,
        'IF': True,
        'MA$': True,
        'MA': True,
        'OM': True,
        'PONG': True,
        'PP': True,
        'RV': True,
        'SM$': True,
        'SMH$': True,
        'SMH': True,
        'SM': True,
        'SN': True,
        'TA': True,
        'TG': True,
        'TQ': True,
        'UT': True,
    }

    @staticmethod
    def server(server_name):
        return Server.server_dict[server_name]

    @staticmethod
    def server_names():
        return Server.server_dict.keys()

    @staticmethod
    def servers():
        return Server.server_dict.values()

    @staticmethod
    def default():
        return Server.server(Server.default_server_name)

    @staticmethod
    def k4_set_only_cmd(base, cmd):
        if base in Server.k4_set_only_cmd_bases:
            if base == 'LI' and len(cmd) > 6:
                return False
            elif base == 'MS' and len(cmd) > 4:
                return False
            else:
                return True
        elif base[-1] in Server.set_only_suffixes:
            return True
        else:
            return False

    @staticmethod
    def k4_get_only_cmd(base):
        return base in Server.k4_get_only_cmd_bases

    @staticmethod
    def send_cmds_with_server(cmd_list):
        for server_name, cmds in cmd_list:
            if server_name in Server.server_names():
                server = Server.server(server_name)
                server.send_cmds(cmds)
            elif server_name == 'delay':
                delay = float(cmd_dict[server_name]) / 1000
                time.sleep(delay)
            else:
                raise Exception("Unknown server name '{name}'".format(name=server_name))

    @staticmethod
    def split_cmd(cmd):
        if cmd[-1] == ';':
            cmd = cmd[0:-1]
        return cmd.split(';')

    def __init__(self, config_info):
        required = ['item', 'name', 'address', 'port']
        options = ['type', 'startup', 'connect_on_start', 'button_font']
        validate_config_options(config_info, required, options)

        self.name = config_info['name']
        self.type = config_info.get('type', '').lower()
        self.address = config_info['address']
        self.port = config_info['port']
        self.startup = config_info.get('startup', None)
        self.connect_on_start = true_values(config_info.get('connect_on_start', True))
        self.socket = None
        self.recv_buffer = ''
        self.send_queue = queue.Queue()
        self.recv_queue = queue.Queue()
        self.output_audio_queue = None
        self.send_thread = None
        self.recv_thread = None
        self.connected = False
        self.k4_subscriptions = {}
        self.k4_parameters = {}
        self.connect_callbacks = []
        self.partial_packet = None
        self.password = None

        self.ignored_errors = {}

        if Server.default_server_name == None:
            Server.default_server_name = config_info['name']
        Server.server_dict[self.name] = self

        self.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        self.subscribe_response('ER;', self.on_error_code, send=False)

    def on_error_code(self, response):
        response = response.rstrip(';')
        try:
            code, text = response.split(':', 1)
            Popup.warning(msg=[code, text])
        except:
            Popup.warning(msg=response)

    def subscribe_connect(self, callback):
        if self.connected:
            callback()
        else:
            self.connect_callbacks.append(callback)

    def update_k4_parameter(self, base, parameter):
        old = self.k4_parameters.get(base, None)
        self.k4_parameters[base] = parameter

        callbacks = self.k4_subscriptions.get(base, [])
        for callback in callbacks:
            callback(base + parameter + ';')

        return  old != parameter

    def k4_parameter(self, base):
        return self.k4_parameters.get(base, None)

    def connect(self):
        if self.connected:
            return

        vprint1('Connecting to {name}, address {addr}, port {port}'.format(
              name=self.name, addr=self.address, port=self.port))

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            sock.settimeout(5)
            sock.connect((self.address, self.port))
            self.connected = True
            self.socket = sock
            self.send_thread = threading.Thread(target=self.send_loop, name=self.name+'.send_thread')
            self.send_thread.start()
            self.recv_thread = threading.Thread(target=self.recv_loop, name=self.name+'.recv_thread')
            self.recv_thread.start()
            if self.type == 'k4':
                if self.port == 9200:
                    self.dequeue_k4_cat()
                else:
                    self.output_audio_queue = queue.Queue()

                    if self.password == None:
                        self.password = Popup.password(title="Connect to K4",
                            msg="Enter your k4 remote password:")
                    h = hashlib.sha384(self.password.encode()).hexdigest()
                    self.send_str(h, force_as_string=True)
                    self.send_str('RDY;')
                    Poll.add_poll(Server.ping_poll_interval, self.ping)

                    Audio.output_queue(self.output_audio_queue)

                if self.port == 9205:
                    self.dequeue_k4_packets()

                self.send_str('PING;')               # Trigger a response: PONG;
                self.send_str('K41;')                # request K4 to respond in advanced mode
                self.send_str('AI4;')                # request K4 to send updates immediately
                self.send_str('ER1;')                # request long format error messages
                self.send_cmds('MD;MD$;')            # cache the mode response for later use in setting the vfo step

                self.send_str('SIDA0;')              # Disable AI4 delivery of DAP info reports
                self.send_str('SIDD0;')              # Disable AI4 delivery of DDC info reports
                self.send_str('SIDU0;')              # Disable AI4 delivery of DUC info reports
                self.send_str('SIFP0;')              # Disable AI4 delivery of FP info reports
                self.send_str('SIRF0;')              # Disable AI4 delivery of RFB info reports
                self.send_str('SIRC0;')              # Disable AI4 delivery of RMT connection info

                if self.startup != None:
                    self.send_cmds(self.startup)     # send user-specified startup commands

            for callback in self.connect_callbacks:
                callback()

        except socket.gaierror:
            print('Address not found: {addr}'.format(addr=self.address))
            if not Options.debug > 0:
                cleanup_and_exit()
        except OSError:
            print('Failed to connect to {name}, address {addr}, port {port}'.format(
                  name=self.name, addr=self.address, port=self.port))
            if Options.debug > 0:
                raise
            else:
                cleanup_and_exit()

    def close(self):
        self.connected = False
        self.send_queue.put('shutdown')
        if self.output_audio_queue != None:
            self.output_audio_queue.put([])
        if self.send_thread != None:
            self.send_thread.join()
        if self.recv_thread != None:
            self.recv_thread.join()

    def send_str(self, cmd, force_as_string=False):
        if self.port == 9200 or force_as_string:
            self.send_queue.put((cmd.encode(), ))
        else:
            self.send_cat_packet(cmd.encode())

    def send_cat_packet(self, byts):
        self.send_queue.put((
            Server.begin_packet_marker,
            self.encode_len(len(byts)+3), 
            Server.cat_packet_header,
            byts, 
            Server.end_packet_marker))

    def encode_len(self, l):
        return bytearray(((l>>24)&0xff, (l>>16)&0xff, (l>>8)&0xff, l&0xff))

    def send_cmds(self, cmds):
        if not self.connected:
            Popup.warning("Server '{name}' not connected.".format(name=self.name))
        if isinstance(cmds, str):
            cmds = Server.split_cmd(cmds)
        for cmd in cmds:
            if cmd == '':
                continue
            base = cmd_base(cmd)
            if Server.k4_set_only_cmd(base, cmd) or self.update_k4_parameter(base, cmd[len(base):]):
                cmd += ';'
                self.send_str(cmd)

    def send_loop(self):
        while True:
            bs = self.send_queue.get()
            if not self.connected:
                return
            try:
                try:
                    self.socket.sendmsg(bs)
                except:
                    for b in bs:
                        self.socket.sendall(b)
                #dprint1('{name}: sent: {bs}'.format(name=self.name, bs=bs))
                if Options.debug >= 1 and len(bs) > 3 and bs[2][0] == 0:
                    cmds = bs[3].decode()
                    if cmds in ['PING;']:
                        dprint3('{name}: sent: {cmds}'.format(name=self.name, cmds=cmds))
                    else:
                        dprint1('{name}: sent: {cmds}'.format(name=self.name, cmds=cmds))
            except OSError:
                print("Failed to send command, '{bs}' to '{name}'".format(bs=bs[3], name=self.name))

    def expand_cmds(self, cmds):
        if isinstance(cmds, str):
            return [[self.name, Server.split_cmd(cmds)]]
        elif isinstance(cmds, dict):
            cmd_dict = cmds
            ret = []
            for name in cmd_dict:
                cmd = cmd_dict[name]
                ret.append(name, Server.split_cmd(cmd_dict[name]))
            return ret
        elif isinstance(cmds, list):
            ret = []
            for cmd_dict in cmds:
                if not isinstance(cmd_dict, dict):
                    raise Exception("Unknown server sub-command '{cmd}'".format(cmd=cmd_dict))
                for name in cmd_dict:
                    cmd = cmd_dict[name]
                    ret.append(name, Server.split_cmd(cmd_dict[name]))
            return ret
        else:
            raise Exception("Error: bad cmd format: '{cmds}'".format(cmds=cmds))

    def expand_server_cmds(self, cmds):
        if isinstance(cmds, str):
            return Server.split_cmd(cmds)
        ret = []
        for name, cmds in self.expand_cmds(cmds):
            if name == self.name:
                ret.extend(cmds)
        return ret

    def expand_and_send_cmds(self, cmds):
        expanded_cmds = self.expand_cmds(cmds)
        Server.send_cmds_with_server(expanded_cmds)

    def server_cmds(self, cmds):
        ret = []
        expanded_cmds = self.expand_cmds(cmds)
        for server_name, cmds in expanded_cmds:
            if server_name != self.name:
                continue
            for cmd in cmds:
                ret.append(cmd)
        return ret

    def subscribe_cmds(self, cmds, callback):
        for cmd in self.server_cmds(cmds):
            self.subscribe_response(cmd, callback)

    def ping(self):
        self.send_str('PING;')

    def dequeue_k4_packets(self):
        packet_offset = 0

        while True:
            try:
                rb = self.recv_queue.get_nowait()
                if self.partial_packet != None:
                    rb = self.partial_packet + rb
                    self.partial_packet = None

                while True:
                    remaining_length = len(rb)
                    if remaining_length < 8:
                        self.partial_packet = rb
                        break
                    if rb[0:4] != Server.begin_packet_marker:
                        raise Exception('bad received packet header', rb[0:4])
                    payload_length = (rb[4]<<24) | rb[5]<<16 | rb[6]<<8 | rb[7]
                    end_offset = 12 + payload_length
                    if remaining_length < end_offset:
                        self.partial_packet = rb
                        break
                    if rb[end_offset-4:end_offset] != Server.end_packet_marker:
                        raise Exception('bad received packet trailer', rb[end_offset-4:end_offset])
                    #tprint('payload type', rb[8], 'version', rb[9], 'sequence', rb[10])

                    payload_type = rb[8]
                    payload = rb[11:end_offset-4]
                    if payload_type == 0:
                        self.received_cat(payload)
                    elif payload_type == 1:
                        self.received_audio(payload)
                    elif payload_type == 2:
                        self.received_pan(payload)
                    elif payload_type == 3:
                        self.received_minipan(payload)

                    if remaining_length == end_offset:
                        break
                    rb = rb[end_offset:]

            except queue.Empty:
                Poll.delayed_call(Server.receive_poll_interval, self.dequeue_k4_packets)
                break

    def received_cat(self, cmds):
        responses = cmds.decode().split(';')[:-1]
        self.receive_k4_responses(responses)

    def received_audio(self, data):
        # If we're behind in emptying the queue, don't bother adding to it.
        if self.output_audio_queue.qsize() > 1:
            return

        self.output_audio_queue.put(data)

    def received_pan(self, data):
        #tprint('pan: len:', len(data))
        pass

    def received_minipan(self, data):
        #tprint('minipan: len:', len(data))
        pass

    def dequeue_k4_cat(self):
        while True:
            responses = []

            try:
                recv_bytes = self.recv_queue.get_nowait()
                recv_str = recv_bytes.decode()
                responses = recv_str.split(';')
                if len(responses) == 0:
                    continue

                if self.partial_packet != None:
                    responses[0] = self.partial_packet + responses[0]
                    self.partial_packet = ''

                if responses[-1] != '':
                    self.partial_packet = responses[-1]

                responses = responses[0:-1]
                self.receive_k4_responses(responses)
            except queue.Empty:
                Poll.delayed_call(Server.receive_poll_interval, self.dequeue_k4_cat)
                break

    def receive_k4_responses(self, responses):
        for response in responses:
            base = cmd_base(response)
            if Options.debug >= 1:
                if base in ('SM', 'SM$', 'SMH', 'SMH$', 'TM', 'PONG'):
                    dprint3('{name}: received: {response}'.format(name=self.name, response=response))
                else:
                    dprint1('{name}: received: {response}'.format(name=self.name, response=response))
            response = response[len(base):]
            if response == '?' and base not in self.ignored_errors:
                if Options.debug > 0:
                    raise Exception('Received error response from K4: ', base + response)
                else:
                    Popup.warning('Received error response from K4: ' + base + response)
            self.update_k4_parameter(base, response)

    def recv_loop(self):
        while True:
            readable, writable, in_error = select.select([self.socket.fileno()], [], [self.socket], 1)
            if not self.connected:
                return
            if len(in_error) > 0:
                raise Exception("Socket error reading from server '{name}'".format(name=self.name))
            if len(readable) == 0:
                continue

            recv_bytes = self.socket.recv(16384)
            if len(recv_bytes) == 0:
                self.connected = False
                return

            try:
                self.recv_queue.put(recv_bytes)
            except queue.ShutDown:
                pass

    def subscribe_response(self, cmd, callback, send=True):
        base = cmd_base(cmd)
        if Server.k4_set_only_cmd(base, cmd):
            return                              # No use subscribing to set-only commands
        if not base in self.k4_subscriptions:
            self.k4_subscriptions[base] = []
        if not callback in self.k4_subscriptions[base]:
            self.k4_subscriptions[base].append(callback)
        if send == True:
            parameter = self.k4_parameters.get(base, None)
            if parameter != None:
                callback(base + parameter + ';')
            self.send_str(cmd_get_format(cmd))              # TODO Try sending only if not found is cached parameters

    def unsubscribe_response(self, base, callback):
        try:
            self.k4_subscriptions[base].remove(callback)
        except:
            pass

    def clear_k4_subscriptions(self):
        self.k4_subscriptions.clear()

    def add_ignored_error(self, base):
        self.ignored_errors[base] = True

    def set_password(self, password):
        self.password = password

class Widget():
    blink_mS = 500
    default_leading = 0
    default_label_leading = 1

    def __init__(self, config_info, container):
        self.config_info = config_info
        self.container = container
        self.bg = None
        self.abg = None
        self.fg = None
        self.afg = None
        self.cached_font = None
        self.cached_button_font = None
        self.cached_label_font = None

        if 'server' in self.config_info:
            self.server = Server.server(self.config_info['server'])
        else:
            if self.container != None:
                self.server = self.container.server

        if self.container != None:
            self.frame = self.label_and_leading_frame()

    def k4param(self, base):
        if self.server.type == 'k4':
            return self.server.k4_parameter(base)
        else:
            return None

    def eval_value(self, s, value):
        try:
            ret = eval(str(s))
        except Exception as err:
            dprint('value: "{value}", eval("{s}")'.format(value=value, s=s))
            dprint('exception: {err}'.format(err=err))
            raise
        return ret

    def label_font(self):
        if self.cached_label_font != None:
            return self.cached_label_font
        if 'label_font' in self.config_info:
            font = self.config_info['label_font']
            font = tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])
        else:
            font = self.container.label_font()
            self.cached_label_font = font
        return font

    def button_font(self):
        if self.cached_button_font != None:
            return self.cached_button_font
        if 'button_font' in self.config_info:
            font = self.config_info['button_font']
            font = tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])
        else:
            font = self.container.button_font()
            self.cached_button_font = font
        return font

    def font(self):
        if self.cached_font != None:
            return self.cached_font
        if 'font' in self.config_info:
            font = self.config_info['font']
            font = tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])
        else:
            font = self.button_font()
            self.cached_font = font
        return font

    def label_and_leading_frame(self):
        container = self.container
        config_info = self.config_info
        if 'column' in config_info:
            column = config_info['column']
            if column < container.column:
                container.next_row()
            container.column = column

        columnspan = config_info.get('columnspan', 1)
        rowspan = config_info.get('rowspan', 1)

        self.outer_frame = tk.Frame(container.frame)

        label = config_info.get('label', None)

        if 'label' in config_info:
            default_leading = Widget.default_label_leading
        else:
            default_leading = Widget.default_leading

        leading = config_info.get('leading', default_leading)

        self.outer_frame.grid(row=container.row,
                        column=container.column,
                        rowspan=rowspan,
                        columnspan=columnspan,
                        sticky='nw')

        if label == None and leading == 0:
            return self.outer_frame

        row = 0
        if leading != 0:
            family = self.label_font().cget('family')
            weight = self.label_font().cget('weight')
            leading_font = tkFont.Font(family=family, size=leading, weight=weight)
            leading_label = tk.Label(self.outer_frame, text=' ', font=leading_font)
            leading_label.grid(row=0, column=0, sticky='nw')
            row=1

        if label == None:
            inner_frame = tk.Frame(self.outer_frame)
        else:
            inner_frame = tk.LabelFrame(self.outer_frame,
                                       text=label,
                                       font=self.label_font(),
                                       labelanchor='nw',
                                       bd=4,
                                       relief='raised')
        inner_frame.grid(row=row, column=0, sticky='nw')

        return inner_frame

class Container(Widget):
    depth = -1

    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        if isinstance(self, Page):
            self.childwidth = config_info.get('childwidth', None)
        else:
            self.childwidth = config_info.get('childwidth', container.childwidth)
        self.columns = config_info.get('columns', len(self.config_info['contains']))
        self.row = 0
        self.column = 0

        self.children = []

    def next_column(self):
        self.column += 1
        if self.column >= self.columns:
            self.column = 0
            self.next_row()

    def next_row(self):
        self.row += 1

    def show_widgets(self):
        Container.depth += 1
        if len(self.config_info['contains']) == 0:
            raise Exception('item: group requires a contains: option')
        for config_info in self.config_info['contains']:
            widget_type = config_info['item'].lower()
            if widget_type == 'group':
                if Options.debug > 0:
                    label = config_info.get('label', '')
                    indent = '    ' * Container.depth
                    dprint('{indent}group {label}: row  {row}, column: {column}'.format(indent=indent, label=label, row=self.row, column=self.column))
                child = Group(config_info, self)
            elif widget_type == 'button':
                child = Button(config_info, self)
            elif widget_type == 'radiobutton':
                child = Radiobutton(config_info, self)
            elif widget_type == 'vfo':
                child = VFO(config_info, self)
            elif widget_type == 'slider':
                child = Slider(config_info, self)
            elif widget_type == 'togglebutton':
                child = Togglebutton(config_info, self)
            elif widget_type == 'getvalue':
                child = Getvalue(config_info, self)
            elif widget_type == 'bargraph':
                child = Bargraph(config_info, self)
            elif widget_type == 'text':
               child = Text(config_info, self)
            elif widget_type == 'notebook':
               child = Notebook(config_info, self)
            elif widget_type == 'dropdownbutton':
               child = Dropdownbutton(config_info, self)
            elif widget_type == 'menu':
               child = Menu(config_info, self)
            elif widget_type == 'settings':
               child = Settings(config_info, self)
            else:
                raise Exception('Error: config file: unknown item "{type}"'.format(type=widget_type))

            self.children.append(child)

            self.next_column()

        Container.depth -= 1

    def items_width(self):
        width = 0
        for config_info in self.config_info['contains']:
            text = str(config_info.get('text', ''))
            for line in text.split('\n'):
                if len(line) > width:
                    width = len(line)
            for config_info in config_info.get('selections', []):
                text = str(config_info.get('text', ''))
                for line in text.split('\n'):
                    if len(line) > width:
                        width = len(line)
        return width

    def has_tabnames(self):
        children = self.config_info['contains']
        tabcount = 0
        for child in children:
            if child.get('item', None) == 'group' and child.get('tabname', None) != None:
                tabcount += 1
        if tabcount > 0 and tabcount != len(children):
            raise Exception('Error: Some, but not all contained items specify a tabname')

        return tabcount > 0

class Page(Container):
    pages = {}
    name_stack = []
    top = None

    @staticmethod
    def show_page(page_name):
        if len(Page.name_stack) > 0:
            #            current_page_name = Page.name_stack[-1]
            #current_page = Page.pages[current_page_name]
            #current_page.hide()
            Page.current().hide()
        if page_name in Page.pages:
            Page.name_stack.append(page_name)
            Page.pages[page_name].show()
        else:
           raise Exception("Page:'{name}' not found.".format(name=page_name))

    @staticmethod
    def current():
        if len(Page.name_stack) == 0:
            return None
        return Page.pages[Page.name_stack[-1]]

    @staticmethod
    def show_previous():
        if len(Page.name_stack) < 2:
            return
        current_page_name = Page.name_stack.pop()
        page_name = Page.name_stack.pop()
        Page.name_stack.append(current_page_name)
        Page.show_page(page_name)

    @staticmethod
    def main():
        first_page_name = list(Page.pages.keys())[0]
        return Page.pages[first_page_name]

    def __init__(self, config_info):
        required = ['item', 'name', 'contains']
        options = ['server', 'columns', 'childwidth', 'label_font', 'button_font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, None)

        self.name = config_info['name']
        Page.pages[self.name] = self

        if self.has_tabnames():
            self.frame = ttk.Notebook(Page.top)
        else:
            self.frame = tk.Frame(Page.top)

        self.show_widgets()

    def show(self):
        self.frame.grid()

    def hide(self):
        self.frame.grid_forget()

    def label_font(self):
        font = self.config_info.get('label_font', Default.label_font)
        return tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])

    def button_font(self):
        font = self.config_info.get('button_font', Default.button_font)
        return tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])

    def server(self):
        if 'server' in self.config_info:
            server = Server.server(self.config_info['server'])
        else:
            server = None
        return server

class Group(Container):
    def __init__(self, config_info, container):
        required = ['item', 'contains']
        options = ['columns', 'column', 'columnspan', 'rowspan', 'childwidth',
                   'label_font', 'button_font', 'tabname', 'label', 'leading']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)
        self.tabname = config_info.get('tabname', '')

        self.show_widgets()

        if isinstance(container.frame, ttk.Notebook):
            container.frame.add(self.outer_frame, text=self.tabname)

class Button(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['text', 'cmd', 'directive', 'bg', 'abg', 'fg', 'afg', 'justify', 'font', 'label', 'leading', 'button_font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        text = str(config_info.get('text', ''))
        cmd = config_info.get('cmd', None)
        directive = config_info.get('directive', None)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg
        justify = config_info.get('justify', 'center')

        width = container.items_width()

        if directive != None:
            command = directive_command(self, directive)
        elif cmd != None:
            command = lambda: self.server.expand_and_send_cmds(cmd)

        button = tk.Button(self.frame,
                    bd='2',
                    text=text,
                    font=self.font(),
                    width=width,
                    justify=justify,
                    relief='raised',
                    fg=fg,
                    bg=bg,
                    activebackground=abg,
                    activeforeground=afg,
                    padx=2,
                    pady=2,
                    command=command)

        button.grid(row=0, column=0, sticky='w')

class Togglebutton(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['wraparound', 'justify', 'selections', 'label', 'leading']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        self.index = 0
        self.blink_state = False

        self.selections = []

        self.wraparound = true_values(config_info.get('wraparound', True))
        self.justify = config_info.get('justify', 'left')

        conf_selections = config_info.get('selections', None)
        for conf_sel in conf_selections:
            index = len(self.selections)
            selection = {}

            required = []
            options = ['text', 'cmd', 'response', 'directive', 'bg', 'abg', 'fg', 'afg', 'blink', 'font', 'button_font']
            validate_config_options(conf_sel, required, options, name='togglebutton.selection')

            selection['text'] = conf_sel.get('text', '')

            cmd = conf_sel.get('cmd', None)
            orig_response = conf_sel.get('response', cmd)
            selection['response'] = orig_response

            selection['parameters'] = {}

            if cmd != None:
                cmds = self.server.expand_server_cmds(cmd)
                responses = self.server.expand_server_cmds(orig_response)
                for response in responses:
                    base = cmd_base(response)
                    if Server.k4_set_only_cmd(base, response):
                        if len(cmds) <= 1 and len(responses) <= 1:
                            raise Exception("Set-only command: '{cmd}' not permitted in togglebutton".format(cmd=orig_response))
                        continue
                    if Server.k4_get_only_cmd(base) and len(cmds) <= 1 and len(responses) <= 1:
                        raise Exception("Get-only command: '{cmd}' not permitted in togglebutton".format(cmd=orig_response))
                    response = response[len(base):]
                    selection['parameters'][base] = response

            selection['command'] = self.do_selection

            selection['cmd'] = cmd
            selection['directive'] = conf_sel.get('directive', None)
            selection['bg'] = conf_sel.get('bg', Default.bg)
            selection['fg'] = conf_sel.get('fg', Default.fg)
            selection['abg'] = conf_sel.get('abg', Default.abg)
            selection['afg'] = conf_sel.get('afg', Default.afg)
            if selection['afg'] == None:
                selection['afg'] = selection['fg']
            selection['blink'] = conf_sel.get('blink', False)
            self.selections.append(selection)

        width = container.items_width()

        self.button = tk.Button(self.frame,
                    bd='2',
                    font=self.font(),
                    width=width,
                    relief='raised',
                    padx=2,
                    pady=2,
                    command=selection['command'])
        self.configure()

        self.button.grid(row=0, column=0, sticky='w')

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        for selection in self.selections:
            response = selection['response']
            if response != None:
                self.server.subscribe_cmds(response, self.on_response_received)

    def configure(self):
        selection = self.selections[self.index]
        self.button.configure(
                    text=selection['text'],
                    fg=selection['fg'],
                    bg=selection['bg'],
                    activebackground=selection['abg'],
                    activeforeground=selection['afg'],
                    justify=self.justify)
        if selection['blink']:
            self.blinkon(selection)
        else:
            self.blinkoff(selection)

    def next_selection(self):
        self.index += 1
        if self.index >= len(self.selections):
            if self.wraparound:
                self.index = 0
            else:
                self.index = len(self.selections) - 1
        self.configure()

    def do_selection(self):
        self.next_selection()
        selection = self.selections[self.index]

        directive = selection['directive']
        cmd = selection['cmd']

        if directive != None:
            command = directive_command(self, directive)
            command()
        elif cmd != None:
            self.server.expand_and_send_cmds(cmd)

        self.configure()

    def compare_parameters(self, text, parameters):
        for base in parameters.keys():
            dprint2('commpare :{text} s: {s}, b: {b}'.format(text=text, s=self.server.k4_parameters.get(base, None), b=parameters[base]))
            if parameters[base] != self.server.k4_parameters.get(base, None):
                return False
        dprint2('Match')
        return True

    def on_response_received(self, response):
        for index, selection in enumerate(self.selections):
            if self.compare_parameters(selection['text'], selection['parameters']):
                self.index = index
                self.configure()

    def blinkon(self, selection):
        Poll.add_poll(Widget.blink_mS, self.blink)

    def blinkoff(self, selection):
        Poll.remove_poll(Widget.blink_mS, self.blink)

    def blink(self):
        selection = self.selections[self.index]
        self.blink_state = not self.blink_state
        if self.blink_state:
            self.button.configure(bg=selection['fg'], fg=selection['bg'])
        else:
            self.button.configure(bg=selection['bg'], fg=selection['fg'])

class Radiobutton(Widget):
    variables = {}
    button_counter = 0

    def __init__(self, config_info, container):
        required = ['item', 'groupid']
        options = ['text', 'cmd', 'response', 'indicator', 'selectcolor', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'blink', 'font', 'button_font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        Radiobutton.button_counter += 1

        self.text = str(config_info.get('text', ''))
        self.cmd = config_info.get('cmd', None)
        self.response = config_info.get('response', self.cmd)
        indicator = config_info.get('indicator', 1)
        selectcolor = config_info.get('selectcolor', Default.selectcolor)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg
        self.blink = config_info.get('blink', False)
        self.blink_state = False
        self.group_id = config_info.get('groupid', None)

        self.parameters = {}

        if not self.group_id in Radiobutton.variables:
            Radiobutton.variables[self.group_id] = tk.StringVar
        variable = Radiobutton.variables[self.group_id]

        width = container.items_width()

        self.button = tk.Radiobutton(self.frame,
                    bd='2',
                    text=self.text,
                    font=self.font(),
                    width=width,
                    relief='raised',
                    fg=fg,
                    bg=bg,
                    activebackground=abg,
                    activeforeground=afg,
                    padx=2,
                    pady=2,
                    command=self.on_clicked,
                    indicator=indicator,
                    selectcolor=selectcolor,
                    variable=variable,
                    value=Radiobutton.button_counter)

        self.button.grid(row=0, column=0, sticky='w')

        cmds = self.server.expand_server_cmds(self.cmd)
        responses = self.server.expand_server_cmds(self.response)
        for response in responses:
            base = cmd_base(response)
            if Server.k4_set_only_cmd(base, response):
                if len(cmds) <= 1 and len(responses) <= 1:
                    raise Exception("Set-only command: '{cmd}' not permitted in Radiobutton".format(cmd=self.response))
                continue
            if Server.k4_get_only_cmd(base) and len(cmds) <= 1 and len(responses) <= 1:
                raise Exception("Get-only command: '{cmd}' not permitted in Radiobutton".format(cmd=self.response))
            response = response[len(base):]
            self.parameters[base] = response

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        self.server.subscribe_cmds(self.response, self.on_response_received)

    def on_clicked(self):
        if self.cmd != None:
            self.server.expand_and_send_cmds(self.cmd)

    def compare_parameters(self, group, text):
        parameters = self.parameters
        for base in parameters.keys():
            dprint2('commpare {group}:{text} s: {s}, b: {b}'.format(group=group, text=text, s=self.server.k4_parameters.get(base, None), b=parameters[base]))
            if parameters[base] != self.server.k4_parameters.get(base, None):
                return False
        dprint2('Match')
        return True

    def on_response_received(self, response):
        if self.compare_parameters(self.group_id, self.text):
            self.button.select()
            if self.blink:
                self.blinkon()
        else:
            self.button.deselect()
            if self.blink:
                self.blinkoff()

    def blinkon(self):
        Poll.add_poll(Widget.blink_mS, self.blink)

    def blinkoff(self):
        Poll.remove_poll(Widget.blink_mS, self.blink)

    def blink(self):
        self.blink_state = not self.blink_state
        if self.blink_state:
            self.button.select()
        else:
            self.button.deselect()

class VFO(Widget):
    steps = [.001, .01, .1, 1, 10 ]
    texts = [ '1 Hz', '10 Hz', '100 Hz', '1 kHz', '10 kHz' ]
    step_to_index = {}
    text_to_index = {}
    low_frequency_limit=100
    high_frequency_limit=54000

    def __init__(self, config_info, container):
        required = ['item', 'AorB']
        options = ['width', 'activecolor', 'transmitcolor', 'step_spinbox', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'blink', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        if len(VFO.step_to_index) == 0:
            for i, step in enumerate(VFO.steps):
                VFO.step_to_index[step] = i

        if len(VFO.text_to_index) == 0:
            for i, text in enumerate(VFO.texts):
                VFO.text_to_index[text] = i

        self.AorB = config_info.get('AorB', 'A').upper()

        self.bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        step_spinbox = true_values(config_info.get('step_spinbox', 'false'))
        width = config_info.get('width', 0)
        self.active_color = config_info.get('activecolor', self.bg)
        self.transmit_color = config_info.get('transmitcolor', self.bg)

        self.step = .1

        frame = tk.Frame(self.frame)

        self.vfo_sb = tk.Spinbox(
                frame,
                from_=VFO.low_frequency_limit,
                to=VFO.high_frequency_limit,
                wrap=False,
                command=self.on_frequency_change,
                increment=self.step,
                font=self.font(),
                width=width,
                repeatdelay=300,
                repeatinterval=50,
                format='%5.3f',
                justify='right',
                state='normal',
                cursor='hand2',
                fg=fg,
                )
        self.vfo_sb.grid(row=0, column=0, sticky='w')
        self.vfo_sb.bind('<Return>', self.set_frequency)

        self.step_sb = tk.Spinbox(
                frame,
                command=self.on_step_sb_changed,
                values=tuple(VFO.texts),
                font=self.font(),
                width=6,
                justify='right',
                state='readonly',
                fg=fg,
                bg=self.bg,
                readonlybackground=self.bg,
                activebackground=abg,
                )
        self.step_sb.delete(0, 'end')
        self.step_sb.insert(0, '100 Hz')

        self.step_cb_val = tk.StringVar()

        # Define the style for vfo widget
        stylename = str(self) + '.TCombobox'
        style = ttk.Style()
        style.configure(stylename, background=self.bg, foreground=fg)

        self.step_cb = ttk.Combobox(
                frame,
                textvar=self.step_cb_val,
                font=self.font(),
                values=VFO.texts,
                height=len(VFO.texts),
                width=6,
                justify='right',
                state='readonly',
                style=stylename,
                )
        self.step_cb_val.trace('w', self.on_step_cb_changed)

        if step_spinbox:
            self.step_sb.grid(row=0, column=1, sticky='w')
        else:
            self.step_cb.grid(row=0, column=1, sticky='w')

        frame.grid(row=0, column=0, sticky='w')

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        self.enter_frequency_wrapper = (Page.top.register(self.enter_frequency), '%P', '%V')
        self.vfo_sb.configure(validate='all', validatecommand=self.enter_frequency_wrapper)
        self.server.subscribe_cmds('F{vfo}'.format(vfo=self.AorB), self.on_frequency_received)
        step_cmd = 'VT'
        if self.AorB == 'B':
            step_cmd += '$'
        self.server.subscribe_cmds(step_cmd, self.on_step_received)

        # subscribe to split and transmit on/off changes
        self.server.subscribe_cmds('FT', self.set_vfo_bg)
        self.server.subscribe_cmds('TQ', self.set_vfo_bg)
        self.vfo_sb.bind('<Visibility>', self.set_vfo_bg)

    def enter_frequency(self, p, v):
        try:
            float(p)
        except:
            return False

        if v == 'focusin' or v == 'key':
            return True
        elif v == 'focusout':
            return self.set_frequency()

    def set_frequency(self, event=None):
        Page.top.focus()                # Remove focus from vfo_sb
        freq = float(self.vfo_sb.get())
        if freq < VFO.low_frequency_limit:
            self.set_vfo_sb(VFO.low_frequency_limit)
            return False
        if freq > VFO.high_frequency_limit:
            self.set_vfo_sb(VFO.high_frequency_limit)
            return False

        self.send_frequency()
        self.set_vfo_bg()
        return True

    def on_frequency_change(self):
        freq = int(float(self.vfo_sb.get()) * 1000)
        mod = freq % int(self.step * 1000)
        freq -= mod
        if mod != 0:
            self.set_vfo_sb(freq/1000)
        Poll.add_poll(50, self.send_frequency)

    def send_frequency(self):
        Poll.remove_poll(50, self.send_frequency)
        freq = int(float(self.vfo_sb.get()) * 1000)
        freq11 = "{:011d}".format(freq)
        cmd = "F{vfo}{freq};".format(vfo=self.AorB, freq=freq11)
        self.server.send_cmds(cmd)

    def on_frequency_received(self, response):
        freq_str = response_after_base(response)[0:11]
        self.set_vfo_sb(float(freq_str)/1000)
        self.set_vfo_bg()

    def set_vfo_sb(self, freq):
        self.vfo_sb.configure(validate='none')
        self.vfo_sb.delete(0, 'end')
        self.vfo_sb.insert(0, "{:5.3f}".format(freq))
        self.vfo_sb.configure(validate='all')

    def on_step_sb_changed(self):
        text = self.step_sb.get()
        self.set_step(text)

    def on_step_cb_changed(self, var, index, mode):
        text = self.step_cb_val.get()
        if text != '':
            self.set_step(text)

    def set_step(self, text):
        self.step = VFO.steps[VFO.text_to_index[text]]
        self.vfo_sb.config(increment=self.step)
        cmd = 'VT'
        if self.AorB == 'B':
            cmd += '$'
        cmd += str(VFO.step_to_index[self.step])
        cmd += self.current_mode_index()
        self.server.send_cmds(cmd + ';')

    def on_step_received(self, response):
        step_str = response_after_base(response)
        step_index = int(step_str[0])
        if step_index == 5:                             # Work around an apparent K4 bug
            cmd = 'VT'
            if self.AorB == 'B':
                cmd += '$'
            self.server.send_cmds(cmd + '2;')
            step_index = 2
        self.step = VFO.steps[step_index]
        self.vfo_sb.config(increment=self.step)
        text = VFO.texts[VFO.step_to_index[self.step]]
        self.step_sb.configure(state='normal')
        self.step_sb.delete(0, 'end')
        self.step_sb.insert(0, text)
        self.step_sb.configure(state='readonly')
        self.step_cb_val.set(text)

    def current_mode_index(self):
        cmd = 'MD'
        if self.AorB == 'B':
            cmd += '$'
        return self.server.k4_parameter(cmd)

    def set_vfo_bg(self, arg=None):
        split = self.server.k4_parameters.get('FT') == '1'
        transmit = self.server.k4_parameters.get('TQ') == '1'
        if split ^ (self.AorB == 'A'):
            if transmit:
                self.vfo_sb.configure(bg=self.transmit_color)
            else:
                self.vfo_sb.configure(bg=self.active_color)
        else:
            self.vfo_sb.configure(bg=self.bg)

class Slider(Widget):
    def __init__(self, config_info, container):
        required = ['item', 'from', 'to', 'evalcmd', 'evalresponse']
        options = ['orient', 'width', 'length', 'evalincrement', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        self.from_ = config_info['from']
        self.to = config_info['to']
        self.evalcmd = config_info['evalcmd']
        self.evalresponse = config_info['evalresponse']
        orient = config_info.get('orient', 'horizontal')
        width = config_info.get('width', 15)
        length = config_info.get('length', 15)
        self.evalincrement = config_info.get('evalincrement', 1.0)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)

        self.value = tk.DoubleVar()
        self.value.set(0.0)
        self.previous_value = 0.0

        resolution=eval_value(self.evalincrement, self.value.get())

        self.scale = tk.Scale(self.frame,
                         from_=self.from_,
                         to=self.to,
                         orient=orient,
                         resolution=resolution,
                         width=width,
                         length=length,
                         font=self.font(),
                         bg=bg,
                         fg=fg,
                         variable=self.value,
                         command=self.value_changed)
        self.scale.grid(row=0, column=0, sticky='nw')

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        cmd = eval_value(self.evalcmd, self.value.get())
        self.server.subscribe_cmds(cmd, self.on_response_received)

    def value_changed(self, event):
        value = self.value.get()
        next_value = value
        if self.previous_value == value:
            return
        if self.previous_value < value:
            next_value = value + eval_value(self.evalincrement, value)
        self.scale.configure(resolution=eval_value(self.evalincrement, next_value))
        cmd = eval_value(self.evalcmd, value)
        self.previous_value = value
        self.server.send_cmds(cmd)

    def on_response_received(self, response):
        value = float(eval_value(self.evalresponse, response))
        self.value.set(value)
        self.scale.configure(resolution=eval_value(self.evalincrement, value))
        self.previous_value = value

class Getvalue(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['cmd', 'response', 'evalresponse', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        cmd = config_info.get('cmd', None)
        response = config_info.get('response', cmd)
        self.evalresponse = config_info.get('evalresponse', cmd)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg
        justify = config_info.get('justify', 'center')

        self.server.expand_and_send_cmds(cmd)

        self.label = tk.Label(self.frame,
                    bd='2',
                    font=sef.font(),
                    justify=justify,
                    fg=fg,
                    bg=bg,
                    activebackground=abg,
                    activeforeground=afg,
                    padx=2,
                    pady=2)

        self.label.grid(row=0, column=0, sticky='w')

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        self.server.subscribe_cmds(response, self.on_response_received)

    def on_response_received(self, response):
        value = eval_value(self.evalresponse, response)
        self.label.configure(text=value)

class Bargraph(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['cmd', 'response', 'evalresponse', 'orient', 'maximum', 'evalmaximum',
                   'length', 'lengthpercent', 'lefttext', 'bottomtext', 'evalbottomtext',
                   'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        self.cmd = config_info.get('cmd', None)
        self.response = config_info.get('response', self.cmd)
        self.evalresponse = config_info.get('evalresponse', self.response)
        orient = config_info.get('orient', 'horizontal')
        self.maximum = config_info.get('maximum', 100)
        self.evalmaximum = config_info.get('evalmaximum', None)
        self.length = config_info.get('length', 100)
        self.length_percent = config_info.get('lengthpercent', None)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg

        self.left_text = config_info.get('lefttext', '')
        self.bottomtext = config_info.get('bottomtext', '')
        self.evalbottomtext = config_info.get('evalbottomtext', None)

        bar_frame = tk.Frame(self.frame)

        self.left_frame = tk.Frame(bar_frame)
        if self.left_text != '':
            left_label = tk.Label(self.left_frame,
                text=self.left_text,
                bd=0,
                font=self.font(),
                justify='left',
                fg=fg,
                bg=bg,
                activebackground=abg,
                activeforeground=afg,
                padx=0,
                pady=2)

            left_label.grid(row=0, column=0, sticky='w')
        self.left_frame.grid(row=0, column=0, sticky='w')

        self.progressvalue = tk.IntVar()
        self.progressbar = ttk.Progressbar(bar_frame,
                    orient=orient,
                    variable=self.progressvalue,
                    maximum=self.maximum + .001,
                    length=self.length)

        self.progressbar.grid(row=0, column=1, sticky='w')

        bar_frame.grid(row=0, column=0, sticky='w')

        self.bottom_frame = tk.Frame(self.frame)
        if self.bottomtext != None or self.evalbottomtext != None:
            self.bottom_label = tk.Label(self.bottom_frame,
                text=self.bottomtext,
                bd=0,
                font=self.font(),
                justify='left',
                fg=fg,
                bg=bg,
                activebackground=abg,
                activeforeground=afg,
                padx=0,
                pady=2)

            self.bottom_label.grid(row=0, column=0, sticky='w')
        self.bottom_frame.grid(row=1, column=0, sticky='w')

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        self.frame.bind('<Visibility>', self.configure)
        self.server.expand_and_send_cmds(self.cmd)
        self.server.subscribe_cmds(self.response, self.on_response_received)

    def on_response_received(self, response):
        value = int(self.eval_value(self.evalresponse, response))
        self.progressvalue.set(value)
        self.configure()

    def configure(self, event=None):
        bottomtext = self.bottomtext
        if self.evalbottomtext != None:
            bottomtext = self.eval_value(self.evalbottomtext, None)
        self.bottom_label.configure(text=bottomtext)
        if self.bottom_label.winfo_viewable():
            self.bottom_frame.update()
        bottom_width = self.bottom_frame.winfo_width()
        left_width = self.left_frame.winfo_width()
        length = self.length
        if self.length_percent != None:
            length = (bottom_width - left_width) * self.length_percent / 100.0
        maximum = self.maximum
        if self.evalmaximum != None:
            maximum = float(self.eval_value(self.evalmaximum, None)) + .001
        self.progressbar.configure(length=length, maximum=maximum)

class Text(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['text', 'label', 'leading', 'fg', 'bg', 'justify', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        text = config_info.get('text', '')
        fg = config_info.get('fg', Default.fg)
        bg = config_info.get('bg', Default.bg)
        justify = config_info.get('justify', 'center')

        label = tk.Label(self.frame,
                    text=text,
                    bd='2',
                    font=self.font(),
                    justify=justify,
                    fg=fg,
                    bg=bg,
                    padx=2,
                    pady=2)

        label.grid(row=0, column=0, sticky='w')

class Notebook(Container):
    def __init__(self, config_info, container):
        required = ['item', 'contains']
        options = ['server', 'childwidth', 'label_font', 'button_font']

        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        if not has_tabnames():
            raise Exception('notebook contains items without tabnames')

        self.frame = None
        self.show_widgets()

        notebook = ttk.Notebook(self.frame)
        notebook.grid()

        for child in self.children:
            if not isinstance(child, Group):
                raise Exception('Notebook contains an item that is not a group', child)
            notebook.add(child.frame, text=child.tabname)

class Dropdownbutton(Widget):
    def __init__(self, config_info, container):
        required = ['item', 'selections']
        options = ['bg', 'abg', 'fg', 'afg', 'selectbg', 'selectfg', 'width', 'justify', 'unexpectedresponse', 'label', 'leading']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        texts = []
        self.text_to_index = {}

        self.index = 0
        self.blink_state = False

        self.selections = []

        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg
        self.selectbg = config_info.get('selectbg', bg)
        self.selectfg = config_info.get('selectfg', fg)
        justify = config_info.get('justify', 'right')

        self.unexpected_response = config_info.get('unexpectedresponse', '')

        width = 0

        conf_selections = config_info.get('selections', None)
        for index, conf_sel in enumerate(conf_selections):
            index = len(self.selections)
            selection = {}

            required = []
            options = ['text', 'cmd', 'response', 'blink']
            validate_config_options(conf_sel, required, options, name='dropdownbutton.selection')

            text = conf_sel.get('text', '')
            selection['text'] = text
            texts.append(text)
            self.text_to_index[text] = index
            if len(text) > width:
                width = len(text)

            cmd = conf_sel.get('cmd', None)
            orig_response = conf_sel.get('response', cmd)
            selection['response'] = orig_response

            selection['parameters'] = {}
            cmds = self.server.expand_server_cmds(cmd)
            responses = self.server.expand_server_cmds(orig_response)
            for response in responses:
                base = cmd_base(response)
                if Server.k4_set_only_cmd(base, response):
                    if len(cmds) <= 1 and len(responses) <= 1:
                        raise Exception("Set-only command: '{cmd}' not permitted in Dropdownbutton".format(cmd=orig_response))
                    continue
                if Server.k4_get_only_cmd(base) and len(cmds) <= 1 and len(responses) <= 1:
                    raise Exception("Get-only command: '{cmd}' not permitted in Dropdownbutton".format(cmd=orig_response))
                response = response[len(base):]
                selection['parameters'][base] = response

            selection['cmd'] = cmd
            selection['blink'] = conf_sel.get('blink', False)
            self.selections.append(selection)

        if config_info.get('width', None) != None:
            width = config_info['width']
        elif self.container.childwidth != None:
            width = self.container.childwidth

        # Define the style for this dropdown widget
        self.stylename = str(self) + '.TCombobox'
        self.style = ttk.Style()
        self.style.configure(self.stylename, background=bg, foreground=fg, selectbackground=self.selectbg, selectforeground=self.selectfg)

        self.val = tk.StringVar()

        self.combobox = ttk.Combobox(
                self.frame,
                textvar=self.val,
                font=self.font(),
                values=texts,
                height=len(texts),
                width=width,
                state='readonly',
                justify=justify,
                style=self.stylename,
                )

        self.val.trace('w', self.on_combobox_changed)

        self.combobox.grid(row=0, column=0, sticky='e')

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        for selection in self.selections:
            self.server.subscribe_cmds(selection['response'], self.on_response_received)

    def on_combobox_changed(self, var, index, mode):
        text = self.val.get()
        if text == '':
            return

        index = self.text_to_index.get(text, None)
        if index != None:
            self.index = index
            selection = self.selections[self.index]
            cmd = selection['cmd']
            if cmd != None:
                self.server.expand_and_send_cmds(cmd)

    def compare_parameters(self, text, parameters):
        for base in parameters.keys():
            dprint2('commpare :{text} s: {s}, b: {b}'.format(text=text, s=self.server.k4_parameters.get(base, None), b=parameters[base]))
            if parameters[base] != self.server.k4_parameters.get(base, None):
                return False
        dprint2('Match')
        return True

    def on_response_received(self, response):
        found = False
        for index, selection in enumerate(self.selections):
            if self.compare_parameters(selection['text'], selection['parameters']):
                self.index = index
                self.combobox.state='normal'
                self.val.set(selection['text'])
                self.combobox.state='readonly'
                if selection['blink']:
                    self.blinkon()
                else:
                    self.blinkoff()
                found = True
        if not found:
            if self.unexpected_response != '':
                text = eval_value(self.unexpected_response, response)
            else:
                text = ''

            self.combobox.state='normal'
            self.val.set(text)
            self.combobox.state='readonly'

    def blinkon(self):
        Poll.add_poll(Widget.blink_mS, self.blink)

    def blinkoff(self):
        Poll.remove_poll(Widget.blink_mS, self.blink)

    def blink(self):
        self.blink_state = not self.blink_state
        if self.blink_state:
            self.style.configure(self.stylename, selectbackground=self.selectfg, selectforeground=selectbg)
        else:
            self.style.configure(self.stylename, selectbackground=self.selectbg, selectforeground=selectfg)

def cmd_base(cmd):
    ucmd = cmd.upper()
    base = ucmd[0:2]
    if base in Server.k4_long_cmd_bases:
        for long_base in Server.k4_long_cmd_bases[base]:
            if ucmd.startswith(long_base):
                base = long_base
                break
    if len(cmd) > len(base) and cmd[len(base)] == '$':
        base += '$'
    return base

def cmd_get_format(cmd):
    base = cmd_base(cmd)
    get_base = base
    if base == 'ML':
        get_base = cmd[0:3]
    elif base == 'BR':
        get_base = cmd[0:3]
    elif base == 'PK':
        get_base = cmd[0:4]
    return get_base + ';'

def response_after_base(response):
    i = len(cmd_base(response))
    return response[i:]

def true_values(v):
    if v == True or v == 1:
        return True

    if not isinstance(v, str):
        return False

    v = v.lower()
    return v == 'true' or v == 'on' or v == '1' or v == 'yes'

def directive_command(self, directive):
    special_strings = {
        'connect': self.server.connect,
        'quit': cleanup_and_exit,
        'show_previous_page': Page.show_previous,
    }

    if directive in special_strings:
        command = special_strings[directive]
    elif directive.startswith('show_page '):
        page_name = directive[len('show_page '):]
        command = lambda: Page.show_page(page_name)
    else:
       raise Exception('Unknown directive: ', directive)
    return command

class Menu_definition():
    def __init__(self, menu, d):
        self.menu = menu
        self.index = int(d[0])
        self.desc = hex_decode(d[1])
        self.area = d[2]
        self.type = d[3]
        self.locked = 'Unlocked' if d[4] == '0' else 'Locked' if d[4] == '1' else 'Unmodifiable' if d[4] == '2' else ''
        self.low = self.typed_value(d[5])
        self.high = self.typed_value(d[6])
        self.default = self.typed_value(d[7])
        self.current = self.typed_value(d[8])
        self.increment = self.typed_value(d[9])
        self.values = []
        for value in d[10:]:
            self.values.append(hex_decode(value))
        self.container = menu.container
        self.server = menu.server

        self.send_command = self.widget_send_command

        self.updated_desc = self.desc

        self.widget = None
        self.changeable = ''

        self.frame = tk.LabelFrame(self.menu.frame,
                                   text=self.desc,
                                   font=self.menu.label_font(),
                                   labelanchor='nw',
                                   bd=4,
                                   relief='raised')

        if len(self.values) > 0:
            self.listbox()
        elif self.type == 'BIN':
            self.range_listbox()
        elif self.type == 'VFOCRS':
            self.vfocrs()
        elif self.type == 'AOFS':
            self.aofs()
        elif self.type == 'M50Hz':
            self.m50hz()
        elif self.type == 'ZMON':
            self.zmon()
        elif self.type == 'D10mW':
            self.d10mw()
        elif self.type in ('DEC', 'REF', 'ms', 'ZOFF', 'MHz', 'Hz'):
            self.slider()
        elif self.type in ('IP', 'SN'):
            self.fixed_text()
        elif self.type == 'STR':
            self.text()

        self.locked_frame = tk.Frame(self.frame)
        self.locked_frame.grid(row=0, column=1)

        self.locked_button = tk.Button(self.locked_frame,
                    bd='2',
                    text=self.locked,
                    font=self.menu.font(),
                    width=12,
                    justify='center',
                    relief='raised',
                    fg=self.menu.fg,
                    bg=self.menu.bg,
                    activebackground=self.menu.abg,
                    activeforeground=self.menu.afg,
                    padx=2,
                    pady=2,
                    command=self.on_locked_changed)

        self.locked_button.grid(row=0, column=0)

        self.default_button = tk.Button(self.locked_frame,
                    bd='2',
                    text="Set to\nNormal",
                    font=self.menu.font(),
                    width=12,
                    justify='center',
                    relief='raised',
                    fg=self.menu.fg,
                    bg=self.menu.bg,
                    activebackground=self.menu.abg,
                    activeforeground=self.menu.afg,
                    padx=2,
                    pady=2,
                    command=self.on_default_clicked)

        self.default_button.grid(row=1, column=0)

    def null_update(self, current=None):
        pass

    def on_locked_changed(self):
        if self.locked == 'Locked':
            if self.changeable == 'Locked':
                self.changeable = 'Unlocked'
            else:
                self.changeable = 'Locked'

        self.update()

    def update(self, locked=None, current=None):
        self.update_widget(current=current)

        if locked != None:
            self.changeable = locked

        if self.changeable == 'Unmodifiable':
            self.default_button.grid_forget()
        elif self.changeable == 'Unlocked':
            self.default_button.grid(row=1, column=0)
            self.default_button.configure(state='normal')
        else:
            self.default_button.grid(row=1, column=0)
            self.default_button.configure(state='disabled')

        self.locked_button.configure(text=self.changeable)

        self.update_desc()

    def update_desc(self):
        desc = self.updated_desc
        if self.area == 'XV':
            if self.type == 'DEC':
                self.menu.xv_band = int(self.current)
            else:
                self.updated_desc = self.desc.replace('<n>', str(self.menu.xv_band))

            if self.updated_desc != desc:
                self.menu.listbox.delete(self.position)
                self.menu.listbox.insert(self.position, self.updated_desc)

        if self.type == 'ms':
            self.updated_desc = self.desc + "\n(mS)"

        if self.type == 'ZMON':
            self.updated_desc = self.desc + "\n(-1 = OFF, 0 = MON)"

        if self.type == 'ZOFF':
            self.updated_desc = self.desc + "\n(0 = OFF)"

        if self.type == 'MHz':
            self.updated_desc = self.updated_desc + "\n(MHz)"

        if self.type == 'D10mW':
            self.updated_desc = self.updated_desc + "\n(mW)"

        if self.type == 'Hz':
            self.updated_desc = self.updated_desc + "\n(Hz)"

        if self.updated_desc != desc:
            self.frame.configure(text=self.updated_desc)
        
    def current_desc(self):
        return self.updated_desc

    def on_default_clicked(self):
        if self.changeable == 'Unlocked':
            self.update(current=self.default)
            self.send_command()

    def show(self):
        self.update(locked=self.locked)
        self.frame.grid(row=0, column=2)

    def hide(self):
        self.frame.grid_forget()

    def listbox(self):
        self.update_widget = self.listbox_update
        self.widget = tk.Listbox(
                self.frame,
                font=self.menu.font(),
                justify='left',
                bg=self.menu.bg,
                fg=self.menu.fg,
                selectbackground=self.menu.selectbg,
                selectforeground=self.menu.selectfg,
                exportselection=False,
                )

        if self.low != 0:
            raise Exception('Unexpected listbox low ', self.low)

        high = self.high + 1
        if high < len(self.values):
            self.values = self.values[:high]
        
        width = 0
        for value in self.values:
            value = str(value)
            if len(value) > width:
                width = len(value)
            self.widget.insert(tk.END, value)

        width = int(round(width*1.1)+1)
        self.widget.configure(height=len(self.values), width=width)
        self.widget.selection_clear(0, tk.END)
        self.widget.selection_set(self.current)
        selections = self.widget.curselection()
        if len(selections) > 0:
            index = selections[0]

        self.widget.grid(row=0, column=0)
        self.widget.bind('<<ListboxSelect>>', self.on_listbox_selected)

    def on_listbox_selected(self, arg):
        if self.changeable != 'Unlocked':
            self.widget.selection_clear(0, tk.END)
            self.widget.selection_set(self.current)
            return

        selections = self.widget.curselection()
        index = selections[0]
        self.current = index
        self.send_command()

    def listbox_update(self, current=None):
        if current != None:
            self.current = current
        self.widget.selection_clear(0, tk.END)
        self.widget.selection_set(self.current)

    def vfocrs(self):
        self.values = ('0.1 kHz', '0.5 kHz', '1.0 kHz', '2.5 kHz')
        self.listbox()

    def m50hz(self):
        self.values = ('150 Hz', '200 Hz', '250 Hz', '300 Hz', '350 Hz', '400 Hz', '450 Hz', '500 Hz', '550 Hz', '600 Hz', '650 Hz', '700 Hz')
        self.high -= self.low
        self.low = 0
        self.listbox()
        self.send_command = self.m50hz_send_command
        self.update_widget = self.m50hz_update

    def m50hz_send_command(self):
        value = int(self.current) + 3
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def m50hz_update(self, current=None):
        if current != None:
            self.current = current - 3
        self.listbox_update()

    def aofs(self):
        self.low -= 8
        self.high -= 8
        self.slider()
        self.send_command = self.aofs_send_command
        self.update_widget = self.aofs_update

    def aofs_send_command(self):
        value = int(self.current) + 8
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def aofs_update(self, current=None):
        if current != None:
            self.current = current - 8
        self.slider_update()

    def zmon(self):
        self.low -= 1
        self.high -= 1
        self.slider()
        self.send_command = self.zmon_send_command
        self.update_widget = self.zmon_update

    def zmon_send_command(self):
        value = int(self.current) + 1
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def zmon_update(self, current=None):
        if current != None:
            self.current = current - 1
        self.slider_update()

    def d10mw(self):
        self.low = float(self.low) / 10
        self.high = float(self.high) / 10
        self.increment = float(self.increment) / 10
        self.slider()
        self.send_command = self.d10mw_send_command
        self.update_widget = self.d10mw_update

    def d10mw_send_command(self):
        value = int(self.current * 10)
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def d10mw_update(self, current=None):
        if current != None:
            self.current = float(current) / 10
        self.slider_update()

    def range_listbox(self):
        for i in range(self.low, self.high+1, self.increment):
            self.values.append(i)
        self.high -= self.low
        self.low = 0
        self.listbox()
        self.send_command = self.range_listbox_send_command
        self.update_widget = self.range_listbox_update

    def range_listbox_update(self, current=None):
        if current != None:
            self.current = self.values.index(current)
        self.widget.selection_clear(0, tk.END)
        self.widget.selection_set(self.current)

    def range_listbox_send_command(self):
        value = int(self.values[self.current])
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def slider(self):
        self.update_widget = self.slider_update
        self.value = tk.DoubleVar()
        self.value.set(self.current)

        self.widget = tk.Scale(self.frame,
                         from_=self.high,
                         to=self.low,
                         orient='vertical',
                         resolution=self.increment,
                         width=20,
                         length=font_height(self.menu.font())*9,
                         font=self.menu.font(),
                         bg=self.menu.bg,
                         fg=self.menu.fg,
                         variable=self.value,
                         command=self.slider_value_changed)
        self.widget.grid(row=0, column=0)

    def slider_value_changed(self, event):
        if self.changeable != 'Unlocked':
            self.value.set(self.current)
            return

        self.current = self.value.get()
        self.send_command()

    def slider_update(self, current=None):
        if current != None:
            if isinstance(current, str) and current.find('-') > 0:
                current = current.lstrip('0')
            self.current = current
        self.value.set(self.current)

    def fixed_text(self):
        self.update_widget = self.fixed_text_update
        self.widget = tk.Label(self.frame,
            text=self.current,
            bd=2,
            font=self.menu.font(),
            justify='left',
            fg=self.menu.fg,
            bg=self.menu.bg,
            activebackground=self.menu.abg,
            activeforeground=self.menu.afg,
            padx=2,
            pady=2)
        self.widget.grid(row=0, column=0)

    def fixed_text_update(self, current=None):
        if current != None:
            self.current = current
        self.locked = 'Unmodifiable'
        self.widget.configure(text=self.current)

    def text(self):
        self.update_widget = self.text_update
        self.text_var = tk.StringVar()
        self.text_var.set(self.current)
        self.widget = tk.Entry(self.frame,
            textvariable=self.text_var,
            bd=2,
            font=self.menu.font(),
            justify='left',
            fg=self.menu.fg,
            bg=self.menu.bg)
        self.widget.grid(row=0, column=0)
        self.widget.bind('<Return>', self.set_text)
        self.widget.bind('<FocusOut>', self.set_text)

    def set_text(self, event):
        self.current = self.text_var.get()
        self.send_command()

    def text_update(self, current=None):
        if current != None:
            self.current = current
        self.text_var.set(self.current)

    def widget_send_command(self):
        if isinstance(self.current, str) or self.type == 'REF':
            self.server.send_str('ME{index:04d}.{value};'.format(index=self.index, value=self.current))
        else:
            value = int(round(self.current))
            self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def typed_value(self, n):
        if self.type == 'REF':
            return n
        try:
            n = float(n)
            if int(n) == n:
                n = int(n)
        except:
            pass
        return n

    def print(self):
        print('index', self.index)
        print('desc', self.desc)
        print('area', self.area)
        print('type', self.type)
        print('locked', self.locked)
        print('low', self.low)
        print('high', self.high)
        print('default', self.default)
        print('current', self.current)
        print('increment', self.increment)
        print('values', self.values)

class Menu(Widget):
    last_index = 114
    entries_displayed = 15

    def __init__(self, config_info, container):
        required = ['item']
        options = ['entries_displayed', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'selectbg', 'selectfg', 'font', 'label_font' ]
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        entries_displayed = config_info.get('entries_displayed', Menu.entries_displayed)

        self.current_md = None

        self.bg = config_info.get('bg', Default.bg)
        self.fg = config_info.get('fg', Default.fg)
        self.selectbg = config_info.get('selectbg', Default.bg)
        self.selectfg = config_info.get('selectfg', Default.fg)

        self.definitions = []
        self.lookup_definitions = {}
        self.definitions_requested = False

        self.xv_band = 0

        self.frame = tk.Frame(self.frame)
        self.frame.grid(row=0, column=0)

        self.listbox = tk.Listbox(
                self.frame,
                font=self.font(),
                height=entries_displayed,
                justify='left',
                bg=self.bg,
                fg=self.fg,
                selectbackground=self.selectbg,
                selectforeground=self.selectfg,
                exportselection=False,
                )

        self.scrollbar = tk.Scrollbar(self.frame)
        self.listbox.config(yscrollcommand=self.scrollbar.set)
        self.scrollbar.config(command=self.listbox.yview)

        self.listbox.bind('<<ListboxSelect>>', self.on_listbox_selected)

        self.frame.bind('<Visibility>', self.on_visible)

    def update_definition_list(self):
        self.listbox.delete(0, tk.END)

        width = 0
        for i, md in enumerate(self.definitions):
            md.position = i
            desc = md.current_desc()
            if len(desc) > width:
                width = len(desc)
            self.listbox.insert(tk.END, md.desc)

        self.listbox.configure(width=width)

    def received_all_definitions(self):
        self.server.subscribe_response('ME;', self.on_received_current, send=False)

        self.definitions = sorted(self.definitions, key=lambda d:d.current_desc().casefold())
        self.update_definition_list()

        if Options.debug > 0:
            for md in self.definitions:
                self.server.send_str('ME{index:04d};'.format(index=md.index))   # request current values

        self.server.send_str('ME0043;')         # request updated IP address. We know this has changed.
        self.server.send_str('ME0086;ME0078;ME0076;ME0079;ME0098;ME0077;')   # request current transverter band menu settings

        self.listbox.grid(row=0, column=0, sticky='w')
        self.scrollbar.grid(row=0, column=1, sticky='ns')

    def on_received_current(self, response):
        index, current_value = response[2:].split('.', 1)
        current_value = current_value.rstrip(';')
        index = int(index)
        md = self.lookup_definitions[index]
        current_value = md.typed_value(current_value)
        md.update(current=current_value)

    def on_listbox_selected(self, arg):
        selections = self.listbox.curselection()
        if len(selections) == 0:
            return

        index = selections[0]

        if self.current_md != None and self.current_md.widget != None:
            self.current_md.hide()

        md = self.definitions[index]
        self.current_md = md

        md.show()

    def print_definitions(self):
        for definition in self.definitions:
            tprint(definition)

    def on_visible(self, event=None):
        self.server.subscribe_connect(self.request_definitions)

    def request_definitions(self, event=None):
        if self.definitions_requested:
            return
        self.definitions_requested = True

        self.server.add_ignored_error('MEDF')
        self.server.subscribe_response('MEDF;', self.on_received_definition, send=False)
        for i in range(1, Menu.last_index+10):
            self.server.send_str('MEDF{:04d};'.format(i))

    def on_received_definition(self, response):
        if response[4] == '?':
            return                                 # some errors are expected

        definition_values = response[4:].rstrip(';').split(',')
        if definition_values[3] == 'NULL':                      # md.type
            return

        md = Menu_definition(self, definition_values)
        found = self.lookup_definitions.get(md.index, None)
        if found != None:
            return

        self.lookup_definitions[md.index] = md
        self.definitions.append(md)

        if md.index >= Menu.last_index:
            self.received_all_definitions()
        if md.index > Menu.last_index:
            dprint1('received menu with higher index: {index:04d} {desc}'.format(index=md.index, desc=md.desc))

class Audio():
    singleton = None

    @classmethod
    def get_singleton(cls):
        if cls.singleton == None:
            cls.singleton = Audio()

        return cls.singleton

    @classmethod
    def output_queue(cls, queue):
        self = cls.get_singleton()
        self.output_queue = queue
        self.output_thread = threading.Thread(target=self.output_loop, name='audio_output_thread')
        self.output_thread.start()

    @classmethod
    def close(cls):
        if cls.singleton == None:
            return

        self = cls.singleton
        if self.output_thread != None:
            self.output_thread.join()

    @classmethod
    def device_infos(cls):
        self = cls.get_singleton()
        return self.device_infos

    @classmethod
    def input_sample_rate(cls):
        self = cls.get_singleton()
        return self.device_infos[self.input_device_index]['default_sample_rate']

    @classmethod
    def output_sample_rate(cls):
        self = cls.get_singleton()
        return self.device_infos[self.output_device_index]['default_sample_rate']

    @classmethod
    def set_input_device_name(cls, name):
        self = cls.get_singleton()
        dev_info = self.device_info_by_name(name)
        self.input_device_index = dev_info['index']

    @classmethod
    def set_output_device_name(cls, name):
        self = cls.get_singleton()
        dev_info = self.device_info_by_name(name)
        self.output_device_index = dev_info['index']

    @classmethod
    def input_device_name(cls):
        self = cls.get_singleton()
        dev_info = self.device_infos[self.input_device_index]
        return dev_info['name']

    @classmethod
    def output_device_name(cls):
        self = cls.get_singleton()
        dev_info = self.device_infos[self.output_device_index]
        return dev_info['name']

    @classmethod
    def input_device_info(cls):
        self = cls.get_singleton()
        return self.device_infos[self.input_device_index]

    @classmethod
    def output_device_info(cls):
        self = cls.get_singleton()
        return self.device_infos[self.output_device_index]

    @classmethod
    def input_device_index(cls):
        self = cls.get_singleton()
        return self.input_device_index

    @classmethod
    def output_device_index(cls):
        self = cls.get_singleton()
        return self.output_device_index

    @classmethod
    def input_device_names(cls):
        self = cls.get_singleton()
        names = []
        for index in self.device_infos:
            device_info = self.device_infos[index]
            if device_info['input_channels'] > 0:
                names.append(device_info['name'])
        return names

    @classmethod
    def output_device_names(cls):
        self = cls.get_singleton()
        names = []
        for index in self.device_infos:
            device_info = self.device_infos[index]
            if device_info['output_channels'] > 0:
                names.append(device_info['name'])
        return names

    def __init__(self):
        self.input_thread = None
        self.output_thread = None
        self.input_device_index = 0
        self.output_device_index = 0
        self.device_infos = {}

        fd = os.dup(2)
        os.close(2)              # Close stderr because pyaudio outputs a lot of disquieting messages
        pa = pyaudio.PyAudio()

        info = pa.get_host_api_info_by_index(0)
        numdevices = info.get('deviceCount')

        default_input_device_index = pa.get_default_input_device_info()['index']
        default_output_device_index = pa.get_default_output_device_info()['index']

        for i in range(0, numdevices):
            info = pa.get_device_info_by_host_api_device_index(0, i)
            if info['name'] in [ 'dmix', 'lavrate', 'samplerate', 'speexrate', 'pulse', 'speex', 'upmix', 'vdownmix' ]:
                continue
            default_sample_rate = info['defaultSampleRate']
            device_info = { 'default_sample_rate': int(default_sample_rate), 'input_channels': 0, 'output_channels': 0 }

            try:
                if pa.is_format_supported(default_sample_rate,
                             input_device=info['index'],
                             input_channels=1,
                             input_format=pyaudio.paFloat32):
                        device_info['index'] = info['index']
                        device_info['name'] = info['name']
                        device_info['input_channels'] = info['maxInputChannels']
                        if info['index'] == default_input_device_index:
                            self.input_device_index = info['index']

                if pa.is_format_supported(default_sample_rate,
                             output_device=info['index'],
                             output_channels=1,
                             output_format=pyaudio.paFloat32):
                        device_info['index'] = info['index']
                        device_info['name'] = info['name']
                        device_info['output_channels'] = info['maxOutputChannels']
                        if info['index'] == default_output_device_index:
                            self.output_device_index = info['index']
            except:
                pass

            if 'index' in device_info:
                self.device_infos[device_info['index']] = device_info

        os.dup2(fd, 2)           # restore stderr
        os.close(fd)

    def device_info_by_name(self, name):
        for index in self.device_infos:
            dev_info = self.device_infos[index]
            if dev_info['name'] == name:
                return dev_info
        return None

    def output_loop(self):
        output_stream = None
        current_index = None
        warned = False

        while True:
            packet = self.output_queue.get()
            if len(packet) == 0:
                return

            if current_index != self.output_device_index:
                current_index = self.output_device_index
                encode_mode = packet[0]
                if encode_mode != 3:
                    raise Exception('Unsupported audio encode mode:', encode_mode)
                # encode_mode = opus float32

                frame_size = packet[2] << 8 | packet[1]

                sample_rate = packet[3]
                if sample_rate != 0:
                    raise Exception('Unsupported audio sample rate:', sample_rate)
                sample_rate = 12000

                channels = 2

                dec = opuslib.Decoder(sample_rate, channels)

                fd = os.dup(2)
                os.close(2)              # Close stderr because pyaudio outputs a lot of disquieting messages
                pa = pyaudio.PyAudio()
                os.dup2(fd, 2)           # restore stderr
                os.close(fd)

                if output_stream != None:
                    output_stream.close()
                    output_stream = None

                try:
                    output_stream = pa.open(format=pyaudio.paFloat32,
                                            channels=channels,
                                            rate=Audio.output_sample_rate(),
                                            frames_per_buffer=frame_size,
                                            output=True,
                                            output_device_index=self.output_device_index,
                                            )
                    warned = False
                except:
                    if not warned:
                        Popup.warning('Failed to open: ' + self.output_device_name())
                        warned = True
                    continue

            pcm = dec.decode_float(bytes(packet[4:]), frame_size)

            # pydub doesn't support float32, so we convert to int32
            a = numpy.frombuffer(pcm, dtype=numpy.float32)
            a = (a * (2 ** 30 - 1)).clip(-2 ** 30, (2 ** 30 - 1)).astype(numpy.int32)

            aseg = pydub.AudioSegment(data=a.tobytes(), sample_width=4, frame_rate=sample_rate, channels=2)
            aseg = aseg.set_frame_rate(Audio.output_sample_rate())

            # Now we convert back to float32 so we can get some amplification
            channel_sounds = aseg.split_to_mono()
            samples = [s.get_array_of_samples() for s in channel_sounds]
            a = numpy.array(samples).T.astype(numpy.float32)
            a /= (2**30 - 1) / 8              # multiply by 8 for some amplification
            output_stream.write(a.tobytes())

class Settings(Widget):
    settings_filename = 'settings.ini'

    def __init__(self, config_info, container):
        required = ['item']
        options = [ 'label', 'leading', 'bg', 'fg', 'abg', 'afg', 'selectbg', 'selectfg', 'font', 'label_font' ]
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        self.settings = configparser.ConfigParser()
        self.settings_changed = False
        self.load_settings()

        input_device_name = self.get_setting('Audio', 'input_device_name')
        if input_device_name != None:
            Audio.set_input_device_name(input_device_name)

        output_device_name = self.get_setting('Audio', 'output_device_name')
        if output_device_name != None:
            Audio.set_output_device_name(output_device_name)

        self.bg = config_info.get('bg', Default.bg)
        self.fg = config_info.get('fg', Default.fg)
        self.abg = config_info.get('abg', Default.abg)
        self.afg = config_info.get('afg', Default.afg)
        if self.afg == None:
            self.afg = self.fg
        self.selectbg = config_info.get('selectbg', Default.bg)
        self.selectfg = config_info.get('selectfg', Default.fg)

        self.frame = tk.LabelFrame(self.frame,
                              text='Settings',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')
        self.frame.grid(row=0, column=0)

        password_frame = self.password_settings()
        password_frame.grid(row=0, column=0, sticky='w')
        audio_frame = self.audio_settings()
        audio_frame.grid(row=1, column=0, sticky='w')

    def password_settings(self):
        frame = tk.LabelFrame(self.frame,
                              text='K4 Remote Password',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')

        self.password_var = tk.StringVar()
        h = self.get_setting('Elecraft K4', 'insecure_password_hash')
        if h == None:
            pw = ''
        else:
            pw = Reversable_hash.unhash(h)
        if pw != '':
            self.server.set_password(pw)

        self.password_var.set(pw)
        entry = tk.Entry(frame,
            textvariable=self.password_var,
            bd=2,
            font=self.font(),
            show='*',
            justify='left',
            fg=self.fg,
            bg=self.bg)
        entry.grid(row=0, column=0)
        entry.bind('<Return>', self.set_text)
        entry.bind('<FocusOut>', self.set_text)

        return frame

    def set_text(self, event):
        pw = self.password_var.get()
        h = Reversable_hash.hash(pw)
        Settings.password_hash = h
        self.put_setting('Elecraft K4', 'insecure_password_hash', h)
        self.server.set_password(pw)

    def audio_settings(self):
        frame = tk.LabelFrame(self.frame,
                              text='Audio Devices',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')

        audio_input_frame = self.audio_input_settings(frame)
#        Disable display of input settings for now
#        audio_input_frame.grid(row=0, column=0, sticky='w')
        audio_output_frame = self.audio_output_settings(frame)
        audio_output_frame.grid(row=1, column=0, sticky='w')

        return frame

    def audio_input_settings(self, frame):
        input_device_name = self.get_setting('Audio', 'input_device_name')
        if input_device_name == None:
            input_device_name = Audio.input_device_name()

        input_frame = tk.LabelFrame(frame,
                                    text='Current Input Device',
                                    font=self.label_font(),
                                    labelanchor='nw',
                                    bd=4,
                                    padx=4,
                                    pady=4,
                                    relief='raised')

        # Define the style for this dropdown widget
        stylename = str(self) + 'input.TCombobox'
        style = ttk.Style()
        style.configure(stylename, background=self.bg, foreground=self.fg, selectbackground=self.selectbg, selectforeground=self.selectfg)

        input_names = Audio.input_device_names()
        width = 0
        for name in input_names:
            if len(name) > width:
                width = len(name)

        self.input_val = tk.StringVar()
        self.input_val.set(input_device_name)

        input_combobox = ttk.Combobox(
                input_frame,
                textvar=self.input_val,
                font=self.font(),
                values=input_names,
                height=len(input_names),
                width=width,
                state='readonly',
                justify='left',
                style=stylename,
                )
        input_combobox.grid(row=1, column=0, sticky='w')

        self.input_val.trace('w', self.on_input_combobox_changed)

        return input_frame

    def on_input_combobox_changed(self, var, index, mode):
        input_name = self.input_val.get()
        if input_name == '':
            return

        self.put_setting('Audio', 'input_device_name', input_name)
        Audio.set_input_device_name(input_name)

    def audio_output_settings(self, frame):
        output_device_name = self.get_setting('Audio', 'output_device_name')
        if output_device_name == None:
            output_device_name = Audio.output_device_name()

        output_frame = tk.LabelFrame(frame,
                                     text='Current Output Device',
                                     font=self.label_font(),
                                     labelanchor='nw',
                                     bd=4,
                                     padx=4,
                                     pady=4,
                                     relief='raised')

        # Define the style for this dropdown widget
        stylename = str(self) + 'output.TCombobox'
        style = ttk.Style()
        style.configure(stylename, background=self.bg, foreground=self.fg, selectbackground=self.selectbg, selectforeground=self.selectfg)

        output_names = Audio.output_device_names()
        width = 0
        for name in output_names:
            if len(name) > width:
                width = len(name)

        self.output_val = tk.StringVar()
        self.output_val.set(output_device_name)

        output_combobox = ttk.Combobox(
                output_frame,
                textvar=self.output_val,
                font=self.font(),
                values=output_names,
                height=len(output_names),
                width=width,
                state='readonly',
                justify='left',
                style=stylename,
                )
        output_combobox.grid(row=0, column=0, sticky='w')

        self.output_val.trace('w', self.on_output_combobox_changed)

        return output_frame

    def on_output_combobox_changed(self, var, index, mode):
        output_name = self.output_val.get()
        if output_name == '':
            return

        self.put_setting('Audio', 'output_device_name', output_name)
        Audio.set_output_device_name(output_name)

    def put_setting(self, category, setting, value):
        if not category in self.settings:
            self.settings[category] = {}
        previous_value = self.settings[category].get(setting, None)
        if value != previous_value:
            self.settings[category][setting] = value
            self.settings_changed = True
            self.save_settings()

    def get_setting(self, category, setting):
        if category not in self.settings:
            return None
        if setting not in self.settings[category]:
            return None
        return self.settings[category][setting]

    def platform_settings_filename(self, filename):
        if sys.platform == 'darwin':
            from AppKit import NSSearchPathForDirectoriesInDomains
            # http://developer.apple.com/DOCUMENTATION/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSSearchPathForDirectoriesInDomains
            # NSApplicationSupportDirectory = 14
            # NSUserDomainMask = 1
            # True for expanding the tilde into a fully qualified path
            filename = os.path.join(NSSearchPathForDirectoriesInDomains(14, 1, True)[0], appname, filename)
        elif sys.platform == 'win32':
            filename = os.path.join(os.environ['APPDATA'], appname, filename)
        else:
            home_dir = os.path.expanduser('~')
            config_dir = os.path.join(home_dir, '.config')
            if os.path.isdir(config_dir):
                config_dir = os.path.join(config_dir, appname)
            else:
                config_dir = os.path.join(home_dir, '.' + appname)
            if not os.path.isdir(config_dir):
                os.mkdir(config_dir, 0o755)
            filename = os.path.join(config_dir, filename)

        return filename

    def save_settings(self):
        if not self.settings_changed:
            return

        filename = self.platform_settings_filename(Settings.settings_filename)
        with open(filename, 'w') as settingsfile:
            self.settings.write(settingsfile)
        self.settings_changed = False

    def load_settings(self):
        filename = self.platform_settings_filename(Settings.settings_filename)
        self.settings.read(filename)

# A simple reversable string hash function
# Not in any way cryptographically secure
class Reversable_hash():
    @classmethod
    def rhash(cls, n):
        return "%08x" % (n * 387420489 % 4000000000)

    @classmethod
    def un_rhash(cls, h):
        return int(h, 16) * 3513180409 % 4000000000

    @classmethod
    def hash(cls, s):
        hashes = []
        for c in s:
            hashes.append(cls.rhash(ord(c)))
        return ''.join(hashes)

    @classmethod
    def unhash(cls, s):
        i = 0
        chars = []
        for i in range(0, len(s), 8):
            h = s[i:i+8]
            chars.append(chr(cls.un_rhash(h)))
        return ''.join(chars)

class Config():
    main_block_name = ' main'

    @staticmethod
    def preprocess(filename):
        self = Config()
        return self.process(filename)

    def process(self, filename):
        self.filename = filename
        self.blocks = {}
        self.errors = 0

        block_stack = []
        current_block = { 'name':Config.main_block_name, 'lines':[] }
        self.blocks[Config.main_block_name] = current_block
        in_block = False
        line_count = 0
        with open(filename) as stream:
            while True:
                line = stream.readline()
                if line == '':
                    break
                line_count += 1
                match = re.search("^([ \t]*)#(define|end|include)([ \t]+([_A-Za-z][-_A-Za-z0-9]*)([ \t]*)(.*)$)?", line)
                if not match:
                    current_block['lines'].append(line)
                else:
                    indent = match.group(1)
                    directive = match.group(2)
                    after_directive = match.group(3)
                    block_name = match.group(4)
                    trailing = match.group(6)
                    if directive == 'define':
                        if indent != '':
                            dprint('Error ({filename}:{line_count}): #define must be in column 1'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif block_name == None:
                            dprint('Error ({filename}:{line_count}): Invalid block name after #define'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif trailing != '':
                            dprint('Error ({filename}:{line_count}): unexpected characters after #define {name}'.format(filename=filename, line_count=line_count, name=block_name))
                            self.errors += 1
                            continue
                        elif in_block:
                            pname = current_block['name']
                            dprint('Error ({filename}:{line_count}): #define {name}, encountered while defining {pname}'.format(filename=filename, line_count=line_count, name=block_name, pname=pname))
                            self.errors += 1
                            continue
                        elif block_name in self.blocks:
                            dprint('Error ({filename}:{line_count}): #define {name}, redefined. Previously defined at line {pline_count}'.format(filename=filename, line_count=line_count, name=block_name, pline_count=self.blocks[block_name]['line_count']))
                            self.errors += 1
                            continue

                        block_stack.append(current_block)
                        current_block = { 'name':block_name, 'lines':[], 'line_count':line_count }
                        self.blocks[block_name] = current_block
                        in_block = True
                    elif directive == 'end':
                        if not in_block:
                            dprint('Error ({filename}:{line_count}): #end encountered while not defining a block'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif after_directive != None:
                            dprint('Error ({filename}:{line_count}): extra characters found after #end'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        current_block = block_stack.pop()
                        if current_block['name']:
                            in_block = False
                    elif directive == 'include':
                        if block_name == None:
                            dprint('Error ({filename}:{line_count}): Invalid block name after #include'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif trailing != '':
                            dprint('Error ({filename}:{line_count}): unexpected characters after #include {name}'.format(filename=filename, line_count=line_count, name=block_name))
                            self.errors += 1
                            continue
                        line = { 'indent':indent, 'block_name':block_name, 'line_count':line_count }
                        current_block['lines'].append(line)

        if in_block:
            block_name = current_block['name']
            dprint('Error ({filename}:{line_count}): End of file while defining block {block_name}'.format(filename=filename, line_count=line_count, block_name=block_name))
            self.errors += 1

        self.writing_blocks = {}
        indents = []

        if Options.yaml_file != None:
            with open(Options.yaml_file, 'w') as stream:
                self.write_block(stream, Config.main_block_name, '', 1)
        else:
            tmpfile = tempfile.TemporaryFile(mode='w+')
            self.write_block(tmpfile, Config.main_block_name, '', 1)

        if self.errors > 0:
            quit()

        if Options.yaml_file != None:
            quit()

        tmpfile.seek(0)
        return tmpfile

    def write_block(self, file, block_name, indent, line_count):
        if block_name in self.writing_blocks:
            previous_line_count = self.writing_blocks[block_name]
            dprint('Error ({filename}:{line_count}): #include {block_name}, recursively included, previously at {previous_line_count}'.format(filename=self.filename, line_count=line_count, block_name=block_name, previous_line_count=previous_line_count))
            self.errors += 1
            quit()

        self.writing_blocks[block_name] = line_count

        block = self.blocks[block_name]
        for line in block['lines']:
            if isinstance(line, str):
                if line != "\n":
                    line = indent + line
                file.write(line)
            else:
                block_name = line['block_name']
                if block_name not in self.blocks:
                    line_count = line['line_count']
                    dprint('Error ({filename}:{line_count}): #include of undefined block {block_name}.'.format(filename=self.filename, line_count=line_count, block_name=block_name))
                    self.errors += 1
                    continue

                self.write_block(file, block_name, indent + line['indent'], line_count)

        del self.writing_blocks[block['name']]

def read_config(config_file_name):
    with Config.preprocess(config_file_name) as stream:
        try:
            config = yaml.safe_load(stream)
        except yaml.YAMLError as exc:
            print(exc)

        for config_info in config:
            item = config_info['item']
            if item == 'page':
                Page(config_info)
            elif item == 'server':
                Server(config_info)
            elif item == 'defaults':
                Default(config_info)
            else:
                raise Exception("Unexpected top level item '{item}' in '{filename}'.".format(item=item, filename=config_file_name))

def font_height(font):
    return font.metrics("linespace")

class Poll:
    poll_callbacks = {}
    polls = {}
    top = None

    def __init__(self, top):
        Poll.top = top

    def poll(interval):
        for callback in tuple(Poll.poll_callbacks[interval]):
            callback()
        if len(Poll.poll_callbacks[interval]) == 0:
            del Poll.poll_callbacks[interval]
        else:
            Poll.top.after(interval, Poll.polls[interval])

    def add_poll(interval, callback):
        if interval not in Poll.poll_callbacks:
            Poll.poll_callbacks[interval] = []
            Poll.polls[interval] = lambda: Poll.poll(interval)
            Poll.top.after(interval, Poll.polls[interval])
        if not callback in Poll.poll_callbacks[interval]:
            Poll.poll_callbacks[interval].append(callback)

    def remove_poll(interval, callback):
        try:
            Poll.poll_callbacks[interval].remove(callback)
        except:
            pass

    def delayed_call(delay, callback):
        Poll.top.after(delay, callback)

class Options():
    config_file = None
    verbose = 0
    debug = 0
    yaml_file = None

    @staticmethod
    def Parse():
        parser = OptionParser(version=version)
        parser.add_option('-c', '--config', dest='config_file', default='k4companion.yaml',
                          help="use config file FILE", metavar="FILE")
        parser.add_option('-v', '--verbose', action='count', dest='verbose', default = 0,
                          help="output additional status messages")
        parser.add_option('-d', '--debug', action='count', dest='debug', default=0,
                          help="output debugging messages")
        parser.add_option('--yaml', dest='yaml_file', default=None,
                          help="output preprocessed YAML to FILE", metavar="FILE")
        (options, args) = parser.parse_args()

        Options.config_file = options.config_file
        Options.verbose = options.verbose
        Options.debug = options.debug
        Options.yaml_file = options.yaml_file

        if Options.debug > 0 and Options.verbose == 0:
            Options.verbose = Options.debug

        if len(args) != 0:
            parser.error("Unexpected argument '{arg}'".format(arg=args[0]))

def cleanup_and_exit():
    for server in Server.servers():
        server.close()

    Audio.close()

    quit()

def eval_value(s, value):
    try:
        ret = eval(str(s))
    except Exception as err:
        dprint('value: "{value}", eval("{s}")'.format(value=value, s=s))
        dprint('exception: {err}'.format(err=err))
        raise
    return ret

class Popup():
    @staticmethod
    def popup(msg='', title='', timeout=None, font=None, color='yellow'):
        if isinstance(msg, str):
            msg = [ msg ]
        msg = "\n\n".join(msg)
        popup = Popup(title=title, timeout=timeout, font=font, color=color)
        label = tk.Label(popup.frame, text=msg, anchor='center', justify='left', font=font, bg=color)
        label.grid(row=0, column=0)
        popup.show()

    @staticmethod
    def warning(msg):
        if isinstance(msg, str):
            msg = 'Warning: ' +  msg
        else:
            msg[0] = 'Warning: ' + msg[0]
        Popup.popup(msg=msg, title='Warning', timeout=2000, font=None, color='yellow')

    @staticmethod
    def error(msg):
        if isinstance(msg, str):
            msg = 'Warning: ' +  msg
        else:
            msg[0] = 'Warning: ' + msg[0]
        Popup.popup(msg=msg, title='Error', timeout=5000, font=None, color='yellow')

    def __init__(self, title='', timeout=None, font=None, color='yellow', modal=False):
        self.timeout = timeout
        self.popup = tk.Toplevel(Page.top)
        self.popup.title(title)
        if font == None:
            font = Page.main().font()
        size = font.cget('size')
        self.frame = tk.Frame(self.popup, padx=size*2, pady=size*2, bg=color)
        self.popup.attributes('-topmost', True)

    def show(self):
        self.frame.grid()
        if self.timeout != None:
            self.popup.after(self.timeout, self.popup.destroy)

    def wait(self):
        self.frame.grid()
        self.frame.wait_window()

    def close(self, event=None):
        self.popup.destroy()

    def password_button_clicked(self):
       if self.password_show_button.cget('text') == 'Show':
           self.password_show_button.configure(text='Hide')
           self.password_entry.configure(show='')
       else:
           self.password_show_button.configure(text='Show')
           self.password_entry.configure(show='*')

    def password_entered(self, event=None):
        if self.password_var.get() != '':
            self.close()

    def password(msg='', title='', font=None, color='yellow'):
        if isinstance(msg, str):
            msg = [ msg ]
        msg = "\n\n".join(msg)
        popup = Popup(title=title, font=font, color=color, modal=True)
        label = tk.Label(popup.frame, text=msg, anchor='w', justify='left', font=font, bg=color)
        label.grid(row=0, column=0, sticky='w')
        var = tk.StringVar()
        frame = tk.Frame(popup.frame, bg=color)
        frame.grid(row=1, column=0, sticky='w')
        entry = tk.Entry(frame, textvariable=var, show='*', justify='left', font=font, bg=color)
        entry.grid(row=0, column=0)
        entry.focus()
        entry.bind('<Return>', popup.password_entered)
        show_button = tk.Button(frame, text='Show', font=font, bg=color,
                                command=popup.password_button_clicked)
        show_button.grid(row=0, column=1)
        submit_button = tk.Button(popup.frame, text='Submit', font=font, bg=color,
                                command=popup.close)
        submit_button.grid(row=2, column=0, sticky='w')
        popup.password_var = var
        popup.password_entry = entry
        popup.password_show_button = show_button
        popup.frame.grid()
        popup.popup.transient(Page.top)
        popup.popup.grab_set()
        popup.popup.protocol('WM_DELETE_WINDOW', popup.close)
        Page.top.wait_window(popup.popup)
        return var.get()

def validate_config_options(dictionary, requireds, options, name=None):
    if name == None:
        name = dictionary['item']

    id = ''
    for key in ['label', 'text', 'tabname']:
        if key in dictionary:
            id = dictionary[key]
            break

    options.extend(requireds)
    for option in dictionary.keys():
        if option not in options:
            raise Exception("Unrecognized option '{option}' in item '{name}'{id}.".format(option=option, name=name, id=id))

    for option in requireds:
        if option not in dictionary or dictionary[option] == None:
            if id != '':
                id = ' ({id})'.format(id=id)
            raise Exception("Required option '{option}' missing in item '{name}'{id}.".format(option=option, name=name, id=id))

def hex_decode(string):
    return re.sub('%(..)', lambda m: chr(int(m[1], 16)), string)

def dprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def dprint1(*args, **kwargs):
    if Options.debug >= 1:
        print(*args, file=sys.stderr, **kwargs)

def dprint2(*args, **kwargs):
    if Options.debug >= 2:
        print(*args, file=sys.stderr, **kwargs)

def dprint3(*args, **kwargs):
    if Options.debug >= 3:
        print(*args, file=sys.stderr, **kwargs)

def vprint1(*args, **kwargs):
    if Options.verbose >= 1:
        print(*args, **kwargs)

def vprint2(*args, **kwargs):
    if Options.verbose >= 2:
        print(*args, **kwargs)

def tprint(*args, **kwargs):
    print(*args, **kwargs)

main_page_was_visible = False
def main_page_visible(self):
    global main_page_was_visible
    if not main_page_was_visible:
        main_page_was_visible = True
        page = Page.main()
        server = page.server
        if server.connect_on_start:
            server.connect()

def main():
    Options.Parse()

    top = tk.Tk()
    top.title('K4-Companion')
    top.protocol("WM_DELETE_WINDOW", cleanup_and_exit)
    Page.top = top
    Poll(top)

    read_config(Options.config_file)

    page = Page.main()
    page.frame.bind('<Visibility>', main_page_visible)
    Page.show_page(page.name)

    top.mainloop()

if __name__ == '__main__':
    main()

# vim: set expandtab ts=4 sw=4:
