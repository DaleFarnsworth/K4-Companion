#!/usr/bin/env python3

# K4-Companion is an application written in python3 that can remotely
# control and Elecraft K4 tranceiver via TCP/IP.  It currently controls
# the main K4 features and is very useable as is, but new features are
# being added all the time.  K4-Companion is very configurable.
# 
# K4-Companion began life as a simple macro-sending program called
# K4Macro-Python, created by Charles Powell, NK8O. It has now grown far
# beyond a simple macro-sending program into a full-fledged remote control
# program for the K4.
# 
# Please send problem reports either: by sending an email, by entering
# an issue on github, or by making a pull request. Problem reports and
# suggesions are greatly appreciated.
#
# Configuration information is maintained in a separate YAML file named,
# by default, k4companion.yaml.
# 
# Dale Farnsworth, W7DA
# dale@farnsworth.org
#
# Copyright (C) 2025  Dale Farnsworth
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

import configparser
import ctypes
import hashlib
import math
import numpy
import opuslib
import os
import pyaudio
import queue
import re
import select
import socket
import socks
import sys
import tempfile
import textwrap
import threading
import time
import tkinter as tk
import tkinter.ttk as ttk
import tkinter.font as tkFont
import traceback
import yaml

from optparse import OptionParser
from tkinter import simpledialog

appname = 'k4companion'
version = "1.1.31"

class Default():
# may be overriden by values in the config file
    bg = 'maroon1'
    abg = 'red'
    fg = 'black'
    afg = None        # None means same as fg
    selectcolor = 'red'
    label_font =  { 'family': 'Helvetica', 'size': 10, 'weight': 'normal' }
    button_font = { 'family': 'Helvetica', 'size': 10, 'weight': 'normal' }

    def __init__(self, config_info):
        required = ['item']
        options = ['bg', 'abg', 'fg', 'afg', 'selectcolor', 'label_font', 'button_font']
        validate_config_options(config_info, required, options)

        Default.bg = config_info.get('bg', Default.bg)
        Default.abg = config_info.get('abg', Default.abg)
        Default.fg = config_info.get('fg', Default.fg)
        Default.afg = config_info.get('afg', Default.afg)
        Default.selectcolor = config_info.get('selectcolor', Default.selectcolor)
        Default.label_font = config_info.get('label_font', Default.label_font)
        Default.button_font = config_info.get('button_font', Default.button_font)

class Server():
    server_dict = {}
    default_server_name = None
    address_port = None
    proxy_address_port = None
    password = None

    receive_poll_interval = 1           # poll every 1 mS
    ping_poll_interval = 2000           # poll every 2 seconds
    packet_header_len = 8
    packet_trailer_len = 4
    begin_packet_marker = bytes((0xFE, 0xFD, 0xFC,  0xFB))
    end_packet_marker = bytes((0xFB, 0xFC, 0xFD, 0xFE))
    payload_type_cat = 0
    payload_type_audio = 1
    payload_type_pan = 2
    payload_type_minipan = 3
    cat_version_number = 0
    cat_sequence_number = 0
    control_k4_audio_cmd_bases = { 'AG', 'AG$' }
    audio_version_number = 1

    k4_get_cmd_bases = [         # For future use
        '#A',
        'AC',
        'ACM',
        'ACN',
        'ACs',
        'ACT',
        'AF',
        'AG$',
        'AI',
        'AL',
        'AN',
        'AP$',
        '#AR',
        'AR$',
        'AT',
        '#AVG',
        'BG',
        'BI',
        'BL',
        'BN$',
        'BR',
        'BS',
        'BW$',
        '#C',
        'CC',
        '#CUR$',
        'CW',
        '#D',
        'DA',
        'DB$',
        'DN',
        'DO',
        '#DPM',
        'DR$',
        '#DSM',
        'DT$',
        'DV',
        'DW',
        'ER',
        'ES',
        '#F',
        'FA',
        'FB',
        'FC$',
        'FI$',
        'FP$',
        '#FPS',
        'FR',
        '#FRZ',
        'FT',
        'FX',
        '#FXA',
        '#FXT',
        'GT$',
        '#H',
        'HD',
        '#HDPM',
        '#HDSM',
        '#HREF$',
        '#HWBS',
        '#HWFC',
        'ID',
        'IF',
        'IP',
        'IS$',
        'K4',
        'KCL',
        'KP',
        'KS',
        'KZ',
        'KZF',
        'LB',
        'LI',
        'LK$',
        'LN',
        'LO',
        '#M',
        'MA$',
        'MD$',
        'ME',
        'MEDF',
        'MG',
        'MI',
        'ML',
        '#MP$',
        'MS',
        'MX',
        '#N',
        'NA$',
        '#NB$',
        'NB$',
        '#NBL$',
        'NM$',
        'NR$',
        'OM',
        'OV$',
        '#P',
        'PA$',
        'PC',
        'PING',
        'PK',
        '#PKM',
        'PL$',
        'PONG',
        'PP',
        '#R',
        'RA$',
        'RE',
        '#REF$',
        'RG$',
        'RL',
        'RO$',
        'RP',
        'RR',
        'RRC',
        'RRP',
        'RS',
        'RT$',
        'RV',
        '#S',
        'SB',
        'SC',
        '#SCL',
        'SD',
        '#SFL',
        'SI',
        'SL',
        'SM$',
        'SMH',
        'SMH$',
        'SN',
        '#SPM',
        '#SPN$',
        'SQ$',
        'SW',
        'TA',
        'TB$',
        'TD$',
        'TE',
        'TG',
        'TQ',
        'TS',
        'TX',
        'UP',
        'UT',
        '#V',
        'VC',
        '#VFA',
        '#VFB',
        'VG',
        'VI',
        'VO$',
        'VT$',
        'VX',
        '#W',
        '#WBS',
        '#WFC',
        'WM',
        'XT',
        'XV',
        'XV$',
    ]
    k4_long_cmd_bases = {
        '#A': ['#AR', '#AVG'],
        'AC': ['ACM', 'ACS', 'ACT', 'ACN'],
        '#C': ['#CAL', '#CUR'],
        '#D': ['#DPM', '#DSM'],
        'DN': ['DNB'],
        '#F': ['#FPS', '#FRZ', '#FXA', '#FXT'],
        '#H': ['#HDPM', '#HDSM', '#HREF', '#HWBS', '#HWFC', '#HWFH'],
        'KZ': ['KZL', 'KZF'],
        'LO': ['LOG'],
        'ME': ['MEDF'],
        '#M': ['#MP'],
        '#N': ['#NBL', '#NB'],
        'PC': ['PCX'],
        'PI': ['PING'],
        'PO': ['PONG'],
        '#P': ['#PKM'],
        '#R': ['#REF'],
        'RR': ['RRT', 'RRC', 'RRP'],
        'SD': ['SD0C', 'SD1C','SD0V', 'SD1V','SD0D', 'SD1D', 'SDC', 'SDV'],           # Differentiate between the cmd variants
        'SI': ['SIDA', 'SIDD', 'SIDU', 'SIFP', 'SIRF', 'SIRC'],         # SIDU is first after param dump
        'SM': ['SMH'],
        '#S': ['#SCL', '#SFL', '#SPM', '#SPN'],
        'SW': ['SWT', 'SWH'],
        'UP': ['UPB'],
        'VG': ['VGV', 'VGD'],
        '#V': ['#VFA', '#VFB'],
        '#W': ['#WBS', '#WFC', '#WFH'],
        'XV': ['XVN', 'XVM', 'XVR', 'XVI', 'XVO', 'XVP '],
# Directives:
        'CO': ['CONNECT'],
        'QU': ['QUIT'],
        'SH': ['SHOW'],
    }

    # commands that end in +, -, /, \, ^, > are also pseudo set-only commands
    k4_set_only_cmd_bases = {
        'AB': True,
        'DE': True,
        'DM': True,
        'DNB': True,
        'DN': True,
        'EC': True,
        'LI': True,     # where total length of cmd is <= 6 characters
        'MS': True,     # where total length of cmd is <= 4 characters
        'PING': True,
        'RC$': True,
        'RC': True,
        'RD$': True,
        'RD': True,
        'RU$': True,
        'RU': True,
        'SI': True,
        'SP$': True,
        'SP': True,
        'SWH': True,
        'SW': True,
        'SWT': True,
        'UPB': True,
        'UP': True,
# Directives:
        'QUIT': True,
        'SHOW': True,
    }

    set_only_suffixes = {
        '+': True,
        '-': True,
        '/': True,
        '\\': True,
    }

    k4_get_only_cmd_bases = {
        'BG': True,
        'IF': True,
        'MA$': True,
        'MA': True,
        'OM': True,
        'PONG': True,
        'PP': True,
        'RV': True,
        'SM$': True,
        'SMH$': True,
        'SMH': True,
        'SM': True,
        'SN': True,
        'TA': True,
        'TG': True,
        'TQ': True,
        'UT': True,
    }

    @staticmethod
    def server(server_name):
        return Server.server_dict[server_name]

    @staticmethod
    def server_names():
        return Server.server_dict.keys()

    @staticmethod
    def servers():
        return Server.server_dict.values()

    @staticmethod
    def default():
        return Server.server(Server.default_server_name)

    @staticmethod
    def k4_set_only_cmd(base, cmd):
        if base in Server.k4_set_only_cmd_bases:
            if base == 'LI' and len(cmd) > 6:
                return False
            elif base == 'MS' and len(cmd) > 4:
                return False
            else:
                return True
        elif base[-1] in Server.set_only_suffixes:
            return True
        else:
            return False

    @staticmethod
    def k4_get_only_cmd(base):
        return base in Server.k4_get_only_cmd_bases

    @staticmethod
    def send_cmds_with_server(cmd_list):
        for server_name, cmds in cmd_list:
            if server_name in Server.server_names():
                server = Server.server(server_name)
                server.send_cmds(cmds)
            elif server_name == 'delay':
                delay = float(cmd_dict[server_name]) / 1000
                time.sleep(delay)
            else:
                raise Exception("Unknown server name '{name}'".format(name=server_name))

    @staticmethod
    def split_cmd(cmd):
        if cmd[-1] == ';':
            cmd = cmd[0:-1]
        return cmd.split(';')

    def __init__(self, config_info):
        required = ['item', 'name', 'address', 'port']
        options = ['type', 'startup', 'connect_on_start', 'button_font']
        validate_config_options(config_info, required, options)

        self.name = config_info['name']
        self.type = config_info.get('type', '').lower()
        self.startup = config_info.get('startup', None)
        self.address = config_info['address']
        self.port = config_info['port']
        self.proxy_address = ''
        self.proxy_port = ''
        self.connect_on_start = true_values(config_info.get('connect_on_start', True))
        self.socket = None
        self.recv_buffer = ''
        self.send_queue = queue.Queue()
        self.recv_queue = queue.Queue()
        self.output_audio_queue = None
        self.send_thread = None
        self.recv_thread = None
        self.connected = False
        self.k4_subscriptions = {}
        self.k4_parameters = {}
        self.connect_callbacks = []
        self.partial_packet = None
        self.password = None
        self.control_k4_audio = true_values(Settings.get('Audio', 'control_k4_audio_settings'))
        self.audio_sequence_number = 0
        self.received_initial_parameters = False
        self.received_initial_parameters_callbacks = []
        self.cat_only = False

        self.ignored_errors = {}

        if Server.default_server_name == None:
            Server.default_server_name = config_info['name']
        Server.server_dict[self.name] = self

        self.subscribe_connect(self.on_server_connect)
        self.subscribe_response('SIDU', self.on_received_initial_parameters)

    def on_server_connect(self):
        self.subscribe_cmds('ER;', self.on_error_code, send=False)
        self.update_local_audio_parameters()
        if self.type == 'k4' and not self.cat_only:
            Audio.server_connected(self)

    def on_error_code(self, response):
        response = response.rstrip(';')
        try:
            code, text = response.split(':', 1)
            Popup.warning(msg=[code, text])
        except:
            Popup.warning(msg=response)

    def subscribe_connect(self, callback):
        if self.connected:
            callback()
        else:
            self.connect_callbacks.append(callback)

    def update_k4_parameter(self, base, parameter):
        if base in ('TX', 'RX', 'SD0C', 'SD1C','SD0V', 'SD1V','SD0D', 'SD1D'):
            if base == 'TX':
                self.k4_parameters['RX'] = None
            elif base == 'RX':
                self.k4_parameters['TX'] = None
            elif base in ('SD0C', 'SD1C','SD0V', 'SD1V','SD0D', 'SD1D'):   # Differentiate between the variants
                parameter = base[2] + parameter
                base = base[0:2] + base[3]

        old = self.k4_parameters.get(base, None)
        self.k4_parameters[base] = parameter

        callbacks = self.k4_subscriptions.get(base, [])
        for callback in callbacks:
            callback(base + parameter + ';')

        return  old != parameter

    def k4_parameter(self, base):
        return self.k4_parameters.get(base, None)

    def connect(self):
        if self.connected:
            return

        self.cat_only = self.port == 9200

        vprint1('Connecting to {name}, address {addr}, port {port}'.format(
              name=self.name, addr=self.address, port=self.port))

        if self.proxy_address == '':
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        else:
            sock = socks.socksocket(socket.AF_INET, socket.SOCK_STREAM)
            if self.proxy_port == '':
                sock.set_proxy(socks.SOCKS5, self.proxy_address) # SOCKS5 uses port 1080 by default
            else:
                sock.set_proxy(socks.SOCKS5, self.proxy_address, self.proxy_port)
        try:
            sock.settimeout(5)
            sock.connect((self.address, self.port))
            self.connected = True
            self.printed_connection_warning = False
            self.socket = sock
            self.send_thread = threading.Thread(target=self.send_loop, name=self.name+'.send_thread')

            self.send_thread.start()
            if self.cat_only:
                recv_loop = self.cat_only_recv_loop
            else:
                recv_loop = self.recv_loop

            self.recv_thread = threading.Thread(target=recv_loop, name=self.name+'.recv_thread')
            self.recv_thread.start()
            if self.type == 'k4':
                if self.cat_only:
                    self.dequeue_k4_cat()

                    self.send_str('PING;')               # Trigger a response: PONG;
                else:
                    self.output_audio_queue = queue.Queue()

                    if self.password == None:
                        self.password = Popup.password(title="Connect to K4",
                            msg="Enter your k4 remote password:")
                    h = hashlib.sha384(self.password.encode()).hexdigest()
                    self.send_str(h, force_as_string=True)

                    self.wait_for_k4_received_data()
                    self.receive_non_audio_packets()

                    Poll.add(Server.ping_poll_interval, self.ping)

                for callback in self.connect_callbacks:
                    callback()
            error = None

            if not self.cat_only:
                self.received_cat_cmd = False
                Poll.delayed_callback(4000, self.check_for_received_cat_cmd)

        except socket.gaierror:
            error = 'Address not found: {addr}'.format(addr=self.address)
        except OSError:
            error = "Failed to connect to {name}, address {addr}, port {port}\n".format(
                name=self.name, addr=self.address, port=self.port)
            if self.proxy_address != '':
                port = self.proxy_port
                if port == '':
                    port = 'default'
                error += '  via proxy address {addr}, port {port}'.format(
                      name=self.name, addr=self.proxy_address, port=port)

        if error != None:
            dprint(error)
            error += "\n\nCheck the K4 address in the App tab."
            Popup.error(error, timeout=None)

    def check_for_received_cat_cmd(self):
        if not self.received_cat_cmd:
            error = 'No response received from: {name}'.format(name=self.name)
            error += "\n\nCheck the K4 password in the App tab."
            Popup.error(error, timeout=None)

    def request_initial_parameters(self):
        self.send_str('K41;')                # request K4 to respond in advanced mode
        self.send_str('AI4;')                # request K4 to send updates immediately
        self.send_str('ER1;')                # request long format error messages
        self.send_cmds('MD;MD$;')            # cache the mode response for later use in setting the vfo step

        if self.startup != None:
            self.send_cmds(self.startup)     # send user-specified startup commands

        self.send_str('RDY;')

        self.send_str('SIDA0;')              # Disable AI4 delivery of DAP info reports
        self.send_str('SIDD0;')              # Disable AI4 delivery of DDC info reports
        self.send_str('SIFP0;')              # Disable AI4 delivery of FP info reports
        self.send_str('SIRF0;')              # Disable AI4 delivery of RFB info reports
        self.send_str('SIRC0;')              # Disable AI4 delivery of RMT connection info

        self.send_str('RL;')                 # Request the software release line
        self.send_str('RT$;')                # Request the VFO B RIT on/off status
        self.send_str('MX;')                 # Request the audio mixer status

    def subscribe_received_initial_parameters(self, callback):
        if self.received_initial_parameters:
            callback(self)
        else:
            self.received_initial_parameters_callbacks.append(callback)

    def on_received_initial_parameters(self, response):
        self.send_str('SIDU0;')              # Disable AI4 delivery of DUC info reports
        self.received_initial_parameters = True
        for callback in self.received_initial_parameters_callbacks:
            callback(self)

    def close(self):
        self.connected = False
        self.send_queue.put('shutdown')
        if self.output_audio_queue != None:
            self.output_audio_queue.put([])
        if self.send_thread != None:
            self.send_thread.join()
        if self.recv_thread != None:
            self.recv_thread.join()

    def send_str(self, cmd, force_as_string=False):
        if self.cat_only or force_as_string:
            self.send_queue.put((cmd.encode(), ))
        else:
            self.send_cat_packet(cmd.encode())

    def send_cat_packet(self, cat_bytes):
        self.send_queue.put((
            Server.begin_packet_marker,
            self.encode_len(len(cat_bytes)+3), 
            bytes((Server.payload_type_cat, Server.cat_version_number, Server.cat_sequence_number)),
            cat_bytes, 
            Server.end_packet_marker))

    def send_audio_packet(self, audio_bytes, encode_mode, frame_size):
        high = frame_size>>8
        low = frame_size & 0xff
        self.send_queue.put((
            Server.begin_packet_marker,
            self.encode_len(len(audio_bytes)+7),
            bytes((Server.payload_type_audio, Server.audio_version_number, self.audio_sequence_number)),
            bytes((encode_mode, low, high, Audio.k4_sample_rate_code)),
            audio_bytes,
            Server.end_packet_marker))
        self.audio_sequence_number += 1
        if self.audio_sequence_number > 0xff:
            self.audio_sequence_number = 0

    def encode_len(self, l):
        return bytearray(((l>>24)&0xff, (l>>16)&0xff, (l>>8)&0xff, l&0xff))

    def directive(self, base, cmd):
        lcmd = cmd.lower()
        if lcmd == 'connect!':
            self.connect()
        elif lcmd == 'quit!':
            clean_up_and_exit()
        elif base.lower() == 'show!':
            page = lcmd[len(base):].strip()
            if page == 'previous':
                Page.show_previous()
            else:
                Page.show_page(page)
        else:
           raise Exception('Unknown directive: ', directive)

    def send_cmds(self, cmds):
        if self.warn_if_not_connected():
            return
        if isinstance(cmds, str):
            cmds = Server.split_cmd(cmds)
        for cmd in cmds:
            if cmd == '':
                continue
            base = cmd_base(cmd)
            if base[-1] == '!':
                self.directive(base, cmd)
                continue
            if base == 'SB':
                Audio.control_k4_cmd(base, cmd)
            if base in Server.control_k4_audio_cmd_bases:
                Audio.control_k4_cmd(base, cmd)
                if not self.cat_only and not self.control_k4_audio:
                    continue
            if Server.k4_set_only_cmd(base, cmd) or self.update_k4_parameter(base, cmd[len(base):]):
                if self.warn_if_not_connected():
                    return
                cmd += ';'
                self.send_str(cmd)

    def warn_if_not_connected(self):
        if self.connected:
            return False
        if not self.printed_connection_warning:
            Popup.warning("Server '{name}' not connected.".format(name=self.name))
        self.printed_connection_warning = True
        return True

    def send_loop(self):
        while True:
            bs = self.send_queue.get()
            if not self.connected:
                return

            try:
                self.socket.sendmsg(bs)
            except:
                try:
                    for b in bs:
                        self.socket.send(b)
                except:
                    dprint("Failed to send command, '{bs}' to '{name}'".format(bs=bs[3], name=self.name))

            if Options.debug >= 1:
                cmds = None
                if self.cat_only:
                    cmds = bs[0]
                elif bs[0] == Server.begin_packet_marker and bs[2][0] == Server.payload_type_cat:
                    cmds = bs[3]

                if cmds != None:
                    cmds = cmds.decode()
                    if cmds in ['PING;']:
                        dprint4('{name}: sent: {cmds}'.format(name=self.name, cmds=cmds))
                    else:
                        dprint2('{name}: sent: {cmds}'.format(name=self.name, cmds=cmds))

    def expand_cmds(self, cmds):
        if isinstance(cmds, str):
            return [[self.name, Server.split_cmd(cmds)]]
        elif isinstance(cmds, dict):
            cmd_dict = cmds
            ret = []
            for name in cmd_dict:
                cmd = cmd_dict[name]
                ret.append(name, Server.split_cmd(cmd_dict[name]))
            return ret
        elif isinstance(cmds, list):
            ret = []
            for cmd_dict in cmds:
                if not isinstance(cmd_dict, dict):
                    raise Exception("Unknown server sub-command '{cmd}'".format(cmd=cmd_dict))
                for name in cmd_dict:
                    cmd = cmd_dict[name]
                    ret.append(name, Server.split_cmd(cmd_dict[name]))
            return ret
        else:
            raise Exception("Error: bad cmd format: '{cmds}'".format(cmds=cmds))

    def expand_server_cmds(self, cmds):
        if isinstance(cmds, str):
            return Server.split_cmd(cmds)
        ret = []
        for name, cmds in self.expand_cmds(cmds):
            if name == self.name:
                ret.extend(cmds)
        return ret

    def expand_and_send_cmds(self, cmds):
        expanded_cmds = self.expand_cmds(cmds)
        Server.send_cmds_with_server(expanded_cmds)

    def server_cmds(self, cmds):
        ret = []
        expanded_cmds = self.expand_cmds(cmds)
        for server_name, cmds in expanded_cmds:
            if server_name != self.name:
                continue
            for cmd in cmds:
                ret.append(cmd)
        return ret

    def subscribe_cmds(self, cmds, callback, send=True):
        for cmd in self.server_cmds(cmds):
            self.subscribe_response(cmd, callback, send=send)

    def unsubscribe_cmds(self, cmds, callback):
        for cmd in self.server_cmds(cmds):
            self.unsubscribe_response(cmd, callback)

    def ping(self):
        self.send_str('PING;')

    def wait_for_k4_received_data(self):
        select.select([self.socket.fileno()], [], [self.socket], 1)

    def receive_non_audio_packets(self):
        packet_offset = 0

        while True:
            try:
                payload_type, payload = self.recv_queue.get_nowait()
            except queue.Empty:
                Poll.delayed_callback(Server.receive_poll_interval, self.receive_non_audio_packets)
                break

            if payload_type == self.payload_type_cat:
                responses = payload.decode().split(';')[:-1]
                self.receive_k4_responses(responses)
            elif payload_type == self.payload_type_pan:
                self.received_pan(payload)
            elif payload_type == self.payload_type_minipan:
                self.received_minipan(payload)

    def received_pan(self, data):
        #tprint('pan: len:', len(data))
        pass

    def received_minipan(self, data):
        #tprint('minipan: len:', len(data))
        pass

    def dequeue_k4_cat(self):
        while True:
            responses = []

            try:
                recv_bytes = self.recv_queue.get_nowait()
            except queue.Empty:
                Poll.delayed_callback(Server.receive_poll_interval, self.dequeue_k4_cat)
                break

            recv_str = recv_bytes.decode()
            responses = recv_str.split(';')
            if len(responses) == 0:
                continue

            if self.partial_packet != None:
                responses[0] = self.partial_packet + responses[0]
                self.partial_packet = ''

            if responses[-1] != '':
                self.partial_packet = responses[-1]

            responses = responses[0:-1]
            self.receive_k4_responses(responses)

    def receive_k4_responses(self, responses):
        self.received_cat_cmd = True
        for response in responses:
            base = cmd_base(response)
            if base == 'SB':
                Audio.control_k4_cmd(base, response)
            if Options.debug >= 1:
                if base in ('SM', 'SM$', 'SMH', 'SMH$', 'TM', 'PONG', 'DA'):
                    dprint4('{name}: received: {response};'.format(name=self.name, response=response))
                else:
                    dprint2('{name}: received: {response};'.format(name=self.name, response=response))
            if not self.control_k4_audio and base in self.control_k4_audio_cmd_bases:
                continue
            response = response[len(base):]
            if response == '?' and base not in self.ignored_errors:
                if Options.debug > 0:
                    raise Exception('Received error response from K4: ', base + response)
                else:
                    Popup.warning('Received error response from K4: ' + base + response)
            self.update_k4_parameter(base, response)

    def cat_only_recv_loop(self):
        while True:
            readable, writable, in_error = select.select([self.socket.fileno()], [], [self.socket], 1)
            if not self.connected:
                return
            if len(in_error) > 0:
                raise Exception("Socket error reading from server '{name}'".format(name=self.name))
            if len(readable) == 0:
                continue

            recv_bytes = self.socket.recv(16384)
            if len(recv_bytes) == 0:
                self.connected = False
                return

            try:
                self.recv_queue.put(recv_bytes)
            except queue.ShutDown:
                pass

    def recv_loop(self):
        packet_offset = 0

        while True:
            readable, writable, in_error = select.select([self.socket.fileno()], [], [self.socket], 1)
            if not self.connected:
                return
            if len(in_error) > 0:
                raise Exception("Socket error reading from server '{name}'".format(name=self.name))
            if len(readable) == 0:
                continue

            rb = self.socket.recv(16384)
            if len(rb) == 0:
                self.connected = False
                return

            if self.partial_packet != None:
                rb = self.partial_packet + rb
                self.partial_packet = None

            while True:
                remaining_length = len(rb)
                if remaining_length < 8:
                    self.partial_packet = rb
                    break
                if rb[0:4] != Server.begin_packet_marker:
                    raise Exception('bad received packet header', rb[0:4])
                payload_length = (rb[4]<<24) | rb[5]<<16 | rb[6]<<8 | rb[7]
                end_offset = 12 + payload_length
                if remaining_length < end_offset:
                    self.partial_packet = rb
                    break
                if rb[end_offset-4:end_offset] != Server.end_packet_marker:
                    raise Exception('bad received packet trailer', rb[end_offset-4:end_offset])
                #tprint('payload type', rb[8], 'version', rb[9], 'sequence', rb[10])

                payload_type = rb[8]
                payload = rb[11:end_offset-4]
                if payload_type != self.payload_type_audio:
                    try:
                        self.recv_queue.put((payload_type, payload))
                    except queue.ShutDown:
                        pass
                else:
                    # If we're behind in emptying the queue, don't bother adding to it.
                    if self.output_audio_queue.qsize() < 2:
                        self.output_audio_queue.put(payload)

                if remaining_length == end_offset:
                    break
                rb = rb[end_offset:]

    def subscribe_response(self, cmd, callback, send=True):
        base = cmd_base(cmd)
        if not base in self.k4_subscriptions:
            self.k4_subscriptions[base] = []
        if not callback in self.k4_subscriptions[base]:
            self.k4_subscriptions[base].append(callback)
        if send == True:
            parameter = self.k4_parameters.get(base, None)
            if parameter != None:
                callback(base + parameter + ';')

    def unsubscribe_response(self, cmd, callback):
        base = cmd_base(cmd)
        try:
            self.k4_subscriptions[base].remove(callback)
        except:
            pass

    def clear_k4_subscriptions(self):
        self.k4_subscriptions.clear()

    def add_ignored_error(self, base):
        self.ignored_errors[base] = True

    def get_address_port(self, string):
        match = re.search('^(.*):([0-9]+)', string)
        if match == None:
            return string, ''
        return match[1], match[2]

    def set_address(self, address_port):
        address, port = self.get_address_port(address_port)
        if address != '':
            self.address = address
        if port != '':
            self.port = int(port)
        previous_address_port = self.address_port
        self.__class__.address_port = address_port
        if address_port != previous_address_port and previous_address_port != None:
            restart()

    def set_proxy(self, proxy_address_port):
        address, port = self.get_address_port(proxy_address_port)
        if address != '':
            self.proxy_address = address
        if port != '':
            self.proxy_port = int(port)
        previous_proxy_address_port = self.proxy_address_port
        self.__class__.proxy_address_port = proxy_address_port
        if proxy_address_port != previous_proxy_address_port and previous_proxy_address_port != None:
            restart()

    def set_password(self, password):
        previous_password = self.password
        self.password = password
        self.__class__.password = password
        if password != previous_password and previous_password != None:
            restart()

    def set_control_k4_audio(self, val):
        self.control_k4_audio = val

    def update_local_audio_parameters(self):
        responses = Audio.local_audio_responses()
        responses = responses.split(';')[:-1]
        for response in responses:
            base = cmd_base(response)
            response=response[len(base):]
            self.update_k4_parameter(base, response)
        if self.control_k4_audio:
            self.receive_k4_responses(responses)

class Widget():
    blink_mS = 500
    default_leading = 0
    default_label_leading = 1

    def __init__(self, config_info, container):
        self.config_info = config_info
        self.container = container
        self.bg = None
        self.abg = None
        self.fg = None
        self.afg = None
        self.cached_font = None
        self.cached_button_font = None
        self.cached_label_font = None

        if 'server' in self.config_info:
            self.server = Server.server(self.config_info['server'])
        else:
            if self.container != None:
                self.server = self.container.server

        if self.container != None:
            self.frame = self.label_and_leading_frame()

    def k4param(self, base):
        if self.server.type == 'k4':
            return self.server.k4_parameter(base)
        else:
            return None

    def eval_value(self, s, value=""):
        try:
            ret = eval(str(s))
        except Exception as err:
            dprint('value: "{value}", eval("{s}")'.format(value=value, s=s))
            dprint('exception: {err}'.format(err=err))
            raise
        return ret

    def label_font(self):
        if self.cached_label_font != None:
            return self.cached_label_font
        if 'label_font' in self.config_info:
            font = self.config_info['label_font']
            font = tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])
        else:
            font = self.container.label_font()
            self.cached_label_font = font
        return font

    def button_font(self):
        if self.cached_button_font != None:
            return self.cached_button_font
        if 'button_font' in self.config_info:
            font = self.config_info['button_font']
            font = tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])
        else:
            font = self.container.button_font()
            self.cached_button_font = font
        return font

    def font(self):
        if self.cached_font != None:
            return self.cached_font
        if 'font' in self.config_info:
            font = self.config_info['font']
            font = tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])
        else:
            font = self.button_font()
            self.cached_font = font
        return font

    def label_and_leading_frame(self):
        container = self.container
        config_info = self.config_info
        if 'column' in config_info:
            column = config_info['column']
            if column < container.column:
                container.next_row()
            container.column = column

        columnspan = config_info.get('columnspan', 1)
        rowspan = config_info.get('rowspan', 1)

        self.outer_frame = tk.Frame(container.frame)

        label = config_info.get('label', None)

        if 'label' in config_info:
            default_leading = Widget.default_label_leading
        else:
            default_leading = Widget.default_leading

        leading = config_info.get('leading', default_leading)

        self.outer_frame.grid(row=container.row,
                        column=container.column,
                        rowspan=rowspan,
                        columnspan=columnspan,
                        sticky='nw')

        if label == None and leading == 0:
            return self.outer_frame

        row = 0
        if leading != 0:
            family = self.label_font().cget('family')
            weight = self.label_font().cget('weight')
            leading_font = tkFont.Font(family=family, size=leading, weight=weight)
            leading_label = tk.Label(self.outer_frame, text=' ', font=leading_font)
            leading_label.grid(row=0, column=0, sticky='nw')
            row=1

        if label == None:
            inner_frame = tk.Frame(self.outer_frame)
        else:
            inner_frame = tk.LabelFrame(self.outer_frame,
                                       text=label,
                                       font=self.label_font(),
                                       labelanchor='nw',
                                       bd=4,
                                       relief='raised')
        inner_frame.grid(row=row, column=0, sticky='nw')

        return inner_frame

class Container(Widget):
    depth = -1

    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        if isinstance(self, Page):
            self.childwidth = config_info.get('childwidth', None)
        else:
            self.childwidth = config_info.get('childwidth', container.childwidth)
        self.columns = config_info.get('columns', len(self.config_info['contains']))
        self.row = 0
        self.column = 0

        self.children = []

    def next_column(self):
        self.column += 1
        if self.column >= self.columns:
            self.column = 0
            self.next_row()

    def next_row(self):
        self.row += 1

    def show_widgets(self):
        Container.depth += 1
        if len(self.config_info['contains']) == 0:
            raise Exception('item: group requires a contains: option')
        for config_info in self.config_info['contains']:
            widget_type = config_info['item'].lower()
            if widget_type == 'group':
                if Options.debug > 0:
                    label = config_info.get('label', '')
                    indent = '    ' * Container.depth
                    dprint2('{indent}group {label}: row  {row}, column: {column}'.format(indent=indent, label=label, row=self.row, column=self.column))
                child = Group(config_info, self)
            elif widget_type == 'button':
                child = Button(config_info, self)
            elif widget_type == 'radiobutton':
                child = Radiobutton(config_info, self)
            elif widget_type == 'vfo':
                child = VFO(config_info, self)
            elif widget_type == 'slider':
                child = Slider(config_info, self)
            elif widget_type == 'togglebutton':
                child = Togglebutton(config_info, self)
            elif widget_type == 'getvalue':
                child = Getvalue(config_info, self)
            elif widget_type == 'bargraph':
                child = Bargraph(config_info, self)
            elif widget_type == 'text':
               child = Text(config_info, self)
            elif widget_type == 'notebook':
               child = Notebook(config_info, self)
            elif widget_type == 'dropdownbutton':
               child = Dropdownbutton(config_info, self)
            elif widget_type == 'equalizers':
               child = Equalizers(config_info, self)
            elif widget_type == 'menu':
               child = Menu(config_info, self)
            elif widget_type == 'appsettings':
               child = Settings_widget(config_info, self)
            elif widget_type == 'fwversions':
               child = FWversions(config_info, self)
            else:
                raise Exception('Error: config file: unknown item "{type}"'.format(type=widget_type))

            self.children.append(child)

            self.next_column()

        Container.depth -= 1

    def items_width(self):
        width = 0
        for config_info in self.config_info['contains']:
            text = str(config_info.get('text', ''))
            for line in text.split('\n'):
                if len(line) > width:
                    width = len(line)
            for config_info in config_info.get('selections', []):
                text = str(config_info.get('text', ''))
                for line in text.split('\n'):
                    if len(line) > width:
                        width = len(line)
        return width

    def has_tabnames(self):
        children = self.config_info['contains']
        tabcount = 0
        for child in children:
            if child.get('item', None) == 'group' and child.get('tabname', None) != None:
                tabcount += 1
        if tabcount > 0 and tabcount != len(children):
            raise Exception('Error: Some, but not all contained items specify a tabname')

        return tabcount > 0

class Page(Container):
    pages = {}
    name_stack = []
    top = None

    @staticmethod
    def show_page(page_name):
        if len(Page.name_stack) > 0:
            #            current_page_name = Page.name_stack[-1]
            #current_page = Page.pages[current_page_name]
            #current_page.hide()
            Page.current().hide()
        if page_name in Page.pages:
            Page.name_stack.append(page_name)
            Page.pages[page_name].show()
        else:
           raise Exception("Page:'{name}' not found.".format(name=page_name))

    @staticmethod
    def current():
        if len(Page.name_stack) == 0:
            return None
        return Page.pages[Page.name_stack[-1]]

    @staticmethod
    def show_previous():
        if len(Page.name_stack) < 2:
            return
        current_page_name = Page.name_stack.pop()
        page_name = Page.name_stack.pop()
        Page.name_stack.append(current_page_name)
        Page.show_page(page_name)

    @staticmethod
    def main():
        first_page_name = list(Page.pages.keys())[0]
        return Page.pages[first_page_name]

    def __init__(self, config_info):
        required = ['item', 'name', 'contains']
        options = ['server', 'columns', 'childwidth', 'label_font', 'button_font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, None)

        self.name = config_info['name']
        Page.pages[self.name] = self

        if self.has_tabnames():
            self.frame = ttk.Notebook(Page.top)
        else:
            self.frame = tk.Frame(Page.top)

        self.show_widgets()

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        self.server.request_initial_parameters()

    def show(self):
        self.frame.grid()

    def hide(self):
        self.frame.grid_forget()

    def label_font(self):
        font = self.config_info.get('label_font', Default.label_font)
        return tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])

    def button_font(self):
        font = self.config_info.get('button_font', Default.button_font)
        return tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])

    def server(self):
        if 'server' in self.config_info:
            server = Server.server(self.config_info['server'])
        else:
            server = None
        return server

class Group(Container):
    def __init__(self, config_info, container):
        required = ['item', 'contains']
        options = ['columns', 'column', 'columnspan', 'rowspan', 'childwidth',
                   'label_font', 'button_font', 'tabname', 'label', 'leading']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)
        self.tabname = config_info.get('tabname', '')

        self.show_widgets()

        if isinstance(container.frame, ttk.Notebook):
            container.frame.add(self.outer_frame, text=self.tabname)

class Button(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['text', 'cmd', 'bg', 'abg', 'fg', 'afg', 'justify', 'font', 'label', 'leading', 'button_font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        text = str(config_info.get('text', ''))
        cmd = config_info.get('cmd', None)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg
        justify = config_info.get('justify', 'center')

        width = container.items_width()

        if cmd != None:
            command = lambda: self.server.expand_and_send_cmds(cmd)

        button = tk.Button(self.frame,
                    bd='2',
                    text=text,
                    font=self.font(),
                    width=width,
                    justify=justify,
                    relief='raised',
                    fg=fg,
                    bg=bg,
                    activebackground=abg,
                    activeforeground=afg,
                    padx=2,
                    pady=2,
                    command=command)

        button.grid(row=0, column=0, sticky='w')

class Togglebutton(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['wraparound', 'justify', 'selections', 'label', 'leading']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        self.index = 0
        self.blink_state = False

        self.selections = []

        self.wraparound = true_values(config_info.get('wraparound', True))
        self.justify = config_info.get('justify', 'left')

        conf_selections = config_info.get('selections', None)
        for conf_sel in conf_selections:
            index = len(self.selections)
            selection = {}

            required = []
            options = ['text', 'cmd', 'evalcmd', 'response', 'evalresponse', 'bg', 'abg', 'fg', 'afg', 'blink', 'font', 'button_font', 'hidden']
            validate_config_options(conf_sel, required, options, name='togglebutton.selection')

            selection['text'] = conf_sel.get('text', '')

            cmd = conf_sel.get('cmd', None)
            orig_response = conf_sel.get('response', cmd)
            selection['response'] = orig_response

            selection['parameters'] = {}

            responses = self.server.expand_server_cmds(orig_response)
            for response in responses:
                base = cmd_base(response)
                response = response[len(base):]
                selection['parameters'][base] = response

            selection['command'] = self.do_selection

            selection['cmd'] = cmd
            selection['bg'] = conf_sel.get('bg', Default.bg)
            selection['fg'] = conf_sel.get('fg', Default.fg)
            selection['abg'] = conf_sel.get('abg', Default.abg)
            selection['afg'] = conf_sel.get('afg', Default.afg)
            if selection['afg'] == None:
                selection['afg'] = selection['fg']
            selection['blink'] = conf_sel.get('blink', False)
            selection['evalcmd'] = conf_sel.get('evalcmd', None)
            selection['evalresponse'] = conf_sel.get('evalresponse', None)
            selection['hidden'] = true_values(conf_sel.get('hidden', False))
            self.selections.append(selection)

        width = container.items_width()

        self.button = tk.Button(self.frame,
                    bd='2',
                    font=self.font(),
                    width=width,
                    relief='raised',
                    padx=2,
                    pady=2,
                    command=selection['command'])
        self.configure()

        self.button.grid(row=0, column=0, sticky='w')

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        for selection in self.selections:
            response = selection['response']
            if response != None:
                self.server.subscribe_cmds(response, self.on_response_received)

    def configure(self):
        selection = self.selections[self.index]
        self.button.configure(
                    text=selection['text'],
                    fg=selection['fg'],
                    bg=selection['bg'],
                    activebackground=selection['abg'],
                    activeforeground=selection['afg'],
                    justify=self.justify)
        if selection['blink']:
            self.blinkon(selection)
        else:
            self.blinkoff(selection)

    def next_selection(self):
        while True:
            self.index += 1
            if self.index >= len(self.selections):
                if self.wraparound:
                    self.index = 0
                else:
                    self.index = len(self.selections) - 1

            selection = self.selections[self.index]
            if not selection['hidden']:
                break

        self.configure()

    def do_selection(self):
        if self.server.warn_if_not_connected():
            return
        self.next_selection()
        selection = self.selections[self.index]

        cmd = selection['cmd']
        evalcmd = selection['evalcmd']
        if evalcmd != None:
            cmd = self.eval_value(evalcmd)
        if cmd != None:
            self.server.expand_and_send_cmds(cmd)

        self.configure()

    def compare_parameters(self, selection):
        text = selection['text']
        parameters = selection['parameters']
        for base in parameters.keys():
            k4_parameter = self.server.k4_parameters.get(base, None)
            if selection['evalresponse'] != None and k4_parameter != None:
                k4_parameter = self.eval_value(selection['evalresponse'], base + k4_parameter + ';')[len(base):].rstrip(';')
            dprint3('compare :{text} s: {s}, b: {b}'.format(text=text, s=k4_parameter, b=parameters[base]))
            if parameters[base] != k4_parameter:
                dprint3(text, 'No match')
                return False
        dprint3(text, 'Match')
        return True

    def on_response_received(self, response):
        for index, selection in enumerate(self.selections):
            if self.compare_parameters(selection):
                self.index = index
                self.configure()

    def blinkon(self, selection):
        Poll.add(Widget.blink_mS, self.blink)

    def blinkoff(self, selection):
        Poll.remove(Widget.blink_mS, self.blink)

    def blink(self):
        selection = self.selections[self.index]
        self.blink_state = not self.blink_state
        if self.blink_state:
            self.button.configure(bg=selection['fg'], fg=selection['bg'])
        else:
            self.button.configure(bg=selection['bg'], fg=selection['fg'])

class Radiobutton(Widget):
    variables = {}
    button_counter = 0

    def __init__(self, config_info, container):
        required = ['item', 'groupid']
        options = ['text', 'cmd', 'response', 'indicator', 'selectcolor', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'blink', 'font', 'button_font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        Radiobutton.button_counter += 1

        self.text = str(config_info.get('text', ''))
        self.cmd = config_info.get('cmd', None)
        self.response = config_info.get('response', self.cmd)
        indicator = config_info.get('indicator', 1)
        selectcolor = config_info.get('selectcolor', Default.selectcolor)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg
        self.blink = config_info.get('blink', False)
        self.blink_state = False
        self.group_id = config_info.get('groupid', None)

        self.parameters = {}

        if not self.group_id in Radiobutton.variables:
            Radiobutton.variables[self.group_id] = tk.StringVar
        variable = Radiobutton.variables[self.group_id]

        width = container.items_width()

        self.button = tk.Radiobutton(self.frame,
                    bd='2',
                    text=self.text,
                    font=self.font(),
                    width=width,
                    relief='raised',
                    fg=fg,
                    bg=bg,
                    activebackground=abg,
                    activeforeground=afg,
                    padx=2,
                    pady=2,
                    command=self.on_clicked,
                    indicator=indicator,
                    selectcolor=selectcolor,
                    variable=variable,
                    value=Radiobutton.button_counter)

        self.button.grid(row=0, column=0, sticky='w')

        cmds = self.server.expand_server_cmds(self.cmd)
        responses = self.server.expand_server_cmds(self.response)
        for response in responses:
            base = cmd_base(response)
            response = response[len(base):]
            self.parameters[base] = response

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        self.server.subscribe_cmds(self.response, self.on_response_received)

    def on_clicked(self):
        if self.cmd != None:
            self.server.expand_and_send_cmds(self.cmd)

    def compare_parameters(self, group, text):
        parameters = self.parameters
        for base in parameters.keys():
            dprint3('compare {group}:{text} s: {s}, b: {b}'.format(group=group, text=text, s=self.server.k4_parameters.get(base, None), b=parameters[base]))
            if parameters[base] != self.server.k4_parameters.get(base, None):
                dprint3(text, 'No match')
                return False
        dprint3(text, 'Match')
        return True

    def on_response_received(self, response):
        if self.compare_parameters(self.group_id, self.text):
            self.button.select()
            if self.blink:
                self.blinkon()
        else:
            self.button.deselect()
            if self.blink:
                self.blinkoff()

    def blinkon(self):
        Poll.add(Widget.blink_mS, self.blink)

    def blinkoff(self):
        Poll.remove(Widget.blink_mS, self.blink)

    def blink(self):
        self.blink_state = not self.blink_state
        if self.blink_state:
            self.button.select()
        else:
            self.button.deselect()

class VFO(Widget):
    steps = [.001, .01, .1, 1, 10 ]
    texts = [ '1 Hz', '10 Hz', '100 Hz', '1 kHz', '10 kHz' ]
    step_to_index = {}
    text_to_index = {}
    low_frequency_limit=100
    high_frequency_limit=54000

    def __init__(self, config_info, container):
        required = ['item', 'AorB']
        options = ['width', 'activecolor', 'transmitcolor', 'step_spinbox', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'blink', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        if len(VFO.step_to_index) == 0:
            for i, step in enumerate(VFO.steps):
                VFO.step_to_index[step] = i

        if len(VFO.text_to_index) == 0:
            for i, text in enumerate(VFO.texts):
                VFO.text_to_index[text] = i

        self.AorB = config_info.get('AorB', 'A').upper()

        self.bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        step_spinbox = true_values(config_info.get('step_spinbox', 'false'))
        width = config_info.get('width', 0)
        self.active_color = config_info.get('activecolor', self.bg)
        self.transmit_color = config_info.get('transmitcolor', self.bg)

        self.step = .1

        frame = tk.Frame(self.frame)

        self.vfo_sb = tk.Spinbox(
                frame,
                from_=VFO.low_frequency_limit,
                to=VFO.high_frequency_limit,
                wrap=False,
                command=self.on_frequency_change,
                increment=self.step,
                font=self.font(),
                width=width,
                repeatdelay=300,
                repeatinterval=50,
                format='%5.3f',
                justify='right',
                state='normal',
                cursor='hand2',
                fg=fg,
                )
        self.vfo_sb.grid(row=0, column=0, sticky='w')
        self.vfo_sb.bind('<Return>', self.set_frequency)

        self.step_sb = tk.Spinbox(
                frame,
                command=self.on_step_sb_changed,
                values=tuple(VFO.texts),
                font=self.font(),
                width=6,
                justify='right',
                state='readonly',
                fg=fg,
                bg=self.bg,
                readonlybackground=self.bg,
                activebackground=abg,
                )
        self.step_sb.delete(0, 'end')
        self.step_sb.insert(0, '100 Hz')

        self.step_cb_val = tk.StringVar()

        # Define the style for vfo widget
        stylename = str(self) + '.TCombobox'
        style = ttk.Style()
        style.configure(stylename, background=self.bg, foreground=fg)

        self.step_cb = ttk.Combobox(
                frame,
                textvar=self.step_cb_val,
                font=self.font(),
                values=VFO.texts,
                height=len(VFO.texts),
                width=6,
                justify='right',
                state='readonly',
                style=stylename,
                )
        self.step_cb_val.trace('w', self.on_step_cb_changed)

        if step_spinbox:
            self.step_sb.grid(row=0, column=1, sticky='w')
        else:
            self.step_cb.grid(row=0, column=1, sticky='w')

        frame.grid(row=0, column=0, sticky='w')

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        self.enter_frequency_wrapper = (Page.top.register(self.enter_frequency), '%P', '%V')
        self.vfo_sb.configure(validate='all', validatecommand=self.enter_frequency_wrapper)
        self.server.subscribe_cmds('F{vfo};'.format(vfo=self.AorB), self.on_frequency_received)
        step_cmd = 'VT'
        if self.AorB == 'B':
            step_cmd += '$'
        step_cmd += ';'
        self.server.subscribe_cmds(step_cmd, self.on_step_received)

        # subscribe to split and transmit on/off changes
        self.server.subscribe_cmds('FT;', self.set_vfo_bg)
        self.server.subscribe_cmds('TQ;', self.set_vfo_bg)
        self.vfo_sb.bind('<Visibility>', self.set_vfo_bg)

    def enter_frequency(self, p, v):
        try:
            float(p)
        except:
            return False

        if v == 'focusin' or v == 'key':
            return True
        elif v == 'focusout':
            return self.set_frequency()

    def set_frequency(self, event=None):
        Page.top.focus()                # Remove focus from vfo_sb
        freq = float(self.vfo_sb.get())
        if freq < VFO.low_frequency_limit:
            self.set_vfo_sb(VFO.low_frequency_limit)
            return False
        if freq > VFO.high_frequency_limit:
            self.set_vfo_sb(VFO.high_frequency_limit)
            return False

        self.send_frequency()
        self.set_vfo_bg()
        return True

    def on_frequency_change(self):
        freq = int(float(self.vfo_sb.get()) * 1000)
        mod = freq % int(self.step * 1000)
        freq -= mod
        if mod != 0:
            self.set_vfo_sb(freq/1000)
        Poll.add(50, self.send_frequency)

    def send_frequency(self):
        Poll.remove(50, self.send_frequency)
        freq = int(float(self.vfo_sb.get()) * 1000)
        freq11 = "{:011d}".format(freq)
        cmd = "F{vfo}{freq};".format(vfo=self.AorB, freq=freq11)
        self.server.send_cmds(cmd)

    def on_frequency_received(self, response):
        freq_str = response_after_base(response)[0:11]
        self.set_vfo_sb(float(freq_str)/1000)
        self.set_vfo_bg()

    def set_vfo_sb(self, freq):
        self.vfo_sb.configure(validate='none')
        self.vfo_sb.delete(0, 'end')
        self.vfo_sb.insert(0, "{:5.3f}".format(freq))
        self.vfo_sb.configure(validate='all')

    def on_step_sb_changed(self):
        text = self.step_sb.get()
        self.set_step(text)

    def on_step_cb_changed(self, var, index, mode):
        text = self.step_cb_val.get()
        if text != '':
            self.set_step(text)

    def set_step(self, text):
        self.step = VFO.steps[VFO.text_to_index[text]]
        self.vfo_sb.config(increment=self.step)
        cmd = 'VT'
        if self.AorB == 'B':
            cmd += '$'
        cmd += str(VFO.step_to_index[self.step])
        cmd += self.current_mode_index()
        self.server.send_cmds(cmd + ';')

    def on_step_received(self, response):
        step_str = response_after_base(response)
        step_index = int(step_str[0])
        if step_index == 5:                             # Work around an apparent K4 bug
            cmd = 'VT'
            if self.AorB == 'B':
                cmd += '$'
            self.server.send_cmds(cmd + '2;')
            step_index = 2
        self.step = VFO.steps[step_index]
        self.vfo_sb.config(increment=self.step)
        text = VFO.texts[VFO.step_to_index[self.step]]
        self.step_sb.configure(state='normal')
        self.step_sb.delete(0, 'end')
        self.step_sb.insert(0, text)
        self.step_sb.configure(state='readonly')
        self.step_cb_val.set(text)

    def current_mode_index(self):
        base = 'MD'
        if self.AorB == 'B':
            base += '$'
        return self.server.k4_parameter(base)

    def set_vfo_bg(self, arg=None):
        split = self.server.k4_parameters.get('FT') == '1'
        transmit = self.server.k4_parameters.get('TQ') == '1'
        if split ^ (self.AorB == 'A'):
            if transmit:
                self.vfo_sb.configure(bg=self.transmit_color)
            else:
                self.vfo_sb.configure(bg=self.active_color)
        else:
            self.vfo_sb.configure(bg=self.bg)

class Slider(Widget):
    def __init__(self, config_info, container):
        required = ['item', 'evalcmd', 'from', 'to', 'evalresponse']
        options = ['orient', 'width', 'length', 'evalincrement', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        self.from_ = config_info['from']
        self.to = config_info['to']
        self.evalcmd = config_info['evalcmd']
        self.evalresponse = config_info['evalresponse']
        orient = config_info.get('orient', 'horizontal')
        width = config_info.get('width', 15)
        length = config_info.get('length', 15)
        self.evalincrement = config_info.get('evalincrement', 1.0)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)

        self.value_var = tk.DoubleVar()
        self.value_var.set(0.0)
        self.previous_value = 0.0

        from_ = self.eval_value(self.from_, self.value_var.get())
        to = self.eval_value(self.to, self.value_var.get())
        resolution = self.eval_value(self.evalincrement, self.value_var.get())

        self.scale = tk.Scale(self.frame,
                         from_=from_,
                         to=to,
                         resolution=resolution,
                         orient=orient,
                         repeatdelay=0,
                         width=width,
                         length=length,
                         font=self.font(),
                         bg=bg,
                         fg=fg,
                         variable=self.value_var)
        self.scale.grid(row=0, column=0, sticky='nw')

        self.value_var.trace('w', self.value_changed)
        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        cmd = self.eval_value(self.evalcmd, self.value_var.get())
        if cmd != "":
            self.server.subscribe_cmds(cmd, self.on_response_received)

    def value_changed(self, var, index, mode):
        value = self.value_var.get()
        next_value = value
        if self.previous_value == value:
            return
        if self.previous_value < value:
            next_value = value + self.eval_value(self.evalincrement, value)
        self.scale.configure(resolution=self.eval_value(self.evalincrement, next_value))
        cmd = self.eval_value(self.evalcmd, value)
        self.previous_value = value
        self.server.send_cmds(cmd)

    def on_response_received(self, response):
        value = float(self.eval_value(self.evalresponse, response))
        if value < 0:
            return
        self.scale.configure(resolution=self.eval_value(self.evalincrement, value))
        self.scale.configure(from_=self.eval_value(self.from_, value), to=self.eval_value(self.to, value))
        self.value_var.set(value)
        self.previous_value = value

class Getvalue(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['cmd', 'response', 'evalresponse', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        cmd = config_info.get('cmd', None)
        response = config_info.get('response', cmd)
        self.evalresponse = config_info.get('evalresponse', cmd)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg
        justify = config_info.get('justify', 'center')

        self.server.expand_and_send_cmds(cmd)

        self.label = tk.Label(self.frame,
                    bd='2',
                    font=sef.font(),
                    justify=justify,
                    fg=fg,
                    bg=bg,
                    activebackground=abg,
                    activeforeground=afg,
                    padx=2,
                    pady=2)

        self.label.grid(row=0, column=0, sticky='w')

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        self.server.subscribe_cmds(response, self.on_response_received)

    def on_response_received(self, response):
        value = self.eval_value(self.evalresponse, response)
        self.label.configure(text=value)

class Bargraph(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['cmd', 'response', 'evalresponse', 'orient', 'maximum', 'evalmaximum',
                   'length', 'lengthpercent', 'lefttext', 'bottomtext', 'evalbottomtext',
                   'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        self.cmd = config_info.get('cmd', None)
        self.response = config_info.get('response', self.cmd)
        self.evalresponse = config_info.get('evalresponse', self.response)
        orient = config_info.get('orient', 'horizontal')
        self.maximum = config_info.get('maximum', 100)
        self.evalmaximum = config_info.get('evalmaximum', None)
        self.length = config_info.get('length', 100)
        self.length_percent = config_info.get('lengthpercent', None)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg

        self.left_text = config_info.get('lefttext', '')
        self.bottomtext = config_info.get('bottomtext', '')
        self.evalbottomtext = config_info.get('evalbottomtext', None)

        bar_frame = tk.Frame(self.frame)

        self.left_frame = tk.Frame(bar_frame)
        if self.left_text != '':
            left_label = tk.Label(self.left_frame,
                text=self.left_text,
                bd=0,
                font=self.font(),
                justify='left',
                fg=fg,
                bg=bg,
                activebackground=abg,
                activeforeground=afg,
                padx=0,
                pady=2)

            left_label.grid(row=0, column=0, sticky='w')
        self.left_frame.grid(row=0, column=0, sticky='w')

        self.progressvalue = tk.IntVar()
        self.progressbar = ttk.Progressbar(bar_frame,
                    orient=orient,
                    variable=self.progressvalue,
                    maximum=self.maximum + .001,
                    length=self.length)

        self.progressbar.grid(row=0, column=1, sticky='w')

        bar_frame.grid(row=0, column=0, sticky='w')

        self.bottom_frame = tk.Frame(self.frame)
        if self.bottomtext != None or self.evalbottomtext != None:
            self.bottom_label = tk.Label(self.bottom_frame,
                text=self.bottomtext,
                bd=0,
                font=self.font(),
                justify='left',
                fg=fg,
                bg=bg,
                activebackground=abg,
                activeforeground=afg,
                padx=0,
                pady=2)

            self.bottom_label.grid(row=0, column=0, sticky='w')
        self.bottom_frame.grid(row=1, column=0, sticky='w')

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        self.frame.bind('<Visibility>', self.configure)
        self.server.expand_and_send_cmds(self.cmd)
        self.server.subscribe_cmds(self.response, self.on_response_received)

    def on_response_received(self, response):
        value = int(self.eval_value(self.evalresponse, response))
        self.progressvalue.set(value)
        self.configure()

    def configure(self, event=None):
        bottomtext = self.bottomtext
        if self.evalbottomtext != None:
            bottomtext = self.eval_value(self.evalbottomtext, None)
        self.bottom_label.configure(text=bottomtext)
        if self.bottom_label.winfo_viewable():
            self.bottom_frame.update()
        bottom_width = self.bottom_frame.winfo_width()
        left_width = self.left_frame.winfo_width()
        length = self.length
        if self.length_percent != None:
            length = (bottom_width - left_width) * self.length_percent / 100.0
        maximum = self.maximum
        if self.evalmaximum != None:
            maximum = float(self.eval_value(self.evalmaximum, None)) + .001
        self.progressbar.configure(length=length, maximum=maximum)

class Text(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['text', 'label', 'leading', 'fg', 'bg', 'justify', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        text = config_info.get('text', '')
        fg = config_info.get('fg', Default.fg)
        bg = config_info.get('bg', Default.bg)
        justify = config_info.get('justify', 'center')

        self.label = tk.Label(self.frame,
                    text=text,
                    bd='2',
                    font=self.font(),
                    justify=justify,
                    fg=fg,
                    bg=bg,
                    padx=2,
                    pady=2)

        self.label.grid(row=0, column=0, sticky='w')

class Notebook(Container):
    def __init__(self, config_info, container):
        required = ['item', 'contains']
        options = ['server', 'childwidth', 'label_font', 'button_font']

        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        if not has_tabnames():
            raise Exception('notebook contains items without tabnames')

        self.frame = None
        self.show_widgets()

        notebook = ttk.Notebook(self.frame)
        notebook.grid()

        for child in self.children:
            if not isinstance(child, Group):
                raise Exception('Notebook contains an item that is not a group', child)
            notebook.add(child.frame, text=child.tabname)

class Dropdownbutton(Widget):
    def __init__(self, config_info, container):
        required = ['item', 'selections']
        options = ['bg', 'abg', 'fg', 'afg', 'selectbg', 'selectfg', 'width', 'height',
                   'justify', 'unexpectedresponse', 'label', 'leading']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        texts = []
        self.text_to_index = {}

        self.index = 0
        self.blink_state = False

        self.selections = []

        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg
        self.selectbg = config_info.get('selectbg', bg)
        self.selectfg = config_info.get('selectfg', fg)
        justify = config_info.get('justify', 'right')
        height = config_info.get('height', 0)

        self.unexpected_response = config_info.get('unexpectedresponse', '')

        width = 0

        conf_selections = config_info.get('selections', None)
        for index, conf_sel in enumerate(conf_selections):
            index = len(self.selections)
            selection = {}

            required = []
            options = ['text', 'cmd', 'evalcmd', 'response', 'evalresponse', 'blink']
            validate_config_options(conf_sel, required, options, name='dropdownbutton.selection')

            text = conf_sel.get('text', '')
            selection['text'] = text
            texts.append(text)
            self.text_to_index[text] = index
            if len(text) > width:
                width = len(text)

            cmd = conf_sel.get('cmd', None)
            orig_response = conf_sel.get('response', cmd)
            selection['response'] = orig_response

            selection['parameters'] = {}
            responses = self.server.expand_server_cmds(orig_response)
            for response in responses:
                base = cmd_base(response)
                response = response[len(base):]
                selection['parameters'][base] = response

            selection['cmd'] = cmd
            selection['blink'] = conf_sel.get('blink', False)
            selection['evalcmd'] = conf_sel.get('evalcmd', None)
            selection['evalresponse'] = conf_sel.get('evalresponse', None)
            self.selections.append(selection)

        if config_info.get('width', None) != None:
            width = config_info['width']
        elif self.container.childwidth != None:
            width = self.container.childwidth

        if height == 0:
            height = len(texts)

        # Define the style for this dropdown widget
        self.stylename = str(self) + '.TCombobox'
        self.style = ttk.Style()
        self.style.configure(self.stylename, background=bg, foreground=fg, selectbackground=self.selectbg, selectforeground=self.selectfg)

        self.val = tk.StringVar()

        self.combobox = ttk.Combobox(
                self.frame,
                textvar=self.val,
                font=self.font(),
                values=texts,
                height=height,
                width=width,
                state='readonly',
                justify=justify,
                style=self.stylename,
                )

        self.val.trace('w', self.on_combobox_changed)

        self.combobox.grid(row=0, column=0, sticky='e')

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        for selection in self.selections:
            self.server.subscribe_cmds(selection['response'], self.on_response_received)

    def on_combobox_changed(self, var, index, mode):
        if self.server.warn_if_not_connected():
            return
        text = self.val.get()
        if text == '':
            return

        index = self.text_to_index.get(text, None)
        if index != None:
            self.index = index
            selection = self.selections[self.index]
            cmd = selection['cmd']
            evalcmd = selection['evalcmd']
            if evalcmd != None:
                cmd = self.eval_value(evalcmd)
            if cmd != None:
                self.server.expand_and_send_cmds(cmd)

    def compare_parameters(self, selection):
        text = selection['text']
        parameters = selection['parameters']
        for base in parameters.keys():
            k4_parameter = self.server.k4_parameters.get(base, None)
            if selection['evalresponse'] != None and k4_parameter != None:
                k4_parameter = self.eval_value(selection['evalresponse'], base + k4_parameter + ';')[len(base):].rstrip(';')
            dprint3('compare :{text} s: {s}, b: {b}'.format(text=text, s=k4_parameter, b=parameters[base]))
            if parameters[base] != k4_parameter:
                dprint3(text, 'No match')
                return False
        dprint3(text, 'Match')
        return True

    def on_response_received(self, response):
        found = False
        for index, selection in enumerate(self.selections):
            if self.compare_parameters(selection):
                self.index = index
                self.combobox.state='normal'
                self.val.set(selection['text'])
                self.combobox.state='readonly'
                if selection['blink']:
                    self.blinkon()
                else:
                    self.blinkoff()
                found = True
        if not found:
            if self.unexpected_response != '':
                text = self.eval_value(self.unexpected_response, response)
            else:
                text = ''

            self.combobox.state='normal'
            self.val.set(text)
            self.combobox.state='readonly'

    def blinkon(self):
        Poll.add(Widget.blink_mS, self.blink)

    def blinkoff(self):
        Poll.remove(Widget.blink_mS, self.blink)

    def blink(self):
        self.blink_state = not self.blink_state
        if self.blink_state:
            self.style.configure(self.stylename, selectbackground=self.selectfg, selectforeground=selectbg)
        else:
            self.style.configure(self.stylename, selectbackground=self.selectbg, selectforeground=selectfg)

class Equalizers(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['length', 'label', 'leading', 'font', 'bg', 'fg', 'selectbg', 'selectfg']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        self.trmode_lower_dict = {}

        self.values = {}

        length = config_info.get('length', 150)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        selectbg=config_info.get('selectbg', bg)
        selectfg=config_info.get('selectfg', fg)

        # Define the style for equalzer comboboxex
        self.stylename = str(self) + '.TCombobox'
        self.style = ttk.Style()
        self.style.configure(self.stylename, background=bg, foreground=fg, selectbackground=selectbg, selectforeground=selectfg)

        self.trs = ('Receive', 'Transmit')
        self.modes = ('CW','SSB', 'AM', 'FM')

        self.trmodes = []
        for tr in self.trs:
            for mode in self.modes:
                trmode = self.trmode(tr, mode)
                self.trmodes.append(trmode)

        self.active_alt_vars = {}
        self.alternate_var = tk.StringVar()
        self.vfo_var = tk.StringVar()
        self.vfo_var.set('A')

        self.alternates = {}
        self.alternate = {}
        for trmode in self.trmodes:
            self.alternates[trmode] = ['Main', 'Flat']
            self.values[trmode] = {}
            for alt in self.alternates[trmode]:
                self.values[trmode][alt] = [0, 0, 0, 0, 0, 0, 0, 0]
            self.alternate[trmode] = self.alternates[trmode][0]
            self.active_alt_vars[trmode] = tk.StringVar()
            self.active_alt_vars[trmode].set(self.alternates[trmode][0])

        self.load_settings()

        actives_frame = tk.LabelFrame(self.frame,
                                   text='Active Equalizers',
                                   font=self.label_font(),
                                   labelanchor='n',
                                   bd=4,
                                   relief='raised')
        actives_frame.grid(row=0, column=0, sticky='w', pady=5)

        self.active_alt_comboboxes = {}

        row = 0
        for tr in self.trs:
            frame = tk.Frame(actives_frame)
            frame.grid(row=row, column=0, sticky='w')
            label = tk.Label(frame, text=tr+':', font=self.font(), width=8, justify='right', fg=fg, bg=bg, padx=4, pady=2)
            label.grid(row=row, column=0, sticky='w', pady=2)
            frame = tk.Frame(actives_frame)
            frame.grid(row=row, column=1, sticky='w', pady=2)

            for i, mode in enumerate(self.modes):
                mode_frame = tk.Frame(frame)
                mode_frame.grid(row=row, column=i, sticky='w', padx=2, pady=2)
                trmode = self.trmode(tr, mode)

                label = tk.Label(mode_frame, text=mode+':', bd='2', font=self.font(), width=5, justify='left', fg=fg, bg=bg, padx=2, pady=2)
                label.grid(row=0, column=0, sticky='w')

                combobox = ttk.Combobox(
                        mode_frame,
                        textvar=self.active_alt_vars[trmode],
                        font=self.font(),
                        height=2,
                        width=3,
                        state='readonly',
                        justify='left',
                        style=self.stylename,
                        )

                combobox.grid(row=0, column=1, sticky='w')

                self.active_alt_comboboxes[trmode] = combobox

            row += 1

        vfo_frame = tk.Frame(actives_frame)
        vfo_frame.grid(row=row, column=0, columnspan=2, sticky='w', pady=5)

        text = 'Equalizer follows mode on K4 VFO:'
        label = tk.Label(vfo_frame, text=text, font=self.font(), width=len(text), justify='right', fg=fg, bg=bg, pady=2)
        label.grid(row=0, column=0, sticky='w')

        combobox = ttk.Combobox(
                vfo_frame,
                textvar=self.vfo_var,
                font=self.font(),
                values=('A', 'B'),
                height=2,
                width=2,
                state='readonly',
                justify='left',
                style=self.stylename,
                )

        combobox.grid(row=0, column=1, sticky='w', padx=2, pady=5)

        self.equalizer_frame = tk.LabelFrame(self.frame,
                                   font=self.label_font(),
                                   labelanchor='n',
                                   bd=4,
                                   relief='raised')
        self.equalizer_frame.grid(row=1, column=0, sticky='w', pady=10)

        column0_frame = tk.Frame(self.equalizer_frame)
        column0_frame.grid(row=0, column=0, rowspan=6)

        width = 0
        for trmode in self.trmodes:
            if len(trmode) > width:
                width = len(trmode)

        self.alternate_combobox = ttk.Combobox(
                column0_frame,
                textvar=self.alternate_var,
                font=self.font(),
                state='readonly',
                justify='left',
                style=self.stylename,
                )

        self.alternate_combobox.grid(row=1, column=0, sticky='w', pady=2)

        self.trmode_var = tk.StringVar()

        self.trmode_combobox = ttk.Combobox(
                column0_frame,
                textvar=self.trmode_var,
                font=self.font(),
                values=self.trmodes,
                height=len(self.trmodes),
                width=width,
                state='readonly',
                justify='left',
                style=self.stylename,
                )

        self.trmode_combobox.grid(row=0, column=0, sticky='w', pady=5)
        self.trmode_var.set(self.trmodes[0])

        flat_button = tk.Button(column0_frame,
                    bd='2',
                    text='Set Flat',
                    font=self.font(),
                    width=8,
                    justify='center',
                    relief='raised',
                    fg=fg,
                    bg=bg,
                    activebackground=bg,
                    activeforeground=fg,
                    padx=2,
                    pady=2,
                    command=self.set_flat)
        flat_button.grid(row=2, column=0, sticky='w', pady=5)

        label = tk.Label(column0_frame, text='Add:', bd='2', font=self.font(), justify='center', fg=fg, bg=bg, padx=2, pady=2)
        label.grid(row=3, column=0, sticky='w')

        self.add_var = tk.StringVar()
        add_entry = tk.Entry(column0_frame, textvariable=self.add_var, width=width, justify='left', font=self.font(), fg=fg, bg=bg)
        add_entry.grid(row=4, column=0, sticky='w')
        add_entry.bind('<Return>', self.on_add_alt)

        remove_button =  tk.Button(column0_frame,
                    bd='2',
                    text='Remove',
                    font=self.font(),
                    width=7,
                    justify='center',
                    relief='raised',
                    fg=fg,
                    bg=bg,
                    activebackground=bg,
                    activeforeground=fg,
                    padx=2,
                    pady=2,
                    command=self.on_remove_alt)
        remove_button.grid(row=5, column=0, sticky='w', pady=2)

        self.scale_value_vars = []
        self.scales = []
        self.freqs = (100, 200, 400, 800, 1200, 1600, 2400, 3200)
        for i in range(len(self.freqs)):
            value = tk.IntVar()
            self.scale_value_vars.append(value)
            value.set(0)
            scale = tk.Scale(self.equalizer_frame,
                             from_=16,
                             to=-16,
                             resolution=1,
                             orient='vertical',
                             repeatdelay=0,
                             length=length,
                             font=self.font(),
                             bg=bg,
                             fg=fg,
                             variable=value)
            scale.grid(row=0, column=i+1, pady=0)
            value.trace('w', lambda var, index, mode, i=i: self.on_value_changed(var, index, mode, i))
            self.scales.append(scale)

            label = tk.Label(self.equalizer_frame,
                             text=self.freqs[i],
                             bd=0,
                             font=self.font(),
                             justify='center',
                             fg=fg,
                             bg=bg)
            label.grid(row=1, column=i+1, pady=0)

        self.vfo_var.trace('w', self.on_vfo_changed)
        self.alternate_var.trace('w', self.on_alternate_changed)
        self.trmode_var.trace('w', self.on_trmode_changed)
        for trmode in self.trmodes:
            self.active_alt_vars[trmode].trace('w', lambda var, index, mode, trmode=trmode: self.on_active_changed(var, index, mode, trmode))
        self.server.subscribe_cmds('MD;MD$;', self.on_mode_changed, send=False)

        self.set_trmode(self.trmodes[0])
        self.configure()

    def trmode(self, tr, mode):
        return '{tr} - {mode}'.format(tr=tr, mode=mode)

    def k4_mode(self):
        base = 'MD'
        if self.vfo_var.get() == 'B':
            base += '$'

        k4_modes = (None, 'SSB', 'SSB', 'CW', 'FM', 'AM', None, 'CW', None, None)
        k4_mode = self.k4param(base)
        if k4_mode ==  None or k4_mode == '':
            return None
        mode = k4_modes[int(k4_mode)]
        return mode

    def values_str(self, values):
        strs = []
        for value in values:
            strs.append('{value:+03d}'.format(value=value))
        return ''.join(strs)

    def str_values(self, s):
        values = []
        for offset in range(0, 24, 3):
            values.append(int(s[offset:offset+3]))
        return values

    def set_k4_equalizers(self):
        k4_mode = self.k4_mode()
        if k4_mode == None:
            return

        bases = ('RE', 'TE')
        for i, tr in enumerate(self.trs):
            trmode = self.trmode(tr, k4_mode)
            alt = self.active_alt_vars[trmode].get()
            values = self.values[trmode][alt]
            cmd = bases[i] + self.values_str(values) + ';'
            self.server.send_cmds(cmd)

    def on_active_changed(self, var, index, mode, trmode):
        self.set_k4_equalizers()
        self.save_settings()

    def on_value_changed(self, var, index, mode, i):
        trmode = self.trmode_var.get()
        value = self.scale_value_vars[i].get()
        self.values[trmode][self.alternate[trmode]][i] = value
        self.configure()
        self.save_settings()

    def on_trmode_changed(self, var, index, mode):
        trmode = self.trmode_var.get()
        alt = self.active_alt_vars[trmode].get()
        self.set_alternate(alt)
        self.configure()
        self.save_settings()

    def on_alternate_changed(self, var, index, mode):
        trmode = self.trmode_var.get()
        alt = self.alternate_var.get()
        self.set_alternate(alt)
        self.configure()
        self.save_settings()

    def on_mode_changed(self, response):
        self.set_k4_equalizers()

    def set_trmode(self, trmode):
        self.trmode_var.set(trmode)

    def set_alternate(self, alt):
        trmode = self.trmode_var.get()
        self.alternate[trmode] = alt
        if self.alternate_var.get() != alt:
            self.alternate_var.set(alt)

    def set_flat(self):
        for var in self.scale_value_vars:
            var.set(0)
        self.configure()
        self.save_settings()

    def on_add_alt(self, event):
        trmode = self.trmode_var.get()
        alt = self.add_var.get()
        if alt in self.alternates[trmode]:
            return
        self.alternates[trmode].append(alt)
        self.alternates[trmode].remove('Flat')
        self.alternates[trmode].append('Flat')
        self.values[trmode][alt] = [0, 0, 0, 0, 0, 0, 0, 0]
        self.set_alternate(alt)
        self.add_var.set("")
        self.configure()
        self.save_settings()

    def on_remove_alt(self):
        trmode = self.trmode_var.get()
        alt = self.alternate[trmode]
        if alt in ('Main', 'Flat'):
            return

        self.alternates[trmode].remove(alt)
        del self.values[trmode][alt]
        self.set_alternate('Main')
        self.configure()
        self.save_settings()

    def on_vfo_changed(self, var, index, mode):
        self.configure()
        self.save_settings()

    def configure(self):
        trmode = self.trmode_var.get()
        self.equalizer_frame.configure(text='{trmode} ({alt})'.format(trmode=trmode, alt=self.alternate[trmode]))

        width = 0;
        alts = self.alternates[trmode]
        for alt in alts:
            if len(alt) > width:
                width = len(alt)
        self.alternate_combobox.configure(values=alts, height=len(alts), width=width)

        state = tk.NORMAL
        if self.alternate[trmode] == 'Flat':
            state = tk.DISABLED

        for i, value in enumerate(self.values[trmode][self.alternate[trmode]]):
            if value != self.scale_value_vars[i].get():
                self.scale_value_vars[i].set(value)

        for scale in self.scales:
            scale.configure(state=state)

        for trmode in self.trmodes:
            alts = self.alternates[trmode]
            width = 0;
            for alt in alts:
                if len(alt) > width:
                    width = len(alt)

            self.active_alt_comboboxes[trmode].configure(values=alts, height=len(alts), width=width)

        self.set_k4_equalizers()

    def save_settings(self):
        category = 'Equalizers'
        previous_settings = Settings.get_category(category)
        Settings.clear_category(category)
        for trmode in self.trmodes:
            for i, alt in enumerate(self.alternates[trmode]):
                if alt == 'Flat':
                    continue
                setting = '.'.join((trmode, 'alternate', str(i)))
                Settings.put(category, setting, alt)

        for trmode in self.trmodes:
                setting = '.'.join((trmode, 'active'))
                active = self.active_alt_vars[trmode].get()
                Settings.put(category, setting, active)

        for trmode in self.trmodes:
            for alt in self.alternates[trmode]:
                if alt == 'Flat':
                    continue
                setting = '.'.join((trmode, alt))
                values = self.values[trmode][alt]
                Settings.put(category, setting, self.values_str(values))

        settings = Settings.get_category(category)
        if settings != previous_settings:
            Settings.save()

    def load_settings(self):
        category = 'Equalizers'

        for trmode in self.trmodes:
            i = 0
            while True:
                setting = '.'.join((trmode, 'alternate', str(i)))
                alt = Settings.get(category, setting)
                if alt == None:
                    break
                if alt not in self.alternates[trmode]:
                    self.alternates[trmode].append(alt)
                    self.alternates[trmode].remove('Flat')
                    self.alternates[trmode].append('Flat')
                i += 1

            setting = '.'.join((trmode, 'active'))
            active = Settings.get(category, setting)
            if active == None:
                return
            self.active_alt_vars[trmode].set(active)

            for alt in self.alternates[trmode]:
                if alt == 'Flat':
                    continue
                setting = '.'.join((trmode, alt))
                value = Settings.get(category, setting)
                self.values[trmode][alt] = self.str_values(value)

def cmd_base(cmd):
    ucmd = cmd.upper()
    base = ucmd[0:2]
    if base in Server.k4_long_cmd_bases:
        for long_base in Server.k4_long_cmd_bases[base]:
            if ucmd.startswith(long_base):
                base = long_base
                break
    if len(cmd) > len(base):
        if cmd[len(base)] == '$':
            base += '$'
        elif cmd[len(base)] == '!':
            base += '!'
    return base

def cmd_get_format(cmd):
    base = cmd_base(cmd)
    get_base = base
    if base == 'ML':
        get_base = cmd[0:3]
    elif base == 'BR':
        get_base = cmd[0:3]
    elif base == 'PK':
        get_base = cmd[0:4]
    return get_base + ';'

def response_after_base(response):
    i = len(cmd_base(response))
    return response[i:]

def true_values(v):
    if v == True or v == 1:
        return True

    if not isinstance(v, str):
        return False

    v = v.lower()
    return v == 'true' or v == 'on' or v == '1' or v == 'yes'

class Menu_definition():
    def __init__(self, menu, d):
        self.menu = menu
        self.index = int(d[0])
        self.desc = hex_decode(d[1])
        self.area = d[2]
        self.type = d[3]
        self.locked = 'Unlocked' if d[4] == '0' else 'Locked' if d[4] == '1' else 'Unmodifiable' if d[4] == '2' else ''
        self.low = self.typed_value(d[5])
        self.high = self.typed_value(d[6])
        self.default = self.typed_value(d[7])
        self.current = self.typed_value(d[8])
        self.increment = self.typed_value(d[9])
        self.values = []
        for value in d[10:]:
            self.values.append(hex_decode(value))
        self.container = menu.container
        self.server = menu.server

        self.send_command = self.widget_send_command

        self.updated_desc = self.desc

        self.widget = None
        self.changeable = ''

        self.frame = tk.LabelFrame(self.menu.frame,
                                   text=self.desc,
                                   font=self.menu.label_font(),
                                   labelanchor='nw',
                                   bd=4,
                                   relief='raised')

        if len(self.values) > 0:
            self.listbox()
        elif self.type == 'BIN':
            self.range_listbox()
        elif self.type == 'VFOCRS':
            self.vfocrs()
        elif self.type == 'AOFS':
            self.aofs()
        elif self.type == 'M50Hz':
            self.m50hz()
        elif self.type == 'ZMON':
            self.zmon()
        elif self.type == 'D10mW':
            self.d10mw()
        elif self.type in ('DEC', 'REF', 'ms', 'ZOFF', 'MHz', 'Hz'):
            self.slider()
        elif self.type in ('IP', 'SN'):
            self.fixed_text()
        elif self.type == 'STR':
            self.text()

        self.locked_frame = tk.Frame(self.frame)
        self.locked_frame.grid(row=0, column=1)

        self.locked_button = tk.Button(self.locked_frame,
                    bd='2',
                    text=self.locked,
                    font=self.menu.font(),
                    width=12,
                    justify='center',
                    relief='raised',
                    fg=self.menu.fg,
                    bg=self.menu.bg,
                    activebackground=self.menu.abg,
                    activeforeground=self.menu.afg,
                    padx=2,
                    pady=2,
                    command=self.on_locked_changed)

        self.locked_button.grid(row=0, column=0)

        self.default_button = tk.Button(self.locked_frame,
                    bd='2',
                    text="Set to\nNormal",
                    font=self.menu.font(),
                    width=12,
                    justify='center',
                    relief='raised',
                    fg=self.menu.fg,
                    bg=self.menu.bg,
                    activebackground=self.menu.abg,
                    activeforeground=self.menu.afg,
                    padx=2,
                    pady=2,
                    command=self.on_default_clicked)

        self.default_button.grid(row=1, column=0)

    def null_update(self, current=None):
        pass

    def on_locked_changed(self):
        if self.locked == 'Locked':
            if self.changeable == 'Locked':
                self.changeable = 'Unlocked'
            else:
                self.changeable = 'Locked'

        self.update()

    def update(self, locked=None, current=None):
        self.update_widget(current=current)

        if locked != None:
            self.changeable = locked

        if self.changeable == 'Unmodifiable':
            self.default_button.grid_forget()
        elif self.changeable == 'Unlocked':
            self.default_button.grid(row=1, column=0)
            self.default_button.configure(state='normal')
        else:
            self.default_button.grid(row=1, column=0)
            self.default_button.configure(state='disabled')

        self.locked_button.configure(text=self.changeable)

        self.update_desc()

    def update_desc(self):
        desc = self.updated_desc
        if self.area == 'XV':
            if self.type == 'DEC':
                self.menu.xv_band = int(self.current)
            else:
                self.updated_desc = self.desc.replace('<n>', str(self.menu.xv_band))

            if self.updated_desc != desc:
                self.menu.listbox.delete(self.position)
                self.menu.listbox.insert(self.position, self.updated_desc)

        if self.type == 'ms':
            self.updated_desc = self.desc + "\n(mS)"

        if self.type == 'ZMON':
            self.updated_desc = self.desc + "\n(-1 = OFF, 0 = MON)"

        if self.type == 'ZOFF':
            self.updated_desc = self.desc + "\n(0 = OFF)"

        if self.type == 'MHz':
            self.updated_desc = self.updated_desc + "\n(MHz)"

        if self.type == 'D10mW':
            self.updated_desc = self.updated_desc + "\n(mW)"

        if self.type == 'Hz':
            self.updated_desc = self.updated_desc + "\n(Hz)"

        if self.updated_desc != desc:
            self.frame.configure(text=self.updated_desc)
        
    def current_desc(self):
        return self.updated_desc

    def on_default_clicked(self):
        if self.changeable == 'Unlocked':
            self.update(current=self.default)
            self.send_command()

    def show(self):
        self.update(locked=self.locked)
        self.frame.grid(row=0, column=2)

    def hide(self):
        self.frame.grid_forget()

    def listbox(self):
        self.update_widget = self.listbox_update
        self.widget = tk.Listbox(
                self.frame,
                font=self.menu.font(),
                justify='left',
                bg=self.menu.bg,
                fg=self.menu.fg,
                selectbackground=self.menu.selectbg,
                selectforeground=self.menu.selectfg,
                exportselection=False,
                )

        if self.low != 0:
            raise Exception('Unexpected listbox low ', self.low)

        high = self.high + 1
        if high < len(self.values):
            self.values = self.values[:high]
        
        width = 0
        for value in self.values:
            value = str(value)
            if len(value) > width:
                width = len(value)
            self.widget.insert(tk.END, value)

        width = int(round(width*1.1)+1)
        self.widget.configure(height=len(self.values), width=width)
        self.widget.selection_clear(0, tk.END)
        self.widget.selection_set(self.current)
        selections = self.widget.curselection()
        if len(selections) > 0:
            index = selections[0]

        self.widget.grid(row=0, column=0)
        self.widget.bind('<<ListboxSelect>>', self.on_listbox_selected)

    def on_listbox_selected(self, arg):
        if self.changeable != 'Unlocked':
            self.widget.selection_clear(0, tk.END)
            self.widget.selection_set(self.current)
            return

        selections = self.widget.curselection()
        index = selections[0]
        self.current = index
        self.send_command()

    def listbox_update(self, current=None):
        if current != None:
            self.current = current
        self.widget.selection_clear(0, tk.END)
        self.widget.selection_set(self.current)

    def vfocrs(self):
        self.values = ('0.1 kHz', '0.5 kHz', '1.0 kHz', '2.5 kHz')
        self.listbox()

    def m50hz(self):
        self.values = ('150 Hz', '200 Hz', '250 Hz', '300 Hz', '350 Hz', '400 Hz', '450 Hz', '500 Hz', '550 Hz', '600 Hz', '650 Hz', '700 Hz')
        self.high -= self.low
        self.low = 0
        self.listbox()
        self.send_command = self.m50hz_send_command
        self.update_widget = self.m50hz_update

    def m50hz_send_command(self):
        value = int(self.current) + 3
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def m50hz_update(self, current=None):
        if current != None:
            self.current = current - 3
        self.listbox_update()

    def aofs(self):
        self.low -= 8
        self.high -= 8
        self.slider()
        self.send_command = self.aofs_send_command
        self.update_widget = self.aofs_update

    def aofs_send_command(self):
        value = int(self.current) + 8
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def aofs_update(self, current=None):
        if current != None:
            self.current = current - 8
        self.slider_update()

    def zmon(self):
        self.current -= 1
        self.low -= 1
        self.high -= 1
        self.slider()
        self.send_command = self.zmon_send_command
        self.update_widget = self.zmon_update

    def zmon_send_command(self):
        value = int(self.current) + 1
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def zmon_update(self, current=None):
        if current != None:
            self.current = current - 1
        self.slider_update()

    def d10mw(self):
        self.low = float(self.low) / 10
        self.high = float(self.high) / 10
        self.increment = float(self.increment) / 10
        self.slider()
        self.send_command = self.d10mw_send_command
        self.update_widget = self.d10mw_update

    def d10mw_send_command(self):
        value = int(self.current * 10)
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def d10mw_update(self, current=None):
        if current != None:
            self.current = float(current) / 10
        self.slider_update()

    def range_listbox(self):
        for i in range(self.low, self.high+1, self.increment):
            self.values.append(i)
        self.high -= self.low
        self.low = 0
        self.listbox()
        self.send_command = self.range_listbox_send_command
        self.update_widget = self.range_listbox_update

    def range_listbox_update(self, current=None):
        if current != None:
            self.current = self.values.index(current)
        self.widget.selection_clear(0, tk.END)
        self.widget.selection_set(self.current)

    def range_listbox_send_command(self):
        value = int(self.values[self.current])
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def slider(self):
        self.update_widget = self.slider_update
        self.value = tk.DoubleVar()
        self.value.set(self.current)

        self.widget = tk.Scale(self.frame,
                         from_=self.high,
                         to=self.low,
                         orient='vertical',
                         resolution=self.increment,
                         width=20,
                         length=font_height(self.menu.font())*9,
                         font=self.menu.font(),
                         bg=self.menu.bg,
                         fg=self.menu.fg,
                         variable=self.value,
                         command=self.slider_value_changed)
        self.widget.grid(row=0, column=0)

    def slider_value_changed(self, event):
        if self.changeable != 'Unlocked':
            self.value.set(self.current)
            return

        self.current = self.value.get()
        self.send_command()

    def slider_update(self, current=None):
        if current != None:
            if isinstance(current, str) and current.find('-') > 0:
                current = current.lstrip('0')
            self.current = current
        self.value.set(self.current)

    def fixed_text(self):
        self.update_widget = self.fixed_text_update
        self.widget = tk.Label(self.frame,
            text=self.current,
            bd=2,
            font=self.menu.font(),
            justify='left',
            fg=self.menu.fg,
            bg=self.menu.bg,
            activebackground=self.menu.abg,
            activeforeground=self.menu.afg,
            padx=2,
            pady=2)
        self.widget.grid(row=0, column=0)

    def fixed_text_update(self, current=None):
        if current != None:
            self.current = current
        self.locked = 'Unmodifiable'
        self.widget.configure(text=self.current)

    def text(self):
        self.update_widget = self.text_update
        self.text_var = tk.StringVar()
        self.text_var.set(self.current)
        self.widget = tk.Entry(self.frame,
            textvariable=self.text_var,
            bd=2,
            font=self.menu.font(),
            justify='left',
            fg=self.menu.fg,
            bg=self.menu.bg)
        self.widget.grid(row=0, column=0)
        self.widget.bind('<Return>', self.set_text)
        self.widget.bind('<FocusOut>', self.set_text)

    def set_text(self, event):
        self.current = self.text_var.get()
        self.send_command()

    def text_update(self, current=None):
        if current != None:
            self.current = current
        self.text_var.set(self.current)

    def widget_send_command(self):
        if isinstance(self.current, str) or self.type == 'REF':
            self.server.send_str('ME{index:04d}.{value};'.format(index=self.index, value=self.current))
        else:
            value = int(round(self.current))
            self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def typed_value(self, n):
        if self.type == 'REF':
            return n
        try:
            n = float(n)
            if int(n) == n:
                n = int(n)
        except:
            pass
        return n

    def print(self):
        dprint('index', self.index)
        dprint('desc', self.desc)
        dprint('area', self.area)
        dprint('type', self.type)
        dprint('locked', self.locked)
        dprint('low', self.low)
        dprint('high', self.high)
        dprint('default', self.default)
        dprint('current', self.current)
        dprint('increment', self.increment)
        dprint('values', self.values)

class Menu(Widget):
    entries_displayed = 15

    def __init__(self, config_info, container):
        required = ['item']
        options = ['entries_displayed', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'selectbg', 'selectfg', 'font', 'label_font' ]
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        entries_displayed = config_info.get('entries_displayed', Menu.entries_displayed)

        self.current_md = None

        self.bg = config_info.get('bg', Default.bg)
        self.fg = config_info.get('fg', Default.fg)
        self.selectbg = config_info.get('selectbg', Default.bg)
        self.selectfg = config_info.get('selectfg', Default.fg)

        self.definitions = []
        self.lookup_definitions = {}

        self.xv_band = 0

        self.frame = tk.Frame(self.frame)
        self.frame.grid(row=0, column=0)

        self.listbox = tk.Listbox(
                self.frame,
                font=self.font(),
                height=entries_displayed,
                justify='left',
                bg=self.bg,
                fg=self.fg,
                selectbackground=self.selectbg,
                selectforeground=self.selectfg,
                exportselection=False,
                )

        self.scrollbar = tk.Scrollbar(self.frame)
        self.listbox.config(yscrollcommand=self.scrollbar.set)
        self.scrollbar.config(command=self.listbox.yview)

        self.listbox.bind('<<ListboxSelect>>', self.on_listbox_selected)
        self.server.subscribe_cmds('MEDF;', self.on_received_definition, send=False)

    def update_definition_list(self):
        self.listbox.delete(0, tk.END)

        width = 0
        for i, md in enumerate(self.definitions):
            md.position = i
            desc = md.current_desc()
            if len(desc) > width:
                width = len(desc)
            self.listbox.insert(tk.END, md.desc)

        self.listbox.configure(width=width)

    def received_all_definitions(self):
        self.server.subscribe_cmds('ME;', self.on_received_current, send=False)

        self.definitions = sorted(self.definitions, key=lambda d:d.current_desc().casefold())
        self.update_definition_list()

        self.server.send_str('ME0043;')         # request updated IP address. We know this has changed.
        self.server.send_str('ME0086;ME0078;ME0076;ME0079;ME0098;ME0077;')   # request current transverter band menu settings

        self.listbox.grid(row=0, column=0, sticky='w')
        self.scrollbar.grid(row=0, column=1, sticky='ns')

    def on_received_current(self, response):
        index, current_value = response[2:].split('.', 1)
        current_value = current_value.rstrip(';')
        index = int(index)
        md = self.lookup_definitions[index]
        current_value = md.typed_value(current_value)
        md.update(current=current_value)

    def on_listbox_selected(self, arg):
        selections = self.listbox.curselection()
        if len(selections) == 0:
            return

        index = selections[0]

        if self.current_md != None and self.current_md.widget != None:
            self.current_md.hide()

        md = self.definitions[index]
        self.current_md = md

        md.show()

    def on_received_definition(self, response):
        if response[4:8] == '0000':
            self.received_all_definitions()
            return

        definition_values = response[4:].rstrip(';').split(',')
        if len(definition_values) < 3 or definition_values[3] == 'NULL':                      # md.type
            return

        md = Menu_definition(self, definition_values)
        found = self.lookup_definitions.get(md.index, None)
        if found != None:
            return

        self.lookup_definitions[md.index] = md
        self.definitions.append(md)

class Audio():
    singleton = None
    input_channels = 1
    k4_input_channels = 2               # The K4 requires stereo, even though it transmits mono
    input_frame_size = 240
    output_channels = 2
    k4_sample_rate = 12000
    k4_sample_rate_code = 0
    max_input_sample_rate = 48000
    max_output_sample_rate = 48000
    encode_mode_raw32 = 0
    encode_mode_raw16 = 1
    encode_mode_opus = 2
    encode_mode_opus_float = 3
    input_encode_mode = encode_mode_opus_float
    server = None

    @classmethod
    def get_singleton(cls):
        if cls.singleton == None:
            cls.singleton = Audio()

        return cls.singleton

    @classmethod
    def close(cls):
        if cls.singleton == None:
            return

        self = cls.singleton
        self.transmit_audio = False
        if self.input_thread != None:
            self.input_thread.join()
        if self.output_thread != None:
            self.output_thread.join()

    @classmethod
    def set_input_device_name(cls, name):
        self = cls.get_singleton()
        dev_info = self.input_device_info_by_name(name)
        if dev_info != None:
            self.input_device_index = dev_info['index']

    @classmethod
    def set_output_device_name(cls, name):
        self = cls.get_singleton()
        dev_info = self.output_device_info_by_name(name)
        if dev_info != None:
            self.output_device_index = dev_info['index']

    @classmethod
    def input_device_name(cls):
        self = cls.get_singleton()
        dev_info = self.input_device_infos[self.input_device_index]
        return dev_info['name']

    @classmethod
    def output_device_name(cls):
        self = cls.get_singleton()
        dev_info = self.output_device_infos[self.output_device_index]
        return dev_info['name']

    @classmethod
    def input_device_info(cls):
        self = cls.get_singleton()
        return self.input_device_infos[self.input_device_index]

    @classmethod
    def output_device_info(cls):
        self = cls.get_singleton()
        return self.output_device_infos[self.output_device_index]

    @classmethod
    def input_device_index(cls):
        self = cls.get_singleton()
        return self.input_device_index

    @classmethod
    def output_device_index(cls):
        self = cls.get_singleton()
        return self.output_device_index

    @classmethod
    def input_device_names(cls):
        self = cls.get_singleton()
        names = []
        for index in self.input_device_infos:
            device_info = self.input_device_infos[index]
            names.append(device_info['name'])
        return names

    @classmethod
    def output_device_names(cls):
        self = cls.get_singleton()
        names = []
        for index in self.output_device_infos:
            device_info = self.output_device_infos[index]
            names.append(device_info['name'])
        return names

    @classmethod
    def input_device_sample_rate(cls):
        self = cls.get_singleton()
        info = self.input_device_infos[self.input_device_index]
        return info['input_sample_rate']

    @classmethod
    def output_device_sample_rate(cls):
        self = cls.get_singleton()
        info = self.output_device_infos[self.output_device_index]
        return info['output_sample_rate']

    @classmethod
    def control_k4_cmd(cls, base, cmd):
        self = cls.get_singleton()
        cmd = cmd[len(base):]

        if base == 'AG':
            Settings.put_save('Audio', 'main_volume', cmd)
            self.a_volume = float(cmd) / 60.0
        elif base == 'AG$':
            Settings.put_save('Audio', 'sub_volume', cmd)
            self.b_volume = float(cmd) / 60.0
        elif base == 'SB':
            self.sub_on = cmd == '1'

    @classmethod
    def local_audio_responses(cls):
        a_volume = Settings.get('Audio', 'main_volume')
        if a_volume == None:
            a_volume = '000'
        responses = 'AG' + a_volume + ';'

        b_volume = Settings.get('Audio', 'sub_volume')
        if b_volume == None:
            b_volume = '000'
        responses += 'AG$' + b_volume + ';'

        return responses

    @classmethod
    def server_connected(cls, server):
        self = cls.get_singleton()
        cls.server = server
        server.subscribe_cmds('RX;', lambda response: self.on_transmit_changed(server, response), send=False)
        server.subscribe_cmds('TX;', lambda response: self.on_transmit_changed(server, response), send=False)
        server.subscribe_cmds('MX;', lambda response: self.on_mx_changed(server, response), send=False)
        server.subscribe_received_initial_parameters(cls.on_received_initial_parameters)

    @classmethod
    def on_received_initial_parameters(cls, server):
        self = cls.get_singleton()
        self.start_output_thread(cls.server.output_audio_queue)

    def pyaudio(self):
        fd = os.dup(2)
        os.close(2)              # Close stderr because pyaudio outputs a lot of disquieting messages
        pa = pyaudio.PyAudio()
        os.dup2(fd, 2)           # restore stderr
        os.close(fd)
        return pa

    def pa_get_host_api_info_by_index(self, pa, index):
        fd = os.dup(2)
        os.close(2)              # Close stderr because pyaudio outputs a lot of disquieting messages
        info = pa.get_host_api_info_by_index(index)
        os.dup2(fd, 2)           # restore stderr
        os.close(fd)
        return info

    def pa_is_format_supported(self, pa, sample_rate, **kwargs):
        supported = False
        fd = os.dup(2)
        os.close(2)              # Close stderr because pyaudio outputs a lot of disquieting messages
        try: 
            supported = pa.is_format_supported(sample_rate, **kwargs)
        except:
            pass
        os.dup2(fd, 2)           # restore stderr
        os.close(fd)
        return supported

    def __init__(self):
        self.input_thread = None
        self.output_thread = None
        self.input_device_index = 0
        self.output_device_index = 0
        self.input_device_infos = {}
        self.output_device_infos = {}
        self.sub_on = True
        self.transmit_audio = False

        a_volume = Settings.get('Audio', 'main_volume')
        if a_volume == None:
            a_volume = '000'
        self.a_volume = float(a_volume) / 60.0

        b_volume = Settings.get('Audio', 'sub_volume')
        if b_volume == None:
            b_volume = '000'
        self.b_volume = float(b_volume) / 60.0

        pa = self.pyaudio()
        info = self.pa_get_host_api_info_by_index(pa, 0)

        numdevices = info.get('deviceCount')

        default_input_device_index = pa.get_default_input_device_info()['index']
        default_output_device_index = pa.get_default_output_device_info()['index']

        for i in range(0, numdevices):
            info = pa.get_device_info_by_host_api_device_index(0, i)
            if info['name'] in [ 'dmix', 'lavrate', 'samplerate', 'speexrate', 'pulse', 'speex', 'upmix', 'vdownmix' ]:
                continue
            default_sample_rate = info['defaultSampleRate']

            input_device_info = { 'default_sample_rate': int(default_sample_rate), 'input_channels': 0 }

            begin_rate = Audio.k4_sample_rate
            end_rate = Audio.max_input_sample_rate + begin_rate
            step = begin_rate
            for input_sample_rate in range(begin_rate, end_rate, step):
                if self.pa_is_format_supported(pa, input_sample_rate,
                               input_device=info['index'],
                               input_channels=Audio.input_channels,
                               input_format=pyaudio.paFloat32):
                    input_device_info['index'] = info['index']
                    input_device_info['name'] = info['name']
                    input_device_info['input_channels'] = info['maxInputChannels']
                    input_device_info['input_sample_rate'] = input_sample_rate
                    if info['index'] == default_input_device_index:
                        self.input_device_index = info['index']
                    break

            if 'index' in input_device_info:
                self.input_device_infos[input_device_info['index']] = input_device_info
            elif Options.debug > 0:
                if self.pa_is_format_supported(pa, default_sample_rate,
                             input_device=info['index'],
                             input_channels=Audio.input_channels,
                             input_format=pyaudio.paFloat32):
                    dprint('Info:', info['name'], 'does not support multiple of K4 sample rate. supported rate:', default_sample_rate)

            output_device_info = { 'default_sample_rate': int(default_sample_rate), 'output_channels': 0 }

            begin_rate = Audio.k4_sample_rate
            end_rate = Audio.max_output_sample_rate + begin_rate
            step = begin_rate
            for output_sample_rate in range(begin_rate, end_rate, step):
                if self.pa_is_format_supported(pa, output_sample_rate,
                                   output_device=info['index'],
                                   output_channels=Audio.output_channels,
                                   output_format=pyaudio.paFloat32):
                    output_device_info['index'] = info['index']
                    output_device_info['name'] = info['name']
                    output_device_info['output_channels'] = info['maxOutputChannels']
                    output_device_info['output_sample_rate'] = output_sample_rate
                    if info['index'] == default_output_device_index:
                        self.output_device_index = info['index']
                    break

            if 'index' in output_device_info:
                self.output_device_infos[output_device_info['index']] = output_device_info
            elif Options.debug > 0:
                if self.pa_is_format_supported(pa, default_sample_rate,
                             output_device=info['index'],
                             output_channels=Audio.output_channels,
                             output_format=pyaudio.paFloat32):
                    dprint('Info:', info['name'], 'does not support multiple of K4 sample rate. supported rate:', default_sample_rate)

    def input_device_info_by_name(self, name):
        for index in self.input_device_infos:
            dev_info = self.input_device_infos[index]
            if dev_info['name'] == name:
                return dev_info
        return None

    def output_device_info_by_name(self, name):
        for index in self.output_device_infos:
            dev_info = self.output_device_infos[index]
            if dev_info['name'] == name:
                return dev_info
        return None

    def start_output_thread(self, queue):
        self.output_queue = queue
        self.output_thread = threading.Thread(target=self.output_loop, name='audio_output_thread')
        self.output_thread.start()

    def output_loop(self):
        output_stream = None
        current_index = None
        warned = False

        while True:
            packet = self.output_queue.get()
            if len(packet) == 0:
                return

            if current_index != self.output_device_index:
                current_index = self.output_device_index
                encode_mode = packet[0]
                if encode_mode != Audio.encode_mode_opus_float:
                    raise Exception('Unsupported audio encode mode:', encode_mode)

                frame_size = packet[2] << 8 | packet[1]

                sample_rate = packet[3]
                if sample_rate != 0:
                    raise Exception('Unsupported audio sample rate:', sample_rate)

                opus = opuslib.Decoder(Audio.k4_sample_rate, Audio.output_channels)

                pa = self.pyaudio()

                if output_stream != None:
                    output_stream.close()
                    output_stream = None

                resample_ratio = int(Audio.output_device_sample_rate() / Audio.k4_sample_rate)

                retries = 2
                for retry in range(retries+1):
                    try:
                        output_stream = pa.open(format=pyaudio.paFloat32,
                                                channels=Audio.output_channels,
                                                rate=Audio.output_device_sample_rate(),
                                                frames_per_buffer=frame_size,
                                                output=True,
                                                output_device_index=self.output_device_index,
                                                )
                        warned = False
                        break
                    except:
                        if retry >= retries:
                            if not warned:
                                Popup.warning('Failed to open: ' + self.output_device_name())
                                warned = True
                        continue

            pcm = opus.decode_float(bytes(packet[4:]), frame_size)

            stereo = numpy.frombuffer(pcm, dtype=numpy.float32)
            a = stereo[0::2]                    # even samples are from the main receiver
            b = stereo[1::2]                    # odd samples are from the sub receiver

            a = a * self.a_volume * 32          # apply some amplification
            b = b * self.b_volume * 32
                                                # Possible self.ab settings
                                                # a.b
                                                # ab.ab
                                                # a.-a
                                                # a.ab
                                                # ab.b
                                                # ab.a
                                                # b.ab
                                                # b.b
                                                # b.a
                                                # a.a

            if not self.sub_on:
                b = a                      # take all audio from main

            leftsel, rightsel = self.ab.split('.')

            if leftsel == 'a':
                left = a
            elif leftsel == 'b':
                left = b
            elif leftsel == 'ab':
                left = (a + b) / 2

            if rightsel == 'b':
                right = b
            elif rightsel == 'a':
                right = a
            elif rightsel == 'ab':
                right = (a + b) / 2
            elif rightsel == '-a':
                right = -a

            if resample_ratio > 1:
                left = left.repeat(resample_ratio)
                right = right.repeat(resample_ratio)

            stereo = numpy.empty((left.size + right.size,), dtype=numpy.float32)
            stereo[0::2] = left
            stereo[1::2] = right
            output_stream.write(stereo.tobytes())

    def on_transmit_changed(self, server, response):
        transmit = server.k4_parameters.get('TX', None) != None
        tune = server.k4_parameters.get('TU', "0") != '0'
        if transmit and not tune:
            split = server.k4_parameters.get('FT') == '1'
            if split:
                mode = server.k4_parameters.get('MD$')
            else:
                mode = server.k4_parameters.get('MD')

            if mode in ("1", "2", "4", "5"):        # LSB, USB, FM, AM
                if not self.transmit_audio:
                    self.transmit_audio = True
                    self.start_input_thread(server)
                return

        self.transmit_audio = False
        if self.input_thread != None:
            self.input_thread.join()
            self.input_thread = None

    def on_mx_changed(self, server, response):
        self.ab = response[2:].lower().rstrip(';')

    def start_input_thread(self, server):
        self.input_thread = threading.Thread(target=lambda: self.input_loop(server), name='audio_input_thread')
        self.input_thread.start()

    def input_loop(self, server):
        input_stream = None
        current_index = None
        warned = False

        while True:
            if current_index != self.input_device_index:
                current_index = self.input_device_index

                opus = opuslib.Encoder(Audio.k4_sample_rate, Audio.k4_input_channels, 'audio')

                pa = self.pyaudio()

                if input_stream != None:
                    input_stream.close()
                    input_stream = None

                retries = 2
                for retry in range(retries+1):
                    try:
                        input_stream = pa.open(format=pyaudio.paFloat32,
                                                channels=Audio.input_channels,
                                                rate=Audio.input_device_sample_rate(),
                                                frames_per_buffer=Audio.input_frame_size,
                                                input=True,
                                                input_device_index=self.input_device_index,
                                                )
                        warned = False
                        break
                    except:
                        if retry >= retries:
                            if not warned:
                                Popup.warning('Failed to open: ' + self.input_device_name())
                                warned = True
                        continue

                tries = 10
                for i in range(tries):
                    sampled = input_stream.read(Audio.input_frame_size, exception_on_overflow=False)
                    sampled = numpy.frombuffer(sampled, dtype=numpy.float32)
                    average = sum(numpy.abs(sampled)) / len(sampled)
                    if average != 0.0:
                        break
                    if i == tries-1:
                        Popup.warning("No input from audio device:\n  {name}".format(name=Audio.input_device_name()))
                        return

                resample_ratio = int(Audio.input_device_sample_rate() / Audio.k4_sample_rate)

            sampled = input_stream.read(Audio.input_frame_size * resample_ratio, exception_on_overflow=False)
            sampled = numpy.frombuffer(sampled, dtype=numpy.float32)

            if resample_ratio == 1:
                resampled = sampled
            elif resample_ratio == 2:
                s0 = sampled[0::2]
                s1 = sampled[1::2]
                resampled = (s0 + s1) / 2

            elif resample_ratio == 3:
                s0 = sampled[0::3]
                s1 = sampled[1::3]
                s2 = sampled[2::3]
                resampled = sum((s0, s1, s2)) / 3

            elif resample_ratio == 4:
                s0 = sampled[0::4]
                s1 = sampled[1::4]
                s2 = sampled[2::4]
                s3 = sampled[3::4]
                resampled = sum((s0, s1, s2, s3)) / 4

            resampled = resampled / 32                  # apply some attenuation

            resampled = resampled.repeat(2)             # double-up samples. I consider this a K4 bug
            resampled_bytes = resampled.tobytes()

            frame_size = Audio.input_frame_size
            audio_packet = opus.encode_float(resampled_bytes, frame_size)

            if not self.transmit_audio:
                if input_stream != None:
                    input_stream.close()
                    input_stream = None
                return

            server.send_audio_packet(audio_packet, self.input_encode_mode, frame_size)

class Settings():
    settings_filename = 'settings.ini'
    settings = configparser.ConfigParser()
    settings_loaded = False
    settings_changed = False

    @classmethod
    def put(cls, category, setting, value):
        if not cls.settings_loaded:
            cls.load()
        value = str(value)
        if not category in cls.settings:
            cls.settings[category] = {}
        previous_value = cls.settings[category].get(setting, None)
        if value != previous_value:
            cls.settings[category][setting] = value
            cls.settings_changed = True

    @classmethod
    def put_save(cls, category, setting, value):
        cls.put(category, setting, value)
        cls.save()

    @classmethod
    def get(cls, category, setting):
        if not cls.settings_loaded:
            cls.load()
        if category not in cls.settings:
            return None
        if setting not in cls.settings[category]:
            return None
        return cls.settings[category][setting]

    @classmethod
    def clear_category(cls, category):
        cls.settings[category] = {}

    @classmethod
    def get_category(cls, category):
        if not cls.settings_loaded:
            cls.load()
        settings = {}
        try:
            for k, v in cls.settings[category].items():
                settings[k] = v
        except:
            pass
        return settings

    @classmethod
    def platform_settings_filename(cls, filename):
        if sys.platform == 'darwin':
            from AppKit import NSSearchPathForDirectoriesInDomains
            # http://developer.apple.com/DOCUMENTATION/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSSearchPathForDirectoriesInDomains
            # NSApplicationSupportDirectory = 14
            # NSUserDomainMask = 1
            # True for expanding the tilde into a fully qualified path
            filename = os.path.join(NSSearchPathForDirectoriesInDomains(14, 1, True)[0], appname, filename)
        elif sys.platform == 'win32':
            filename = os.path.join(os.environ['APPDATA'], appname, filename)
        else:
            home_dir = os.path.expanduser('~')
            config_dir = os.path.join(home_dir, '.config')
            if os.path.isdir(config_dir):
                config_dir = os.path.join(config_dir, appname)
            else:
                config_dir = os.path.join(home_dir, '.' + appname)
            if not os.path.isdir(config_dir):
                os.mkdir(config_dir, 0o755)
            filename = os.path.join(config_dir, filename)

        return filename

    @classmethod
    def save(cls):
        if not cls.settings_changed:
            return

        filename = cls.platform_settings_filename(cls.settings_filename)
        with open(filename, 'w') as settingsfile:
            cls.settings.write(settingsfile)
        cls.settings_changed = False

    @classmethod
    def load(cls):
        filename = cls.platform_settings_filename(cls.settings_filename)
        cls.settings.read(filename)
        cls.settings_loaded = True

class Settings_widget(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = [ 'label', 'leading', 'bg', 'fg', 'abg', 'afg', 'selectbg', 'selectfg', 'font', 'label_font' ]
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        input_device_name = Settings.get('Audio', 'input_device_name')
        if input_device_name != None:
            Audio.set_input_device_name(input_device_name)

        output_device_name = Settings.get('Audio', 'output_device_name')
        if output_device_name != None:
            Audio.set_output_device_name(output_device_name)

        self.bg = config_info.get('bg', Default.bg)
        self.fg = config_info.get('fg', Default.fg)
        self.abg = config_info.get('abg', Default.abg)
        self.afg = config_info.get('afg', Default.afg)
        if self.afg == None:
            self.afg = self.fg
        self.selectbg = config_info.get('selectbg', Default.bg)
        self.selectfg = config_info.get('selectfg', Default.fg)

        self.frame = tk.LabelFrame(self.frame,
                              text='Settings',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')
        self.frame.grid(row=0, column=0)

        remote_frame = self.remote_settings()
        remote_frame.grid(row=0, column=0, sticky='w')
        audio_frame = self.audio_settings()
        audio_frame.grid(row=1, column=0, sticky='w', pady=8)

    def remote_settings(self):
        frame = tk.LabelFrame(self.frame,
                              text='K4 Remote',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')

        address_frame = self.k4_address_settings(frame)
        address_frame.grid(row=0, column=0, sticky='w', pady=2)

        password_frame = self.k4_password_settings(frame)
        password_frame.grid(row=1, column=0, sticky='w', pady=2)

        proxy_frame = self.k4_proxy_settings(frame)
        proxy_frame.grid(row=2, column=0, sticky='w', pady=2)

        return frame

    def k4_address_settings(self, remote_frame):
        frame = tk.LabelFrame(remote_frame,
                              text='Address',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')

        self.k4_address_var = tk.StringVar()
        k4_address = Settings.get('Elecraft K4', 'address')
        if k4_address == None:
            k4_address = ''

        self.k4_address_var.set(k4_address)
        self.set_k4_server_address()

        entry = tk.Entry(frame,
            textvariable=self.k4_address_var,
            bd=2,
            font=self.font(),
            justify='left',
            fg=self.fg,
            bg=self.bg)
        entry.grid(row=0, column=0)
        entry.bind('<Return>', self.set_k4_server_address)
        entry.bind('<FocusOut>', self.set_k4_server_address)

        return frame

    def set_k4_server_address(self, event=None):
        address = self.k4_address_var.get()
        Settings.put_save('Elecraft K4', 'address', address)
        self.server.set_address(address)

    def k4_password_settings(self, remote_frame):
        frame = tk.LabelFrame(remote_frame,
                              text='Password',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')

        self.password_var = tk.StringVar()
        h = Settings.get('Elecraft K4', 'insecure_password_hash')
        if h == None:
            pw = ''
        else:
            pw = Reversable_hash.unhash(h)
        if pw != '':
            self.server.set_password(pw)

        self.password_var.set(pw)
        entry = tk.Entry(frame,
            textvariable=self.password_var,
            bd=2,
            font=self.font(),
            show='*',
            justify='left',
            fg=self.fg,
            bg=self.bg)
        entry.grid(row=0, column=0)
        entry.bind('<Return>', self.set_k4_password)
        entry.bind('<FocusOut>', self.set_k4_password)

        return frame

    def set_k4_password(self, event=None):
        pw = self.password_var.get()
        h = Reversable_hash.hash(pw)
        Settings.put_save('Elecraft K4', 'insecure_password_hash', h)
        self.server.set_password(pw)

    def k4_proxy_settings(self, remote_frame):
        frame = tk.LabelFrame(remote_frame,
                              text='SOCKS5 Address:Port',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')

        self.k4_proxy_var = tk.StringVar()
        k4_proxy = Settings.get('Elecraft K4', 'proxy_address')
        if k4_proxy == None:
            k4_proxy = ''

        self.k4_proxy_var.set(k4_proxy)
        self.set_k4_server_proxy()

        entry = tk.Entry(frame,
            textvariable=self.k4_proxy_var,
            bd=2,
            font=self.font(),
            justify='left',
            fg=self.fg,
            bg=self.bg)
        entry.grid(row=0, column=0)
        entry.bind('<Return>', self.set_k4_server_proxy)
        entry.bind('<FocusOut>', self.set_k4_server_proxy)

        return frame

    def set_k4_server_proxy(self, event=None):
        proxy = self.k4_proxy_var.get()
        Settings.put_save('Elecraft K4', 'proxy_address', proxy)
        self.server.set_proxy(proxy)

    def audio_settings(self):
        frame = tk.LabelFrame(self.frame,
                              text='Audio Settings',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')

        audio_input_frame = self.audio_input_settings(frame)
        audio_input_frame.grid(row=0, column=0, sticky='w')
        audio_output_frame = self.audio_output_settings(frame)
        audio_output_frame.grid(row=1, column=0, sticky='w', pady=4)
        audio_k4_control_frame = self.audio_k4_control_setting(frame)
        audio_k4_control_frame.grid(row=2, column=0, sticky='w')

        return frame

    def audio_input_settings(self, frame):
        input_device_name = Settings.get('Audio', 'input_device_name')
        if input_device_name == None:
            input_device_name = Audio.input_device_name()

        input_frame = tk.LabelFrame(frame,
                                    text='Current Input Device',
                                    font=self.label_font(),
                                    labelanchor='nw',
                                    bd=4,
                                    padx=4,
                                    pady=4,
                                    relief='raised')

        # Define the style for this combobox widget
        stylename = str(self) + 'input.TCombobox'
        style = ttk.Style()
        style.configure(stylename, background=self.bg, foreground=self.fg, selectbackground=self.selectbg, selectforeground=self.selectfg)

        input_names = Audio.input_device_names()
        width = 0
        for name in input_names:
            if len(name) > width:
                width = len(name)

        self.input_val = tk.StringVar()
        self.input_val.set(input_device_name)

        input_combobox = ttk.Combobox(
                input_frame,
                textvar=self.input_val,
                font=self.font(),
                values=input_names,
                height=len(input_names),
                width=width,
                state='readonly',
                justify='left',
                style=stylename,
                )
        input_combobox.grid(row=1, column=0, sticky='w')

        self.input_val.trace('w', self.on_input_combobox_changed)

        return input_frame

    def on_input_combobox_changed(self, var, index, mode):
        input_name = self.input_val.get()
        if input_name == '':
            return

        Settings.put_save('Audio', 'input_device_name', input_name)
        Audio.set_input_device_name(input_name)

    def audio_output_settings(self, frame):
        output_device_name = Settings.get('Audio', 'output_device_name')
        if output_device_name == None:
            output_device_name = Audio.output_device_name()

        output_frame = tk.LabelFrame(frame,
                                     text='Current Output Device',
                                     font=self.label_font(),
                                     labelanchor='nw',
                                     bd=4,
                                     padx=4,
                                     pady=4,
                                     relief='raised')

        # Define the style for this combobox widget
        stylename = str(self) + 'output.TCombobox'
        style = ttk.Style()
        style.configure(stylename, background=self.bg, foreground=self.fg, selectbackground=self.selectbg, selectforeground=self.selectfg)

        output_names = Audio.output_device_names()
        width = 0
        for name in output_names:
            if len(name) > width:
                width = len(name)

        self.output_val = tk.StringVar()
        self.output_val.set(output_device_name)

        output_combobox = ttk.Combobox(
                output_frame,
                textvar=self.output_val,
                font=self.font(),
                values=output_names,
                height=len(output_names),
                width=width,
                state='readonly',
                justify='left',
                style=stylename,
                )
        output_combobox.grid(row=0, column=0, sticky='w')

        self.output_val.trace('w', self.on_output_combobox_changed)

        return output_frame

    def on_output_combobox_changed(self, var, index, mode):
        output_name = self.output_val.get()
        if output_name == '':
            return

        Settings.put_save('Audio', 'output_device_name', output_name)
        Audio.set_output_device_name(output_name)

    def audio_k4_control_setting(self, frame):
        setting = true_values(Settings.get('Audio', 'control_k4_audio_settings'))
        if setting == None:
            setting = self.cat_only
        self.server.set_control_k4_audio(setting)

        control_frame = tk.LabelFrame(frame,
                                     text='Control K4 Audio Settings?',
                                     font=self.label_font(),
                                     labelanchor='nw',
                                     bd=4,
                                     padx=4,
                                     pady=4,
                                     relief='raised')

        # Define the style for this combobox widget
        stylename = str(self) + 'output.TCombobox'
        style = ttk.Style()
        style.configure(stylename, background=self.bg, foreground=self.fg, selectbackground=self.selectbg, selectforeground=self.selectfg)

        values = ('Yes', 'No')
        width = 3
        current_value = 'Yes' if setting else 'No'

        self.k4_control_audio_val = tk.StringVar()
        self.k4_control_audio_val.set(current_value)

        control_combobox = ttk.Combobox(
                control_frame,
                textvar=self.k4_control_audio_val,
                font=self.font(),
                values=values,
                height=len(values),
                width=width,
                state='readonly',
                justify='left',
                style=stylename,
                )
        control_combobox.grid(row=0, column=0, sticky='w')

        self.k4_control_audio_val.trace('w', self.on_k4_control_audio_combobox_changed)

        return control_frame

    def on_k4_control_audio_combobox_changed(self, var, index, mode):
        current_value = self.k4_control_audio_val.get()
        if current_value == '':
            return

        setting = current_value == 'Yes'

        Settings.put_save('Audio', 'control_k4_audio_settings', setting)
        self.server.set_control_k4_audio(setting)

class FWversions(Text):
    def __init__(self, config_info, container):

        config_info['justify'] = 'left'
        super().__init__(config_info, container)

        self.width = 0
        self.height = 1
        self.text = ''

        self.server.subscribe_cmds('RV;', self.on_received_versions)

    def on_received_versions(self, response):
        version = response.rstrip(';').lstrip('RV.')
        if len(version) > self.width:
            self.width = len(version)
        self.height += 1
        self.text += version + "\n"
        self.label.configure(text=self.text, height=self.height, width=self.width)

# A simple reversable string hash function
# Not in any way cryptographically secure
class Reversable_hash():
    @classmethod
    def rhash(cls, n):
        return "%08x" % (n * 387420489 % 4000000000)

    @classmethod
    def un_rhash(cls, h):
        return int(h, 16) * 3513180409 % 4000000000

    @classmethod
    def hash(cls, s):
        hashes = []
        for c in s:
            hashes.append(cls.rhash(ord(c)))
        return ''.join(hashes)

    @classmethod
    def unhash(cls, s):
        i = 0
        chars = []
        for i in range(0, len(s), 8):
            h = s[i:i+8]
            chars.append(chr(cls.un_rhash(h)))
        return ''.join(chars)

class Config():
    main_block_name = ' main'

    @staticmethod
    def preprocess(filename):
        self = Config()
        return self.process(filename)

    def process(self, filename):
        self.filename = filename
        self.blocks = {}
        self.errors = 0

        block_stack = []
        current_block = { 'name':Config.main_block_name, 'lines':[] }
        self.blocks[Config.main_block_name] = current_block
        in_block = False
        line_count = 0
        with open(filename) as stream:
            while True:
                line = stream.readline()
                if line == '':
                    break
                line_count += 1
                match = re.search("^([ \t]*)#(define|end|include)([ \t]+([_A-Za-z][-_A-Za-z0-9]*)([ \t]*)(.*)$)?", line)
                if not match:
                    current_block['lines'].append(line)
                else:
                    indent = match.group(1)
                    directive = match.group(2)
                    after_directive = match.group(3)
                    block_name = match.group(4)
                    trailing = match.group(6)
                    if directive == 'define':
                        if indent != '':
                            dprint('Error ({filename}:{line_count}): #define must be in column 1'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif block_name == None:
                            dprint('Error ({filename}:{line_count}): Invalid block name after #define'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif trailing != '':
                            dprint('Error ({filename}:{line_count}): unexpected characters after #define {name}'.format(filename=filename, line_count=line_count, name=block_name))
                            self.errors += 1
                            continue
                        elif in_block:
                            pname = current_block['name']
                            dprint('Error ({filename}:{line_count}): #define {name}, encountered while defining {pname}'.format(filename=filename, line_count=line_count, name=block_name, pname=pname))
                            self.errors += 1
                            continue
                        elif block_name in self.blocks:
                            dprint('Error ({filename}:{line_count}): #define {name}, redefined. Previously defined at line {pline_count}'.format(filename=filename, line_count=line_count, name=block_name, pline_count=self.blocks[block_name]['line_count']))
                            self.errors += 1
                            continue

                        block_stack.append(current_block)
                        current_block = { 'name':block_name, 'lines':[], 'line_count':line_count }
                        self.blocks[block_name] = current_block
                        in_block = True
                    elif directive == 'end':
                        if not in_block:
                            dprint('Error ({filename}:{line_count}): #end encountered while not defining a block'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif after_directive != None:
                            dprint('Error ({filename}:{line_count}): extra characters found after #end'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        current_block = block_stack.pop()
                        if current_block['name']:
                            in_block = False
                    elif directive == 'include':
                        if block_name == None:
                            dprint('Error ({filename}:{line_count}): Invalid block name after #include'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif trailing != '':
                            dprint('Error ({filename}:{line_count}): unexpected characters after #include {name}'.format(filename=filename, line_count=line_count, name=block_name))
                            self.errors += 1
                            continue
                        line = { 'indent':indent, 'block_name':block_name, 'line_count':line_count }
                        current_block['lines'].append(line)

        if in_block:
            block_name = current_block['name']
            dprint('Error ({filename}:{line_count}): End of file while defining block {block_name}'.format(filename=filename, line_count=line_count, block_name=block_name))
            self.errors += 1

        self.writing_blocks = {}
        indents = []

        if Options.yaml_file != None:
            with open(Options.yaml_file, 'w') as stream:
                self.write_block(stream, Config.main_block_name, '', 1)
        else:
            tmpfile = tempfile.TemporaryFile(mode='w+')
            self.write_block(tmpfile, Config.main_block_name, '', 1)

        if self.errors > 0:
            quit()

        if Options.yaml_file != None:
            quit()

        tmpfile.seek(0)
        return tmpfile

    def write_block(self, file, block_name, indent, line_count):
        if block_name in self.writing_blocks:
            previous_line_count = self.writing_blocks[block_name]
            dprint('Error ({filename}:{line_count}): #include {block_name}, recursively included, previously at {previous_line_count}'.format(filename=self.filename, line_count=line_count, block_name=block_name, previous_line_count=previous_line_count))
            self.errors += 1
            quit()

        self.writing_blocks[block_name] = line_count

        block = self.blocks[block_name]
        for line in block['lines']:
            if isinstance(line, str):
                if line != "\n":
                    line = indent + line
                file.write(line)
            else:
                block_name = line['block_name']
                if block_name not in self.blocks:
                    line_count = line['line_count']
                    dprint('Error ({filename}:{line_count}): #include of undefined block {block_name}.'.format(filename=self.filename, line_count=line_count, block_name=block_name))
                    self.errors += 1
                    continue

                self.write_block(file, block_name, indent + line['indent'], line_count)

        del self.writing_blocks[block['name']]

def read_config(config_file_name):
    with Config.preprocess(config_file_name) as stream:
        try:
            config = yaml.safe_load(stream)
        except yaml.YAMLError as exc:
            dprint(exc)

        for config_info in config:
            item = config_info['item']
            if item == 'page':
                Page(config_info)
            elif item == 'server':
                Server(config_info)
            elif item == 'defaults':
                Default(config_info)
            else:
                raise Exception("Unexpected top level item '{item}' in '{filename}'.".format(item=item, filename=config_file_name))

def font_height(font):
    return font.metrics("linespace")

class Poll:
    entries = {}
    polls = {}
    id = {}
    top = None

    def __init__(self, top):
        Poll.top = top

    def poll(interval):
        for entry in tuple(Poll.entries[interval]):
            callback, repeat = entry
            if not repeat:
                Poll.remove_entry(interval, entry)
            callback()

        if len(Poll.entries[interval]) == 0:
            del Poll.entries[interval]
            del Poll.polls[interval]
            del Poll.id[interval]
        else:
            Poll.id[interval] = Poll.top.after(interval, Poll.polls[interval])

    def add(interval, callback, repeat=True):
        if interval not in Poll.entries:
            Poll.entries[interval] = []
            Poll.polls[interval] = lambda: Poll.poll(interval)
            Poll.id[interval] = Poll.top.after(interval, Poll.polls[interval])
        entry = (callback, repeat)
        if not entry in Poll.entries[interval]:
            Poll.entries[interval].append(entry)

    def callback_repeats(interval, acallback):
        for entry in Poll.entries[interval]:
            callback, repeat = entry
            if acallback == callback:
                return repeat
        return None

    def remove_entry(interval, entry):
        if entry in Poll.entries[interval]:
            Poll.entries[interval].remove(entry)

    def remove(interval, callback):
        if interval not in Poll.entries:
            return
        repeat = Poll.callback_repeats(interval, callback)
        entry = (callback, repeat)
        Poll.remove_entry(interval, entry)

    def delayed_callback(delay, callback):
        Poll.add(delay, callback, repeat=False)

    def remove_all():
        for interval in list(Poll.id):
            id = Poll.id[interval]
            Poll.top.after_cancel(id)

            for entry in Poll.entries[interval]:
                Poll.remove_entry(interval, entry)
            Poll.poll(interval)

class Options():
    config_file = None
    verbose = 0
    debug = 0
    yaml_file = None

    @staticmethod
    def Parse():
        parser = OptionParser(version=version)
        parser.add_option('-c', '--config', dest='config_file', default='k4companion.yaml',
                          help="use config file FILE", metavar="FILE")
        parser.add_option('-v', '--verbose', action='count', dest='verbose', default = 0,
                          help="output additional status messages")
        parser.add_option('-d', '--debug', action='count', dest='debug', default=0,
                          help="output debugging messages")
        parser.add_option('--yaml', dest='yaml_file', default=None,
                          help="output preprocessed YAML to FILE", metavar="FILE")
        (options, args) = parser.parse_args()

        Options.config_file = options.config_file
        Options.verbose = options.verbose
        Options.debug = options.debug
        Options.yaml_file = options.yaml_file

        if Options.debug > 0 and Options.verbose == 0:
            Options.verbose = Options.debug

        if len(args) != 0:
            parser.error("Unexpected argument '{arg}'".format(arg=args[0]))

def clean_up():
    for server in Server.servers():
        server.close()

    Audio.close()
    Poll.remove_all()

def clean_up_and_exit():
    clean_up()
    quit()

class Popup():
    queue = queue.Queue()
    poll_interval = 200          # 200 mS
    previous_popup = None

    @classmethod
    def show_popup(cls, msg, title, timeout, font, color):
        if isinstance(msg, str):
            msg = [ msg ]
        msg = "\n\n".join(msg)
        popup = cls(title=title, timeout=timeout, font=font, color=color)
        label = tk.Label(popup.frame, text=msg, anchor='center', justify='left', font=font, bg=color)
        label.grid(row=0, column=0)
        popup.show()

    @classmethod
    def show_popups(cls):
        cls.remove_previous()
        cls.dequeue_popups()

    @classmethod
    def dequeue_popups(cls):
        while True:
            try:
                msg, title, timeout, font, color = cls.queue.get_nowait()
                cls.show_popup(msg, title, timeout, font, color)
            except queue.Empty:
                break

        Poll.delayed_callback(cls.poll_interval, cls.dequeue_popups)

    @classmethod
    def popup(cls, msg='', title='', timeout=None, font=None, color='yellow'):
        if threading.current_thread() == threading.main_thread():
            cls.show_popup(msg, title, timeout, font, color)
        else:
            cls.queue.put((msg, title, timeout, font, color))

    @classmethod
    def warning(cls, msg, timeout=2000):
        if isinstance(msg, str):
            msg = 'Warning: ' +  msg
        else:
            msg[0] = 'Warning: ' + msg[0]
        cls.popup(msg=msg, title='Warning', timeout=timeout, font=None, color='yellow')

    @classmethod
    def error(cls, msg, timeout=5000):
        if isinstance(msg, str):
            msg = 'Error: ' +  msg
        else:
            msg[0] = 'Error: ' + msg[0]
        cls.popup(msg=msg, title='Error', timeout=timeout, font=None, color='yellow')

    @classmethod
    def remove_previous(cls):
        if cls.previous_popup != None:
            try:
                cls.previous_popup.destroy()
            except:
                pass
            cls.previous_popup = None

    def __init__(self, title='', timeout=None, font=None, color='yellow', modal=False):
        self.__class__.remove_previous()
        if timeout == 0:
            timeout = None
        self.timeout = timeout
        self.popup = tk.Toplevel(Page.top)
        self.popup.title(title)
        if font == None:
            font = Page.main().font()
        size = font.cget('size')
        self.frame = tk.Frame(self.popup, padx=size*2, pady=size*2, bg=color)
        self.popup.attributes('-topmost', True)
        self.__class__.previous_popup = self.popup

    def show(self):
        self.frame.grid()
        if self.timeout != None:
            Poll.delayed_callback(self.timeout, self.popup.destroy)

    def wait(self):
        self.frame.grid()
        self.frame.wait_window()

    def close(self, event=None):
        self.popup.destroy()

    def password_button_clicked(self):
       if self.password_show_button.cget('text') == 'Show':
           self.password_show_button.configure(text='Hide')
           self.password_entry.configure(show='')
       else:
           self.password_show_button.configure(text='Show')
           self.password_entry.configure(show='*')

    def password_entered(self, event=None):
        if self.password_var.get() != '':
            self.close()

    def password(msg='', title='', font=None, color='yellow'):
        if isinstance(msg, str):
            msg = [ msg ]
        msg = "\n\n".join(msg)
        popup = Popup(title=title, font=font, color=color, modal=True)
        label = tk.Label(popup.frame, text=msg, anchor='w', justify='left', font=font, bg=color)
        label.grid(row=0, column=0, sticky='w')
        var = tk.StringVar()
        frame = tk.Frame(popup.frame, bg=color)
        frame.grid(row=1, column=0, sticky='w')
        entry = tk.Entry(frame, textvariable=var, show='*', justify='left', font=font, bg=color)
        entry.grid(row=0, column=0)
        entry.focus()
        entry.bind('<Return>', popup.password_entered)
        show_button = tk.Button(frame, text='Show', font=font, bg=color,
                                command=popup.password_button_clicked)
        show_button.grid(row=0, column=1)
        submit_button = tk.Button(popup.frame, text='Submit', font=font, bg=color,
                                command=popup.close)
        submit_button.grid(row=2, column=0, sticky='w')
        popup.password_var = var
        popup.password_entry = entry
        popup.password_show_button = show_button
        popup.frame.grid()
        popup.popup.transient(Page.top)
        popup.popup.grab_set()
        popup.popup.protocol('WM_DELETE_WINDOW', popup.close)
        Page.top.wait_window(popup.popup)
        return var.get()

class Timer():
    timers = {}

    @classmethod
    def timer(cls, name):
        return cls.timers.get(name, None)

    def __init__(self, name, entries):
        self.entries = entries
        self.times = []
        self.index = 0
        for i in range(0, entries):
            self.times.append(0)
        self.timers[name] = self

    def add(self):
        self.times[self.index] = time.time_ns()

        self.index += 1
        if self.index >= self.entries:
            self.index = 0

    def values(self):
        return self.times

    def deltas(self):
        deltas = []
        for i in range(self.entries):
            if i == 0:
                previous = self.entries - 1
            else:
                previous = i - 1
            deltas.append(self.times[i] - self.times[previous])

        return deltas

def validate_config_options(dictionary, requireds, options, name=None):
    if name == None:
        name = dictionary['item']

    id = ''
    for key in ['label', 'text', 'tabname']:
        if key in dictionary:
            id = dictionary[key]
            break

    options.extend(requireds)
    for option in dictionary.keys():
        if option not in options:
            raise Exception("Unrecognized option '{option}' in item '{name}'{id}.".format(option=option, name=name, id=id))

    for option in requireds:
        if option not in dictionary or dictionary[option] == None:
            if id != '':
                id = ' ({id})'.format(id=id)
            raise Exception("Required option '{option}' missing in item '{name}'{id}.".format(option=option, name=name, id=id))

def hex_decode(string):
    return re.sub('%(..)', lambda m: chr(int(m[1], 16)), string)

def dprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def dprint1(*args, **kwargs):
    if Options.debug >= 1:
        print(*args, file=sys.stderr, **kwargs)

def dprint2(*args, **kwargs):
    if Options.debug >= 2:
        print(*args, file=sys.stderr, **kwargs)

def dprint3(*args, **kwargs):
    if Options.debug >= 3:
        print(*args, file=sys.stderr, **kwargs)

def dprint4(*args, **kwargs):
    if Options.debug >= 4:
        print(*args, file=sys.stderr, **kwargs)

def vprint1(*args, **kwargs):
    if Options.verbose >= 1:
        print(*args, **kwargs)

def vprint2(*args, **kwargs):
    if Options.verbose >= 2:
        print(*args, **kwargs)

def tprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def backtrace():
    traceback.print_stack()

def main_page_visible(self):
    page = Page.main()
    server = page.server
    if server.connect_on_start:
        server.connect()

def start():
    Poll(Page.top)
    Popup.show_popups()

    read_config(Options.config_file)

    page = Page.main()
    page.frame.bind('<Visibility>', main_page_visible)
    Page.show_page(page.name)

def restart():
    clean_up()
    Page.main().frame.destroy()
    start()

def main():
    Options.Parse()

    top = tk.Tk()
    top.title('K4-Companion')
    top.protocol("WM_DELETE_WINDOW", clean_up_and_exit)
    Page.top = top

    start()

    top.mainloop()

if __name__ == '__main__':
    main()

# vim: set expandtab ts=4 sw=4:
