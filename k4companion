#!/usr/bin/env python3

# K4-Companion is an application written in python3 that can remotely
# control and Elecraft K4 tranceiver via TCP/IP.  It currently controls
# the main K4 features and is very useable as is, but new features are
# being added all the time.  K4-Companion is very configurable.
# 
# K4-Companion began life as a simple macro-sending program called
# K4Macro-Python, created by Charles Powell, NK8O. It has now grown far
# beyond a simple macro-sending program into a full-fledged remote control
# program for the K4.
# 
# Please send problem reports either: by sending an email, by entering
# an issue on github, or by making a pull request. Problem reports and
# suggesions are greatly appreciated.
#
# Configuration information is maintained in a separate YAML file named,
# by default, k4companion.yaml.
# 
# Dale Farnsworth, W7DA
# dale@farnsworth.org
#
# Copyright (C) 2025  Dale Farnsworth
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

import configparser
import ctypes
import hashlib
import math
import numpy
import opuslib
import os
import platform
import pyaudio
import queue
import re
import select
import socket
import socks
import ssl
import sys
import tempfile
import textwrap
import threading
import time
import tkinter as tk
import tkinter.ttk as ttk
import tkinter.font as tkFont
import traceback
import yaml

from optparse import OptionParser
from tkinter import simpledialog

appname = 'k4companion'
version = "1.2.8"

v = platform.python_version_tuple()
python_major = int(v[0])
python_minor = int(v[1])
python_patchlevel = int(v[2])

class Default():
# may be overriden by values in the config file
    bg = 'maroon1'
    abg = 'red'
    fg = 'black'
    afg = None        # None means same as fg
    selectcolor = 'red'
    label_font =  { 'family': 'Helvetica', 'size': 10, 'weight': 'normal' }
    button_font = { 'family': 'Helvetica', 'size': 10, 'weight': 'normal' }

    def __init__(self, config_info):
        required = ['item']
        options = ['bg', 'abg', 'fg', 'afg', 'selectcolor', 'label_font', 'button_font']
        validate_config_options(config_info, required, options)

        Default.bg = config_info.get('bg', Default.bg)
        Default.abg = config_info.get('abg', Default.abg)
        Default.fg = config_info.get('fg', Default.fg)
        Default.afg = config_info.get('afg', Default.afg)
        Default.selectcolor = config_info.get('selectcolor', Default.selectcolor)
        Default.label_font = config_info.get('label_font', Default.label_font)
        Default.button_font = config_info.get('button_font', Default.button_font)

class Server():
    server_dict = {}
    default_server_name = None
    address_port = None
    proxy_address_port = None
    password = None

    receive_poll_interval = 1           # poll every 1 mS
    ping_poll_interval = 2000           # poll every 2 seconds
    packet_header_len = 8
    packet_trailer_len = 4
    begin_packet_marker = bytes((0xFE, 0xFD, 0xFC,  0xFB))
    end_packet_marker = bytes((0xFB, 0xFC, 0xFD, 0xFE))
    payload_type_cat = 0
    payload_type_audio = 1
    payload_type_pan = 2
    payload_type_minipan = 3
    cat_version_number = 0
    cat_sequence_number = 0
    control_k4_audio_cmd_bases = ( 'AG', 'AG$', 'MG' )
    audio_version_number = 1

    k4_get_cmd_bases = [         # For future use
        '#A',
        'AC',
        'ACM',
        'ACN1',
        'ACN2',
        'ACN3',
        'ACN4',
        'ACN5',
        'ACs',
        'ACT',
        'AF',
        'AG$',
        'AI',
        'AL',
        'AN',
        'AP$',
        '#AR',
        'AR$',
        'AT',
        '#AVG',
        'BG',
        'BI',
        'BL',
        'BN$',
        'BR',
        'BS',
        'BW$',
        '#C',
        'CC',
        '#CUR$',
        'CW',
        '#D',
        'DA',
        'DB$',
        'DN',
        'DO',
        '#DPM',
        'DR$',
        '#DSM',
        'DT$',
        'DV',
        'DW',
        'ER',
        'ES',
        '#F',
        'FA',
        'FB',
        'FC$',
        'FI$',
        'FP$',
        '#FPS',
        'FR',
        '#FRZ',
        'FT',
        'FX',
        '#FXA',
        '#FXT',
        'GT$',
        '#H',
        'HD',
        '#HDPM',
        '#HDSM',
        '#HREF$',
        '#HWBS',
        '#HWFC',
        'ID',
        'IF',
        'IP',
        'IS$',
        'K4',
        'KCL',
        'KP',
        'KS',
        'KZ',
        'KZF',
        'LB',
        'LI',
        'LK$',
        'LN',
        'LO',
        '#M',
        'MA$',
        'MD$',
        'ME',
        'MEDF',
        'MG',
        'MI',
        'ML',
        '#MP$',
        'MS',
        'MX',
        '#N',
        'NA$',
        '#NB$',
        'NB$',
        '#NBL$',
        'NM$',
        'NR$',
        'OM',
        'OV$',
        '#P',
        'PA$',
        'PC',
        'PING',
        'PK',
        '#PKM',
        'PL$',
        'PONG',
        'PP',
        '#R',
        'RA$',
        'RE',
        '#REF$',
        'RG$',
        'RL',
        'RO$',
        'RP',
        'RR',
        'RRC',
        'RRP',
        'RS',
        'RT$',
        'RV',
        '#S',
        'SB',
        'SC',
        '#SCL',
        'SD',
        '#SFL',
        'SI',
        'SL',
        'SM$',
        'SMH',
        'SMH$',
        'SN',
        '#SPM',
        '#SPN$',
        'SQ$',
        'SW',
        'TA',
        'TB$',
        'TD$',
        'TE',
        'TG',
        'TQ',
        'TS',
        'TX',
        'UP',
        'UT',
        '#V',
        'VC',
        '#VFA',
        '#VFB',
        'VG',
        'VI',
        'VO$',
        'VT$',
        'VX',
        '#W',
        '#WBS',
        '#WFC',
        'WM',
        'XT',
        'XV',
        'XV$',
    ]
    k4_long_cmd_bases = {
        '#A': ['#AR', '#AVG'],
        'AC': ['ACM', 'ACS', 'ACT', 'ACN1', 'ACN2', 'ACN3', 'ACN4', 'ACN5'],
        '#C': ['#CAL', '#CUR'],
        '#D': ['#DPM', '#DSM'],
        'DN': ['DNB'],
        '#F': ['#FPS', '#FRZ', '#FXA', '#FXT'],
        '#H': ['#HDPM', '#HDSM', '#HREF', '#HWBS', '#HWFC', '#HWFH'],
        'KZ': ['KZL', 'KZF'],
        'LO': ['LOG'],
        'ME': ['MEDF'],
        '#M': ['#MP'],
        '#N': ['#NBL', '#NB'],
        'PC': ['PCX'],
        'PI': ['PING'],
        'PO': ['PONG'],
        '#P': ['#PKM'],
        '#R': ['#REF'],
        'RR': ['RRT', 'RRC', 'RRP'],
        'SD': ['SD0', 'SD1', 'SDC', 'SDV', 'SDD'],           # Differentiate between the cmd variants
        'SI': ['SIDA', 'SIDD', 'SIDU', 'SIFP', 'SIRF', 'SIRC'],         # SIDU is first after param dump
        'SM': ['SMH'],
        '#S': ['#SCL', '#SFL', '#SPM', '#SPN'],
        'SW': ['SWT', 'SWH'],
        'UP': ['UPB'],
        'VG': ['VGV', 'VGD'],
        'VX': ['VXV', 'VXC'],
        '#V': ['#VFA', '#VFB'],
        '#W': ['#WBS', '#WFC', '#WFH'],
        'XV': ['XVN', 'XVM', 'XVR', 'XVI', 'XVO', 'XVP '],
# Directives:
        'CO': ['CONNECT!'],
        'EX': ['EXIT!'],
        'QU': ['QUIT!'],
        'SH': ['SHOW!'],
    }

    # commands that end in +, -, /, \, ^, > are also pseudo set-only commands
    k4_set_only_cmd_bases = {
        'AB': True,
        'DE': True,
        'DM': True,
        'DNB': True,
        'DN': True,
        'EC': True,
        'LI': True,     # where total length of cmd is <= 6 characters
        'MS': True,     # where total length of cmd is <= 4 characters
        'PING': True,
        'RC$': True,
        'RC': True,
        'RD$': True,
        'RD': True,
        'RU$': True,
        'RU': True,
        'SI': True,
        'SP$': True,
        'SP': True,
        'SWH': True,
        'SW': True,
        'SWT': True,
        'UPB': True,
        'UP': True,
# Directives:
        'QUIT': True,
        'SHOW': True,
    }

    set_only_suffixes = {
        '+': True,
        '-': True,
        '/': True,
        '\\': True,
    }

    k4_get_only_cmd_bases = {
        'BG': True,
        'IF': True,
        'MA$': True,
        'MA': True,
        'OM': True,
        'PONG': True,
        'PP': True,
        'RV': True,
        'SM$': True,
        'SMH$': True,
        'SMH': True,
        'SM': True,
        'SN': True,
        'TA': True,
        'TG': True,
        'TQ': True,
        'UT': True,
    }

    @staticmethod
    def server(server_name):
        return Server.server_dict[server_name]

    @staticmethod
    def server_names():
        return Server.server_dict.keys()

    @staticmethod
    def servers():
        return Server.server_dict.values()

    @staticmethod
    def default():
        return Server.server(Server.default_server_name)

    @staticmethod
    def k4_set_only_cmd(base, cmd):
        if base in Server.k4_set_only_cmd_bases:
            if base == 'LI' and len(cmd) > 6:
                return False
            elif base == 'MS' and len(cmd) > 4:
                return False
            else:
                return True
        elif base[-1] in Server.set_only_suffixes:
            return True
        elif base in 'KY' and len(cmd) > 2:
            return True
        else:
            return False

    @staticmethod
    def k4_get_only_cmd(base):
        return base in Server.k4_get_only_cmd_bases

    @staticmethod
    def send_cmds_with_server(cmd_list):
        for server_name, cmds in cmd_list:
            if server_name in Server.server_names():
                server = Server.server(server_name)
                server.send_cmds(cmds)
            elif server_name == 'delay':
                delay = float(cmd_dict[server_name]) / 1000
                time.sleep(delay)
            else:
                raise Exception("Unknown server name '{name}'".format(name=server_name))

    @staticmethod
    def split_cmd(cmd):
        if cmd[-1] == ';':
            cmd = cmd[0:-1]
        return cmd.split(';')

    def __init__(self, config_info):
        required = ['item', 'name', 'address', 'port']
        options = ['type', 'connect_on_start', 'button_font']
        validate_config_options(config_info, required, options)

        self.name = config_info['name']
        self.type = config_info.get('type', '').lower()
        self.startup_cmds = ''
        self.exit_cmds = ''
        self.address = config_info['address']
        self.port = config_info['port']
        self.proxy_address = ''
        self.proxy_port = ''
        self.connect_on_start = true_values(config_info.get('connect_on_start', True))
        self.socket = None
        self.recv_buffer = ''
        self.send_queue = queue.Queue()
        self.recv_queue = queue.Queue()
        self.output_audio_queue = None
        self.send_thread = None
        self.recv_thread = None
        self.connected = False
        self.k4_subscriptions = {}
        self.k4_parameters = {}
        self.connect_callbacks = []
        self.partial_packet = None
        self.password = None
        self.control_k4_audio = true_values(Settings.get('Audio', 'control_k4_audio_settings'))
        self.audio_sequence_number = 0
        self.received_initial_parameters = False
        self.received_initial_parameters_callbacks = []
        self.cat_only = False
        self.printed_connection_warning = False

        self.ignored_errors = {}

        if Server.default_server_name == None:
            Server.default_server_name = config_info['name']
        Server.server_dict[self.name] = self

        self.subscribe_response('ER;', self.on_error_code, send=False)
        self.subscribe_response('SIDU', self.on_received_initial_parameters, send=False)
        self.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        self.update_local_audio_parameters()
        if self.type == 'k4' and not self.cat_only:
            Audio.server_connected(self)

    def on_error_code(self, response):
        response = response.rstrip(';')
        try:
            code, text = response.split(':', 1)
            Popup.warning(msg=[code, text])
        except:
            Popup.warning(msg=response)

    def subscribe_connect(self, callback):
        if self.connected:
            callback()
        else:
            self.connect_callbacks.append(callback)

    def update_k4_parameter(self, base, parameter):
        if base in ('TX', 'RX', 'SD0', 'SD1', 'ES', 'TB', 'TB$'):
            if base == 'TX':
                self.k4_parameters['RX'] = None
            elif base == 'RX':
                self.k4_parameters['TX'] = None
            elif base in ('SD0', 'SD1'):   # Differentiate between the variants
                base, parameter = base[0:2] + parameter[0], base[2] + parameter[1:]
            elif base == 'ES':
                if parameter[0] == '0':
                    self.update_k4_parameter('ES0', parameter[1:])
                elif parameter[0] == '1':
                    self.update_k4_parameter('ES1', parameter[1:])
            elif base in ('TB', 'TB$'):
                if len(parameter) < 3:
                    return

        old = self.k4_parameters.get(base, None)
        self.k4_parameters[base] = parameter

        callbacks = self.k4_subscriptions.get(base, [])
        for callback in callbacks:
            callback(base + parameter + ';')

        return  old != parameter

    def k4_parameter(self, base):
        return self.k4_parameters.get(base, None)

    def connect(self):
        if self.connected:
            return

        self.cat_only = self.port == 9200

        vprint1('Connecting to {name}, address {addr}, port {port}'.format(
              name=self.name, addr=self.address, port=self.port))

        if python_major >= 3 and python_minor >= 13:
            context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            context.maximum_version = ssl.TLSVersion.TLSv1_2
            context.set_ciphers('PSK')
            psk = '1234567890'.encode()
            context.set_psk_client_callback(lambda hint: (None, psk))

        if self.proxy_address == '':
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        else:
            sock = socks.socksocket(socket.AF_INET, socket.SOCK_STREAM)
            if self.proxy_port == '':
                sock.set_proxy(socks.SOCKS5, self.proxy_address) # SOCKS5 uses port 1080 by default
            else:
                sock.set_proxy(socks.SOCKS5, self.proxy_address, self.proxy_port)
        try:
            sock.settimeout(5)
            if python_major >= 3 and python_minor >= 13 and self.port == 9204:
                sock = context.wrap_socket(sock)
            sock.connect((self.address, self.port))
            self.connected = True
            self.printed_connection_warning = False
            self.socket = sock
            self.send_thread = threading.Thread(target=self.send_loop, name=self.name+'.send_thread')

            self.send_thread.start()
            if self.cat_only:
                recv_loop = self.cat_only_recv_loop
            else:
                recv_loop = self.recv_loop

            self.recv_thread = threading.Thread(target=recv_loop, name=self.name+'.recv_thread')
            self.recv_thread.start()
            if self.type == 'k4':
                if self.cat_only:
                    self.dequeue_k4_cat()

                    self.send_str('PING;')               # Trigger a response: PONG;
                else:
                    self.output_audio_queue = queue.Queue()

                    if self.password == None:
                        self.password = Popup.password(title="Connect to K4",
                            msg="Enter your k4 remote password:")
                    h = hashlib.sha384(self.password.encode()).hexdigest()
                    self.send_str(h, force_as_string=True)

                    self.wait_for_k4_received_data()
                    self.receive_non_audio_packets()

                    Poll.add(Server.ping_poll_interval, self.ping)

                for callback in self.connect_callbacks:
                    callback()
            error = None

            if not self.cat_only:
                self.received_cat_cmd = False
                Poll.call(4000, self.check_for_received_cat_cmd)

        except socket.gaierror:
            error = 'Address not found: {addr}'.format(addr=self.address)
        except OSError:
            error = "Failed to connect to {name}, address {addr}, port {port}\n".format(
                name=self.name, addr=self.address, port=self.port)
            if self.proxy_address != '':
                port = self.proxy_port
                if port == '':
                    port = 'default'
                error += '  via proxy address {addr}, port {port}'.format(
                      name=self.name, addr=self.proxy_address, port=port)

        if error != None:
            error += "\n\nCheck the K4 address in the App tab."
            Popup.error(error, timeout=None)

    def check_for_received_cat_cmd(self):
        if not self.received_cat_cmd:
            error = 'No response received from: {name}'.format(name=self.name)
            error += "\n\nCheck the K4 password in the App tab."
            Popup.error(error, timeout=None)

    def request_initial_parameters(self):
        self.send_str('K41;')                # request K4 to respond in advanced mode
        self.send_str('EM3;')                # request opus-float encoded audio
        self.send_str('AI4;')                # request K4 to send updates immediately
        self.send_str('ER1;')                # request long format error messages
        self.send_cmds('MD;MD$;')            # cache the mode response for later use in setting the vfo step

        if self.startup_cmds != '':
            self.send_cmds(self.startup_cmds)# send user-specified startup commands

        self.send_str('RDY;')

        self.send_str('SIDA0;')              # Disable AI4 delivery of DAP info reports
        self.send_str('SIDD0;')              # Disable AI4 delivery of DDC info reports
        self.send_str('SIFP0;')              # Disable AI4 delivery of FP info reports
        self.send_str('SIRF0;')              # Disable AI4 delivery of RFB info reports
        self.send_str('SIRC0;')              # Disable AI4 delivery of RMT connection info

        self.send_str('BI;')                 # Request Band Independence status
        self.send_str('RL;')                 # Request the software release line
        self.send_str('RT$;')                # Request the VFO B RIT on/off status
        self.send_str('MX;')                 # Request the audio mixer status

    def subscribe_received_initial_parameters(self, callback):
        if self.received_initial_parameters:
            callback(self)
        else:
            self.received_initial_parameters_callbacks.append(callback)

    def on_received_initial_parameters(self, response):
        self.send_str('SIDU0;')              # Disable AI4 delivery of DUC info reports
        self.received_initial_parameters = True
        for callback in self.received_initial_parameters_callbacks:
            callback(self)

    def close(self):
        self.connected = False
        self.send_queue.put('shutdown')
        if self.output_audio_queue != None:
            self.output_audio_queue.put([])
        if self.send_thread != None:
            self.send_thread.join()
        if self.recv_thread != None:
            self.recv_thread.join()

    def exit(self):
        if self.connected:
            if self.type == 'k4' and self.exit_cmds != '':
                self.send_cmds(self.exit_cmds)
            self.send_cmds('PING;')

            # wait for commands to be sent
            while not self.send_queue.empty():
                time.sleep(.01)

        self.close()

    def send_str(self, cmd, force_as_string=False):
        if self.cat_only or force_as_string:
            self.send_queue.put((cmd.encode(), ))
        else:
            self.send_cat_packet(cmd.encode())

    def send_cat_packet(self, cat_bytes):
        self.send_queue.put((
            Server.begin_packet_marker,
            self.encode_len(len(cat_bytes)+3), 
            bytes((Server.payload_type_cat, Server.cat_version_number, Server.cat_sequence_number)),
            cat_bytes, 
            Server.end_packet_marker))

    def send_audio_packet(self, audio_bytes, encode_mode, frame_size):
        high = frame_size>>8
        low = frame_size & 0xff
        self.send_queue.put((
            Server.begin_packet_marker,
            self.encode_len(len(audio_bytes)+7),
            bytes((Server.payload_type_audio, Server.audio_version_number, self.audio_sequence_number)),
            bytes((encode_mode, low, high, Audio.k4_sample_rate_code)),
            audio_bytes,
            Server.end_packet_marker))
        self.audio_sequence_number += 1
        if self.audio_sequence_number > 0xff:
            self.audio_sequence_number = 0

    def encode_len(self, l):
        return bytearray(((l>>24)&0xff, (l>>16)&0xff, (l>>8)&0xff, l&0xff))

    def directive(self, base, cmd):
        lcmd = cmd.lower()
        if lcmd == 'connect!':
            self.connect()
        elif lcmd == 'quit!' or lcmd == 'exit!':
            exit()
        elif base.lower() == 'show!':
            page = lcmd[len(base):].strip()
            if page == 'previous':
                Page.show_previous()
            else:
                Page.show_page(page)
        else:
           raise Exception('Unknown directive: ', directive)

    def send_cmds(self, cmds):
        if isinstance(cmds, str):
            cmds = Server.split_cmd(cmds)
        for cmd in cmds:
            if cmd == '':
                continue
            base = cmd_base(cmd)
            if base[-1] == '!':
                self.directive(base, cmd)
                continue
            if base in ('SDC', 'SDV', 'SDD', 'SB') + Server.control_k4_audio_cmd_bases:
                if base in ('SDC', 'SDV', 'SDD'):
                    cmd = cmd[0:2] + cmd[3] + cmd[2] + cmd[4:]
                    base = cmd[0:3]
                elif base == 'SB':
                    Audio.control_k4_cmd(base, cmd)
                elif base in Server.control_k4_audio_cmd_bases:
                    Audio.control_k4_cmd(base, cmd)
                    if not self.cat_only and not self.control_k4_audio:
                        continue
            if self.warn_if_not_connected():
                return
            if Server.k4_set_only_cmd(base, cmd) or self.update_k4_parameter(base, cmd[len(base):]):
                cmd += ';'
                self.send_str(cmd)

    def warn_if_not_connected(self):
        if self.connected:
            return False
        if not self.printed_connection_warning:
            Popup.warning("Server '{name}' not connected.".format(name=self.name))
        self.printed_connection_warning = True
        return True

    def send_loop(self):
        while True:
            bs = self.send_queue.get()
            if not self.connected:
                return

            try:
                self.socket.sendmsg(bs)
            except:
                for b in bs:
                    try:
                        self.socket.send(b)
                    except:
                        dprint1('socket.send error')
                        Popup.error('Lost connection to ' + self.name, timeout=None)
                        self.connected = False
                        return

            if Options.debug >= 1:
                cmds = None
                if self.cat_only:
                    cmds = bs[0]
                elif bs[0] == Server.begin_packet_marker and bs[2][0] == Server.payload_type_cat:
                    cmds = bs[3]

                if cmds != None:
                    cmds = cmds.decode()
                    if cmds in ('PING;', 'ACN1;'):
                        dprint4('{name}: sent: {cmds}'.format(name=self.name, cmds=cmds))
                    else:
                        dprint2('{name}: sent: {cmds}'.format(name=self.name, cmds=cmds))

    def expand_cmds(self, cmds):
        if isinstance(cmds, str):
            return [[self.name, Server.split_cmd(cmds)]]
        elif isinstance(cmds, dict):
            cmd_dict = cmds
            ret = []
            for name in cmd_dict:
                cmd = cmd_dict[name]
                ret.append(name, Server.split_cmd(cmd_dict[name]))
            return ret
        elif isinstance(cmds, list):
            ret = []
            for cmd_dict in cmds:
                if not isinstance(cmd_dict, dict):
                    raise Exception("Unknown server sub-command '{cmd}'".format(cmd=cmd_dict))
                for name in cmd_dict:
                    cmd = cmd_dict[name]
                    ret.append(name, Server.split_cmd(cmd_dict[name]))
            return ret
        else:
            raise Exception("Error: bad cmd format: '{cmds}'".format(cmds=cmds))

    def expand_server_cmds(self, cmds):
        if isinstance(cmds, str):
            return Server.split_cmd(cmds)
        ret = []
        for name, cmds in self.expand_cmds(cmds):
            if name == self.name:
                ret.extend(cmds)
        return ret

    def expand_and_send_cmds(self, cmds):
        expanded_cmds = self.expand_cmds(cmds)
        Server.send_cmds_with_server(expanded_cmds)

    def server_cmds(self, cmds):
        ret = []
        expanded_cmds = self.expand_cmds(cmds)
        for server_name, cmds in expanded_cmds:
            if server_name != self.name:
                continue
            for cmd in cmds:
                ret.append(cmd)
        return ret

    def subscribe_responses(self, cmds, callback, send=True):
        for cmd in self.server_cmds(cmds):
            self.subscribe_response(cmd, callback, send=send)

    def unsubscribe_responses(self, cmds, callback):
        for cmd in self.server_cmds(cmds):
            self.unsubscribe_response(cmd, callback)

    def ping(self):
        self.send_str('PING;')

    def wait_for_k4_received_data(self):
        select.select([self.socket.fileno()], [], [self.socket], 1)

    def receive_non_audio_packets(self):
        packet_offset = 0

        while True:
            try:
                payload_type, payload = self.recv_queue.get_nowait()
            except queue.Empty:
                Poll.call(Server.receive_poll_interval, self.receive_non_audio_packets)
                break

            if payload_type == self.payload_type_cat:
                responses = payload.decode().split(';')[:-1]
                self.receive_k4_responses(responses)
            elif payload_type == self.payload_type_pan:
                self.received_pan(payload)
            elif payload_type == self.payload_type_minipan:
                self.received_minipan(payload)

    def received_pan(self, data):
        #tprint('pan: len:', len(data))
        pass

    def received_minipan(self, data):
        #tprint('minipan: len:', len(data))
        pass

    def dequeue_k4_cat(self):
        while True:
            responses = []

            try:
                recv_bytes = self.recv_queue.get_nowait()
            except queue.Empty:
                Poll.call(Server.receive_poll_interval, self.dequeue_k4_cat)
                break

            recv_str = recv_bytes.decode()
            responses = recv_str.split(';')
            if len(responses) == 0:
                continue

            if self.partial_packet != None:
                responses[0] = self.partial_packet + responses[0]
                self.partial_packet = ''

            if responses[-1] != '':
                self.partial_packet = responses[-1]

            responses = responses[0:-1]
            self.receive_k4_responses(responses)

    def receive_k4_responses(self, responses):
        self.received_cat_cmd = True
        for response in responses:
            base = cmd_base(response)
            if base == 'SB':
                Audio.control_k4_cmd(base, response)
            if Options.debug >= 1:
                if base in ('SM', 'SM$', 'SMH', 'SMH$', 'TM', 'PONG', 'DA', 'TB', 'TB$', 'ACN1'):
                    dprint4('{name}: received: {response};'.format(name=self.name, response=response))
                else:
                    dprint2('{name}: received: {response};'.format(name=self.name, response=response))
            if not self.control_k4_audio and base in self.control_k4_audio_cmd_bases:
                continue
            response = response[len(base):]
            if response == '?' and base not in self.ignored_errors:
                if Options.debug > 0:
                    raise Exception('Received error response from K4: ', base + response)
                else:
                    Popup.warning('Received error response from K4: ' + base + response)
            self.update_k4_parameter(base, response)

    def cat_only_recv_loop(self):
        while True:
            readable, writable, in_error = select.select([self.socket.fileno()], [], [self.socket], 1)
            if not self.connected:
                return
            if len(in_error) > 0:
                dprint1('select.select error')
                Popup.error('Lost connection to ' + self.name, timeout=None)
                self.connected = False
                return
            if len(readable) == 0:
                continue

            try:
                recv_bytes = self.socket.recv(16384)
            except:
                dprint1('socket.recv error')
                recv_bytes = []
            if len(recv_bytes) == 0:
                Popup.error('Lost connection to ' + self.name, timeout=None)
                self.connected = False
                return

            try:
                self.recv_queue.put(recv_bytes)
            except queue.ShutDown:
                pass

    def recv_loop(self):
        packet_offset = 0

        while True:
            readable, writable, in_error = select.select([self.socket.fileno()], [], [self.socket], 1)
            if not self.connected:
                return
            if len(in_error) > 0:
                dprint1('select.select error')
                Popup.error('Lost connection to ' + self.name, timeout=None)
                self.connected = False
                return
            if len(readable) == 0:
                continue

            try:
                rb = self.socket.recv(16384)
            except:
                dprint1('socket.recv error')
                rb = []
            if len(rb) == 0:
                Popup.error('Lost connection to ' + self.name, timeout=None)
                self.connected = False
                return

            if self.partial_packet != None:
                rb = self.partial_packet + rb
                self.partial_packet = None

            while True:
                remaining_length = len(rb)
                if remaining_length < 8:
                    self.partial_packet = rb
                    break
                if rb[0:4] != Server.begin_packet_marker:
                    raise Exception('bad received packet header', rb[0:4])
                payload_length = (rb[4]<<24) | rb[5]<<16 | rb[6]<<8 | rb[7]
                end_offset = 12 + payload_length
                if remaining_length < end_offset:
                    self.partial_packet = rb
                    break
                if rb[end_offset-4:end_offset] != Server.end_packet_marker:
                    raise Exception('bad received packet trailer', rb[end_offset-4:end_offset])
                #tprint('payload type', rb[8], 'version', rb[9], 'sequence', rb[10])

                payload_type = rb[8]
                payload = rb[11:end_offset-4]
                if payload_type != self.payload_type_audio:
                    try:
                        self.recv_queue.put((payload_type, payload))
                    except queue.ShutDown:
                        pass
                else:
                    # If we're behind in emptying the queue, don't bother adding to it.
                    if self.output_audio_queue.qsize() < 2:
                        self.output_audio_queue.put(payload)

                if remaining_length == end_offset:
                    break
                rb = rb[end_offset:]

    def subscribe_response(self, cmd, callback, send=True):
        base = cmd_base(cmd)
        if not base in self.k4_subscriptions:
            self.k4_subscriptions[base] = []
        if not callback in self.k4_subscriptions[base]:
            self.k4_subscriptions[base].append(callback)
        if send == True:
            parameter = self.k4_parameters.get(base, None)
            if parameter != None:
                callback(base + parameter + ';')
            elif self.connected and base not in ('TX', 'RX'):
                self.send_str(cmd_get_format(cmd))

    def unsubscribe_response(self, cmd, callback):
        base = cmd_base(cmd)
        try:
            self.k4_subscriptions[base].remove(callback)
        except:
            pass

    def clear_k4_subscriptions(self):
        self.k4_subscriptions.clear()

    def add_ignored_error(self, base):
        self.ignored_errors[base] = True

    def get_address_port(self, string):
        match = re.search('^(.*):([0-9]+)', string)
        if match == None:
            return string, ''
        return match[1], match[2]

    def set_address(self, address_port):
        address, port = self.get_address_port(address_port)
        if address != '':
            self.address = address
        if port != '':
            self.port = int(port)
        previous_address_port = self.address_port
        self.__class__.address_port = address_port
        if address_port != previous_address_port and previous_address_port != None:
            restart()

    def set_proxy(self, proxy_address_port):
        address, port = self.get_address_port(proxy_address_port)
        if address != '':
            self.proxy_address = address
        if port != '':
            self.proxy_port = int(port)
        previous_proxy_address_port = self.proxy_address_port
        self.__class__.proxy_address_port = proxy_address_port
        if proxy_address_port != previous_proxy_address_port and previous_proxy_address_port != None:
            restart()

    def set_password(self, password):
        previous_password = self.password
        self.password = password
        self.__class__.password = password
        if password != previous_password and previous_password != None:
            restart()

    def set_control_k4_audio(self, val):
        self.control_k4_audio = val

    def update_local_audio_parameters(self):
        responses = Audio.local_audio_responses()
        responses = responses.split(';')[:-1]
        for response in responses:
            base = cmd_base(response)
            response=response[len(base):]
            self.update_k4_parameter(base, response)
        if self.control_k4_audio:
            self.receive_k4_responses(responses)

class Widget():
    blink_mS = 500
    default_leading = 0
    default_label_leading = 1

    def __init__(self, config_info, container):
        self.config_info = config_info
        self.container = container
        self.bg = config_info.get('bg', Default.bg)
        if self.bg == 'None':
            self.bg = Page.top.cget('bg')
        self.fg = config_info.get('fg', Default.fg)
        self.abg = config_info.get('abg', Default.abg)
        self.afg = config_info.get('afg', Default.afg)
        if self.afg == None:
            self.afg = self.fg
        self.sticky = '' if config_info.get('sticky', None) == 'center' else 'nw'
        
        self.cached_font = None
        self.cached_button_font = None
        self.cached_label_font = None

        if 'server' in self.config_info:
            self.server = Server.server(self.config_info['server'])
        else:
            if self.container != None:
                self.server = self.container.server

        if self.container != None:
            self.frame = self.label_and_leading_frame()

    def k4param(self, base):
        if self.server.type == 'k4':
            return self.server.k4_parameter(base)
        else:
            return None

    def len_k4param(self, base):
        param = self.k4param(base)
        if param == None:
            return 0
        return len(param)

    def eval_value(self, s, value=""):
        try:
            ret = eval(str(s))
        except Exception as err:
            dprint('value: "{value}", eval("{s}")'.format(value=value, s=s))
            dprint('exception: {err}'.format(err=err))
            raise
        return ret

    def label_font(self):
        if self.cached_label_font != None:
            return self.cached_label_font
        if 'label_font' in self.config_info:
            font = self.config_info['label_font']
            font = tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])
        else:
            font = self.container.label_font()
            self.cached_label_font = font
        return font

    def button_font(self):
        if self.cached_button_font != None:
            return self.cached_button_font
        if 'button_font' in self.config_info:
            font = self.config_info['button_font']
            font = tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])
        else:
            font = self.container.button_font()
            self.cached_button_font = font
        return font

    def font(self):
        if self.cached_font != None:
            return self.cached_font
        if 'font' in self.config_info:
            font = self.config_info['font']
            font = tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])
        else:
            font = self.button_font()
            self.cached_font = font
        return font

    def label_and_leading_frame(self):
        container = self.container
        config_info = self.config_info
        if 'column' in config_info:
            column = config_info['column']
            if column < container.column:
                container.next_row()
            container.column = column

        columnspan = config_info.get('columnspan', 1)
        rowspan = config_info.get('rowspan', 1)

        self.outer_frame = tk.Frame(container.frame)

        label = config_info.get('label', None)

        if 'label' in config_info:
            default_leading = Widget.default_label_leading
        else:
            default_leading = Widget.default_leading

        leading = config_info.get('leading', default_leading)

        self.outer_frame.grid(row=container.row,
                        column=container.column,
                        rowspan=rowspan,
                        columnspan=columnspan,
                        sticky=self.sticky)

        if label == None and leading == 0:
            return self.outer_frame

        row = 0
        if leading != 0:
            family = self.label_font().cget('family')
            weight = self.label_font().cget('weight')
            leading_font = tkFont.Font(family=family, size=leading, weight=weight)
            leading_label = tk.Label(self.outer_frame, text=' ', font=leading_font)
            leading_label.grid(row=0, column=0, sticky='nw')
            row=1

        if label == None:
            inner_frame = tk.Frame(self.outer_frame)
        else:
            inner_frame = tk.LabelFrame(self.outer_frame,
                                       text=label,
                                       font=self.label_font(),
                                       labelanchor='nw',
                                       bd=2,
                                       relief='raised')
        inner_frame.grid(row=row, column=0, sticky=self.sticky)

        return inner_frame

class Container(Widget):
    depth = -1

    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        if isinstance(self, Page):
            self.childwidth = config_info.get('childwidth', None)
        else:
            self.childwidth = config_info.get('childwidth', container.childwidth)
        self.columns = config_info.get('columns', len(self.config_info['contains']))
        self.row = 0
        self.column = 0

        self.children = []

    def next_column(self):
        self.column += 1
        if self.column >= self.columns:
            self.column = 0
            self.next_row()

    def next_row(self):
        self.row += 1

    def show_widgets(self):
        Container.depth += 1
        if len(self.config_info['contains']) == 0:
            raise Exception('item: group requires a contains: option')
        for config_info in self.config_info['contains']:
            widget_type = config_info['item'].lower()
            if widget_type == 'group':
                if Options.debug > 0:
                    label = config_info.get('label', '')
                    indent = '    ' * Container.depth
                    dprint2('{indent}group {label}: row  {row}, column: {column}'.format(indent=indent, label=label, row=self.row, column=self.column))
                child = Group(config_info, self)
            elif widget_type == 'button':
                child = Button(config_info, self)
            elif widget_type == 'radiobutton':
                child = Radiobutton(config_info, self)
            elif widget_type == 'vfo':
                child = VFO(config_info, self)
            elif widget_type == 'slider':
                child = Slider(config_info, self)
            elif widget_type == 'togglebutton':
                child = Togglebutton(config_info, self)
            elif widget_type == 'getvalue':
                child = Getvalue(config_info, self)
            elif widget_type == 'bargraph':
                child = Bargraph(config_info, self)
            elif widget_type == 'text':
                child = Text(config_info, self)
            elif widget_type == 'notebook':
                child = Notebook(config_info, self)
            elif widget_type == 'dropdownbutton':
                child = Dropdownbutton(config_info, self)
            elif widget_type == 'equalizers':
               child = Equalizers(config_info, self)
            elif widget_type == 'menu':
                child = Menu(config_info, self)
            elif widget_type == 'appsettings':
                child = Settings_widget(config_info, self)
            elif widget_type == 'fwversions':
                child = FWversions(config_info, self)
            elif widget_type == 'startup_cmds':
                child = Startup_cmds(config_info, self)
            elif widget_type == 'exit_cmds':
                child = Exit_cmds(config_info, self)
            elif widget_type == 'antenna':
                child = Antenna(config_info, self)
            elif widget_type == 'cw':
                child = CW(config_info, self)

            else:
                raise Exception('Error: config file: unknown item "{type}"'.format(type=widget_type))

            self.children.append(child)

            self.next_column()

        Container.depth -= 1

    def items_width(self):
        width = 0
        for config_info in self.config_info['contains']:
            text = str(config_info.get('text', ''))
            for line in text.split('\n'):
                if len(line) > width:
                    width = len(line)
            for config_info in config_info.get('selections', []):
                text = str(config_info.get('text', ''))
                for line in text.split('\n'):
                    if len(line) > width:
                        width = len(line)
        return width

    def has_tabnames(self):
        children = self.config_info['contains']
        tabcount = 0
        for child in children:
            if child.get('item', None) == 'group' and child.get('tabname', None) != None:
                tabcount += 1
        if tabcount > 0 and tabcount != len(children):
            raise Exception('Error: Some, but not all contained items specify a tabname')

        return tabcount > 0

class Page(Container):
    pages = {}
    name_stack = []
    top = None
    notebook = None

    @staticmethod
    def show_page(page_name):
        if len(Page.name_stack) > 0:
            #            current_page_name = Page.name_stack[-1]
            #current_page = Page.pages[current_page_name]
            #current_page.hide()
            Page.current().hide()
        if page_name in Page.pages:
            Page.name_stack.append(page_name)
            Page.pages[page_name].show()
        else:
           raise Exception("Page:'{name}' not found.".format(name=page_name))

    @staticmethod
    def current():
        if len(Page.name_stack) == 0:
            return None
        return Page.pages[Page.name_stack[-1]]

    @staticmethod
    def show_previous():
        if len(Page.name_stack) < 2:
            return
        current_page_name = Page.name_stack.pop()
        page_name = Page.name_stack.pop()
        Page.name_stack.append(current_page_name)
        Page.show_page(page_name)

    @staticmethod
    def main():
        first_page_name = list(Page.pages.keys())[0]
        return Page.pages[first_page_name]

    def __init__(self, config_info):
        required = ['item', 'name', 'contains']
        options = ['server', 'columns', 'childwidth', 'label_font', 'button_font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, None)

        self.name = config_info['name']
        Page.pages[self.name] = self

        if self.has_tabnames():
            self.frame = ttk.Notebook(Page.top)
            Page.notebook = self.frame
        else:
            self.frame = tk.Frame(Page.top)

        self.show_widgets()

        self.server.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        self.server.request_initial_parameters()

    def show(self):
        self.frame.grid()

    def hide(self):
        self.frame.grid_forget()

    def label_font(self):
        font = self.config_info.get('label_font', Default.label_font)
        return tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])

    def button_font(self):
        font = self.config_info.get('button_font', Default.button_font)
        return tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])

    def server(self):
        if 'server' in self.config_info:
            server = Server.server(self.config_info['server'])
        else:
            server = None
        return server

class Group(Container):
    def __init__(self, config_info, container):
        required = ['item', 'contains']
        options = ['columns', 'column', 'columnspan', 'rowspan', 'childwidth', 'sticky',
                   'label_font', 'button_font', 'tabname', 'label', 'leading']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)
        self.tabname = config_info.get('tabname', '')

        self.show_widgets()

        if isinstance(container.frame, ttk.Notebook):
            container.frame.add(self.outer_frame, text=self.tabname)

class Button(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['text', 'cmd', 'bg', 'abg', 'fg', 'afg', 'justify', 'font', 'label', 'leading', 'button_font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        text = str(config_info.get('text', ''))
        cmd = config_info.get('cmd', None)
        justify = config_info.get('justify', 'center')

        width = container.items_width()

        if cmd != None:
            command = lambda: self.server.expand_and_send_cmds(cmd)

        button = tk.Button(self.frame,
                    bd='2',
                    text=text,
                    font=self.font(),
                    width=width,
                    justify=justify,
                    relief='raised',
                    fg=self.fg,
                    bg=self.bg,
                    activebackground=self.abg,
                    activeforeground=self.afg,
                    padx=2,
                    pady=2,
                    command=command)

        button.grid(row=0, column=0, sticky='w')

class Togglebutton(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['wraparound', 'justify', 'selections', 'label', 'leading']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        self.index = 0
        self.blink_state = False

        self.selections = []

        self.wraparound = true_values(config_info.get('wraparound', True))
        self.justify = config_info.get('justify', 'left')

        conf_selections = config_info.get('selections', None)
        for conf_sel in conf_selections:
            index = len(self.selections)
            selection = {}

            required = []
            options = ['text', 'cmd', 'evalcmd', 'response', 'evalresponse', 'bg', 'abg', 'fg', 'afg', 'blink', 'font', 'button_font', 'hidden']
            validate_config_options(conf_sel, required, options, name='togglebutton.selection')

            selection['text'] = conf_sel.get('text', '')

            cmd = conf_sel.get('cmd', None)
            orig_response = conf_sel.get('response', cmd)
            selection['response'] = orig_response

            selection['parameters'] = {}

            responses = self.server.expand_server_cmds(orig_response)
            for response in responses:
                base = cmd_base(response)
                response = response[len(base):]
                selection['parameters'][base] = response

            selection['command'] = self.do_selection

            selection['cmd'] = cmd
            selection['bg'] = conf_sel.get('bg', Default.bg)
            selection['fg'] = conf_sel.get('fg', Default.fg)
            selection['abg'] = conf_sel.get('abg', Default.abg)
            selection['afg'] = conf_sel.get('afg', Default.afg)
            if selection['afg'] == None:
                selection['afg'] = selection['fg']
            selection['blink'] = conf_sel.get('blink', False)
            selection['evalcmd'] = conf_sel.get('evalcmd', None)
            selection['evalresponse'] = conf_sel.get('evalresponse', None)
            selection['hidden'] = true_values(conf_sel.get('hidden', False))
            self.selections.append(selection)

        width = container.items_width()

        self.button = tk.Button(self.frame,
                    bd='2',
                    font=self.font(),
                    width=width,
                    relief='raised',
                    padx=2,
                    pady=2,
                    command=selection['command'])
        self.configure()

        self.button.grid(row=0, column=0, sticky='w')

        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        for selection in self.selections:
            response = selection['response']
            if response != None:
                self.server.subscribe_responses(response, self.on_response_received)

    def configure(self):
        selection = self.selections[self.index]
        self.button.configure(
                    text=selection['text'],
                    fg=selection['fg'],
                    bg=selection['bg'],
                    activebackground=selection['abg'],
                    activeforeground=selection['afg'],
                    justify=self.justify)
        if selection['blink']:
            self.blinkon(selection)
        else:
            self.blinkoff(selection)

    def next_selection(self):
        while True:
            self.index += 1
            if self.index >= len(self.selections):
                if self.wraparound:
                    self.index = 0
                else:
                    self.index = len(self.selections) - 1

            selection = self.selections[self.index]
            if not selection['hidden']:
                break

        self.configure()

    def do_selection(self):
        if self.server.warn_if_not_connected():
            return
        self.next_selection()
        selection = self.selections[self.index]

        cmd = selection['cmd']
        evalcmd = selection['evalcmd']
        if evalcmd != None:
            cmd = self.eval_value(evalcmd)
        if cmd != None:
            self.server.expand_and_send_cmds(cmd)

        self.configure()

    def compare_parameters(self, selection):
        text = selection['text']
        parameters = selection['parameters']
        for base in parameters.keys():
            k4_parameter = self.k4param(base)
            if selection['evalresponse'] != None and k4_parameter != None:
                k4_parameter = self.eval_value(selection['evalresponse'], base + k4_parameter + ';')[len(base):].rstrip(';')
            dprint3('compare :{text} s: {s}, b: {b}'.format(text=text, s=k4_parameter, b=parameters[base]))
            if parameters[base] != k4_parameter:
                dprint3(text, 'No match')
                return False
        dprint3(text, 'Match')
        return True

    def on_response_received(self, response):
        for index, selection in enumerate(self.selections):
            if self.compare_parameters(selection):
                self.index = index
                self.configure()

    def blinkon(self, selection):
        Poll.add(Widget.blink_mS, self.blink)

    def blinkoff(self, selection):
        Poll.remove(self.blink)

    def blink(self):
        selection = self.selections[self.index]
        self.blink_state = not self.blink_state
        if self.blink_state:
            self.button.configure(bg=selection['fg'], fg=selection['bg'])
        else:
            self.button.configure(bg=selection['bg'], fg=selection['fg'])

class Radiobutton(Widget):
    variables = {}
    button_counter = 0

    def __init__(self, config_info, container):
        required = ['item', 'groupid']
        options = ['text', 'cmd', 'response', 'indicator', 'selectcolor', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'blink', 'font', 'button_font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        Radiobutton.button_counter += 1

        self.text = str(config_info.get('text', ''))
        self.cmd = config_info.get('cmd', None)
        self.response = config_info.get('response', self.cmd)
        indicator = config_info.get('indicator', 1)
        selectcolor = config_info.get('selectcolor', Default.selectcolor)
        self.blink = config_info.get('blink', False)
        self.blink_state = False
        self.group_id = config_info.get('groupid', None)

        self.parameters = {}

        if not self.group_id in Radiobutton.variables:
            Radiobutton.variables[self.group_id] = tk.StringVar
        variable = Radiobutton.variables[self.group_id]

        width = container.items_width()

        self.button = tk.Radiobutton(self.frame,
                    bd='2',
                    text=self.text,
                    font=self.font(),
                    width=width,
                    relief='raised',
                    fg=self.fg,
                    bg=self.bg,
                    activebackground=self.abg,
                    activeforeground=self.afg,
                    padx=2,
                    pady=2,
                    command=self.on_clicked,
                    indicator=indicator,
                    selectcolor=selectcolor,
                    variable=variable,
                    value=Radiobutton.button_counter)

        self.button.grid(row=0, column=0, sticky='w')

        cmds = self.server.expand_server_cmds(self.cmd)
        responses = self.server.expand_server_cmds(self.response)
        for response in responses:
            base = cmd_base(response)
            response = response[len(base):]
            self.parameters[base] = response

        self.server.subscribe_responses(self.response, self.on_response_received)

    def on_clicked(self):
        if self.cmd != None:
            self.server.expand_and_send_cmds(self.cmd)

    def compare_parameters(self, group, text):
        parameters = self.parameters
        for base in parameters.keys():
            dprint3('compare {group}:{text} s: {s}, b: {b}'.format(group=group, text=text, s=self.k4param(base), b=parameters[base]))
            if parameters[base] != self.k4param(base):
                dprint3(text, 'No match')
                return False
        dprint3(text, 'Match')
        return True

    def on_response_received(self, response):
        if self.compare_parameters(self.group_id, self.text):
            self.button.select()
            if self.blink:
                self.blinkon()
        else:
            self.button.deselect()
            if self.blink:
                self.blinkoff()

    def blinkon(self):
        Poll.add(Widget.blink_mS, self.blink)

    def blinkoff(self):
        Poll.remove(self.blink)

    def blink(self):
        self.blink_state = not self.blink_state
        if self.blink_state:
            self.button.select()
        else:
            self.button.deselect()

class VFO(Widget):
    step = (1, 10, 100, 1000, 10000)
    step_index = {1: 0, 10: 1, 100: 2, 1000: 3, 10000:4}
    low_frequency_limit=10000
    high_frequency_limit=54000000
    has_focus = None

    def __init__(self, config_info, container):
        required = ['item', 'AorB']
        options = ['width', 'activecolor', 'transmitcolor', 'step_spinbox', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'blink', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        self.AorB = config_info.get('AorB', 'A').upper()

        self.width = config_info.get('width', 9)

        self.step_text_index = {}
        for i, step in enumerate(VFO.step):
            text_index = f'1.{self.width-i-(1 if i < 3 else 2)}'
            self.step_text_index[step] = text_index

        self.active_color = config_info.get('activecolor', self.bg)
        self.transmit_color = config_info.get('transmitcolor', self.bg)

        self.freq = 14100000
        self.step = 100

        frame = tk.Frame(self.frame)
        frame.grid(row=0, column=0, sticky='w')

        self.tb = tk.Text(frame, bd=2, bg='pink', fg='black', font=self.font(), height=1, width=self.width, cursor='hand2', wrap=tk.NONE)
        tb = self.tb
        tb.grid(row=0, column=0, sticky='w')

        for event in ('<Return>', '<FocusOut>'):
            tb.bind(event, self.validate_frequency)
        for step in VFO.step:
            tb.tag_bind(f'step_{step}', '<Button-1>', lambda response, step=step: self.button_one(step))

        tb.tag_config('underline', underline=1)
        tb.tag_config('right_justify', justify=tk.RIGHT)

        self.add_tags()

        step_cmd = f'VT{"$" if self.AorB == "B" else ""};'
        self.server.subscribe_response(step_cmd, self.on_step_received)
        self.server.subscribe_response(f'F{self.AorB};', self.on_frequency_received)
        # subscribe to split and transmit on/off changes
        self.server.subscribe_responses('FT;TX;RX;', self.set_vfo_bg)
        self.server.subscribe_connect(self.on_server_connect)

        self.tab = None

    def button_one(self, step):
        self.set_step(step)
        VFO.has_focus = self
        self.bind_frequency_events()

    def bind_top(self, event, fcn, bind=True):
        if bind:
            Page.top.bind(event, fcn)
        else:
            Page.top.unbind(event)

    def bind_frequency_events(self, bind=True):
        vfo = VFO.has_focus
        for key in ('<Left>', '<Right>', '<KP_Left>', '<KP_Right>'):
            vfo.bind_top(key, vfo.on_change_step, bind)
        for key in ('<Up>', '<Down>', '<KP_Up>', '<KP_Down>'):
            vfo.bind_top(key, vfo.on_bump_frequency, bind)
        for key in ('<Next>', '<Prior>', '<KP_Next>', '<KP_Prior>'):
            vfo.bind_top(key, vfo.on_jump_frequency, bind)
        if sys.platform in ('win32', 'darwin'):
            vfo.bind_top('<MouseWheel>', vfo.on_mouse_wheel, bind)
        elif sys.platform == 'linux':
            for button in ('<Button-4>', '<Button-5>'):
                vfo.bind_top(button, vfo.on_mouse_wheel, bind)

    def add_tags(self):
        for step in VFO.step:
            self.tb.tag_add(f'step_{step}', self.step_text_index[step])
        self.tb.tag_add('right_justify', '1.0')
        self.add_underline_tag()

    def add_underline_tag(self):
        self.tb.tag_remove('underline', '1.0', '1.0 lineend')
        self.tb.tag_add('underline', self.step_text_index[self.step])

    def on_server_connect(self):
        nb = Page.notebook
        nb.bind('<<NotebookTabChanged>>', self.tab_changed)
        self.tab = nb.select()

        self.tb.bind('<Visibility>', self.set_vfo_bg)

        if self.AorB == self.transmit_vfo():
            VFO.has_focus = self

        self.bind_frequency_events()

    def validate_frequency(self, event):
        if self.tb.edit_modified():
            self.add_tags()
            self.tb.edit_modified(False)
        try:
            freq = round(float(self.tb.get('1.0', '1.0 lineend')) * 1000)
            self.set_frequency(freq)
            if freq < VFO.low_frequency_limit:
                freq = VFO.low_frequency_limit
            if freq > VFO.high_frequency_limit:
                freq = VFO.high_frequency_limit
        except:
            self.set_frequency(self.freq)
        return 'break'

    def set_frequency(self, freq):
        freq_str = f'{freq / 1000:12.3f}'[12-self.width:]
        if freq_str != self.tb.get('1.0', '1.0 lineend'):
            self.tb.delete('1.0', '1.0 lineend')
            self.tb.insert('1.0', freq_str)
            self.add_tags()
        if freq != self.freq:
            self.freq = freq
            self.send_frequency(freq)
        self.set_vfo_bg()

    def send_frequency(self, freq):
        cmd = f'F{self.AorB}{freq:011f};'
        self.server.send_cmds(cmd)

    def on_frequency_received(self, response):
        freq = response_after_base(response).rstrip(';')
        self.set_frequency(float(freq))

    def set_step(self, step):
        self.step = step
        self.add_underline_tag()
        suffix = '$' if self.AorB == 'B' else ''
        index = VFO.step_index[step]
        mode = self.current_mode_index()
        cmd = f'VT{suffix}{index}{mode};'
        self.server.send_cmds(cmd)

    def on_step_received(self, response):
        step_str = response_after_base(response)
        step_index = int(step_str[0])
        if step_index == 5:                             # Work around an apparent K4 bug
            cmd = f'VT{"$" if self.AorB == "B" else ""}2;'
            self.server.send_cmds(cmd)
            step_index = 2
        self.set_step_index(step_index)

    def set_step_index(self, step_index):
        if step_index < 0:
            step_index = 0
        elif step_index > 4:
            step_index = 4
        self.step = VFO.step[step_index]
        self.add_underline_tag()

    def on_change_step(self, event):
        step_index = VFO.step_index[self.step]
        if event.keysym in ('Left', 'KP_Left'):
            step_index += 1
        else:
            step_index -= 1
        self.set_step_index(step_index)

    def adjust_frequency(self, step):
        freq = self.freq + step
        mod = freq % self.step
        freq -= mod
        if mod != 0 and step < 0:
            freq -= step
        self.set_frequency(freq)

    def on_bump_frequency(self, event):
        step = self.step
        if event.keysym in ('Down', 'KP_Down'):
            step = -step
        self.adjust_frequency(step)

    def on_jump_frequency(self, event):
        orig_step = self.step
        step_index = VFO.step_index[self.step]
        if step_index < 4:
            step_index += 1
        step = VFO.step[step_index]
        if event.keysym in ('Next', 'KP_Next'):
            step = -step
        self.set_frequency(self.freq + step)
        self.add_underline_tag()

    def on_mouse_wheel(self, event):
        if event.num == 4 or event.delta == 120:
            self.adjust_frequency(self.step)
        if event.num == 5 or event.delta == -120:
            self.adjust_frequency(-self.step)

    def current_mode_index(self):
        base = f'MD{"$" if self.AorB == "B" else ""}'
        return self.k4param(base)

    def transmit_vfo(self):
        split = self.k4param('FT') == '1'
        return 'B' if split else 'A'

    def set_vfo_bg(self, arg=None):
        if self.AorB == self.transmit_vfo():
            transmit = self.k4param('TX') != None
            if transmit:
                self.tb.configure(bg=self.transmit_color)
            else:
                self.tb.configure(bg=self.active_color)
        else:
            self.tb.configure(bg=self.bg)

    def tab_changed(self, event):
        current_tab = Page.notebook.select()
        self.bind_frequency_events(current_tab == self.tab)

class Slider(Widget):
    def __init__(self, config_info, container):
        required = ['item', 'evalcmd', 'from', 'to', 'evalresponse']
        options = ['orient', 'width', 'length', 'evalincrement', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        self.from_ = config_info['from']
        self.to = config_info['to']
        self.evalcmd = config_info['evalcmd']
        self.evalresponse = config_info['evalresponse']
        orient = config_info.get('orient', 'horizontal')
        width = config_info.get('width', 15)
        length = config_info.get('length', 15)
        self.evalincrement = config_info.get('evalincrement', 1.0)

        self.value_var = tk.DoubleVar()
        self.value_var.set(0.0)
        self.previous_value = 0.0

        from_ = self.eval_value(self.from_, self.value_var.get())
        to = self.eval_value(self.to, self.value_var.get())
        resolution = self.eval_value(self.evalincrement, self.value_var.get())

        self.scale = tk.Scale(self.frame,
                         from_=from_,
                         to=to,
                         resolution=resolution,
                         orient=orient,
                         repeatdelay=0,
                         width=width,
                         length=length,
                         font=self.font(),
                         bg=self.bg,
                         fg=self.fg,
                         variable=self.value_var)
        self.scale.grid(row=0, column=0, sticky='nw')

        self.value_var.trace('w', self.value_changed)

        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        cmd = self.eval_value(self.evalcmd, self.value_var.get())
        if cmd != "":
            self.server.subscribe_response(cmd, self.on_response_received)

    def value_changed(self, var, index, mode):
        value = self.value_var.get()
        next_value = value
        if self.previous_value == value:
            return
        if self.previous_value < value:
            next_value = value + self.eval_value(self.evalincrement, value)
        self.scale.configure(resolution=self.eval_value(self.evalincrement, next_value))
        cmd = self.eval_value(self.evalcmd, value)
        self.previous_value = value
        self.server.send_cmds(cmd)

    def on_response_received(self, response):
        value = float(self.eval_value(self.evalresponse, response))
        if value < 0:
            return
        self.scale.configure(resolution=self.eval_value(self.evalincrement, value))
        self.scale.configure(from_=self.eval_value(self.from_, value), to=self.eval_value(self.to, value))
        self.value_var.set(value)
        self.previous_value = value

class Getvalue(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['cmd', 'response', 'evalresponse', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        cmd = config_info.get('cmd', None)
        response = config_info.get('response', cmd)
        self.evalresponse = config_info.get('evalresponse', cmd)
        justify = config_info.get('justify', 'center')

        self.server.expand_and_send_cmds(cmd)

        self.label = tk.Label(self.frame,
                    bd='2',
                    font=sef.font(),
                    justify=justify,
                    fg=self.fg,
                    bg=self.bg,
                    activebackground=self.abg,
                    activeforeground=self.afg,
                    padx=2,
                    pady=2)

        self.label.grid(row=0, column=0, sticky='w')

        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        self.server.subscribe_response(response, self.on_response_received)

    def on_response_received(self, response):
        value = self.eval_value(self.evalresponse, response)
        self.label.configure(text=value)

class Bargraph(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['cmd', 'response', 'evalresponse', 'orient', 'maximum', 'evalmaximum',
                   'length', 'lengthpercent', 'lefttext', 'bottomtext', 'evalbottomtext',
                   'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        self.cmd = config_info.get('cmd', None)
        self.response = config_info.get('response', self.cmd)
        self.evalresponse = config_info.get('evalresponse', self.response)
        orient = config_info.get('orient', 'horizontal')
        self.maximum = config_info.get('maximum', 100)
        self.evalmaximum = config_info.get('evalmaximum', None)
        self.length = config_info.get('length', 100)
        self.length_percent = config_info.get('lengthpercent', None)

        self.left_text = config_info.get('lefttext', '')
        self.bottomtext = config_info.get('bottomtext', '')
        self.evalbottomtext = config_info.get('evalbottomtext', None)

        bar_frame = tk.Frame(self.frame)

        self.left_frame = tk.Frame(bar_frame)
        if self.left_text != '':
            left_label = tk.Label(self.left_frame,
                text=self.left_text,
                bd=0,
                font=self.font(),
                justify='left',
                fg=self.fg,
                bg=self.bg,
                activebackground=self.abg,
                activeforeground=self.afg,
                padx=0,
                pady=2)

            left_label.grid(row=0, column=0, sticky='w')
        self.left_frame.grid(row=0, column=0, sticky='w')

        self.progressvalue = tk.IntVar()
        self.progressbar = ttk.Progressbar(bar_frame,
                    orient=orient,
                    variable=self.progressvalue,
                    maximum=self.maximum + .001,
                    length=self.length)

        self.progressbar.grid(row=0, column=1, sticky='w')

        bar_frame.grid(row=0, column=0, sticky='w')

        self.bottom_frame = tk.Frame(self.frame)
        if self.bottomtext != None or self.evalbottomtext != None:
            self.bottom_label = tk.Label(self.bottom_frame,
                text=self.bottomtext,
                bd=0,
                font=self.font(),
                justify='left',
                fg=self.fg,
                bg=self.bg,
                activebackground=self.abg,
                activeforeground=self.afg,
                padx=0,
                pady=2)

            self.bottom_label.grid(row=0, column=0, sticky='w')
        self.bottom_frame.grid(row=1, column=0, sticky='w')

        self.server.subscribe_connect(self.on_server_connect)
        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_server_connect(self):
        self.frame.bind('<Visibility>', self.configure)
        self.server.expand_and_send_cmds(self.cmd)

    def on_received_initial_parameters(self, response):
        self.server.subscribe_response(self.response, self.on_response_received)

    def on_response_received(self, response):
        value = int(self.eval_value(self.evalresponse, response))
        self.progressvalue.set(value)
        if self.server.connected:
            self.configure()

    def configure(self, event=None):
        bottomtext = self.bottomtext
        if self.evalbottomtext != None:
            bottomtext = self.eval_value(self.evalbottomtext, None)
        self.bottom_label.configure(text=bottomtext)
        try:
            if self.bottom_label.winfo_viewable():
                self.bottom_frame.update()
            bottom_width = self.bottom_frame.winfo_width()
            left_width = self.left_frame.winfo_width()
        except:
            bottom_width = 20
            left_width = 20
        length = self.length
        if self.length_percent != None:
            length = (bottom_width - left_width) * self.length_percent / 100.0
        maximum = self.maximum
        if self.evalmaximum != None:
            maximum = float(self.eval_value(self.evalmaximum, None)) + .001
        self.progressbar.configure(length=length, maximum=maximum)

class Text(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['text', 'evaltext', 'label', 'leading', 'fg', 'bg', 'justify', 'font']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        text = config_info.get('text', '')
        evaltext = config_info.get('evaltext', None)
        justify = config_info.get('justify', 'center')

        if evaltext != None:
            text = self.eval_value(evaltext)

        lines = text.split("\n")
        height = len(lines)
        width = 0
        for line in lines:
            if len(line) > width:
                width = len(line)

        self.label = tk.Label(self.frame,
                    text=text,
                    height=height,
                    width=width,
                    bd='2',
                    font=self.font(),
                    justify=justify,
                    fg=self.fg,
                    bg=self.bg,
                    padx=2,
                    pady=2)

        self.label.grid(row=0, column=0, sticky='w')

class Notebook(Container):
    def __init__(self, config_info, container):
        required = ['item', 'contains']
        options = ['server', 'childwidth', 'label_font', 'button_font']

        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        if not has_tabnames():
            raise Exception('notebook contains items without tabnames')

        self.frame = None
        self.show_widgets()

        notebook = ttk.Notebook(self.frame)
        notebook.grid()

        for child in self.children:
            if not isinstance(child, Group):
                raise Exception('Notebook contains an item that is not a group', child)
            notebook.add(child.frame, text=child.tabname)

class Dropdownbutton(Widget):
    def __init__(self, config_info, container):
        required = ['item', 'selections']
        options = ['bg', 'abg', 'fg', 'afg', 'selectbg', 'selectfg', 'width', 'height',
                   'justify', 'unexpectedresponse', 'label', 'leading']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        texts = []
        self.text_to_index = {}

        self.index = 0
        self.blink_state = False

        self.selections = []

        self.selectbg = config_info.get('selectbg', self.bg)
        self.selectfg = config_info.get('selectfg', self.fg)
        justify = config_info.get('justify', 'right')
        height = config_info.get('height', 0)

        self.unexpected_response = config_info.get('unexpectedresponse', '')

        width = 0

        conf_selections = config_info.get('selections', None)
        for index, conf_sel in enumerate(conf_selections):
            index = len(self.selections)
            selection = {}

            required = []
            options = ['text', 'cmd', 'evalcmd', 'response', 'evalresponse', 'blink']
            validate_config_options(conf_sel, required, options, name='dropdownbutton.selection')

            text = conf_sel.get('text', '')
            selection['text'] = text
            texts.append(text)
            self.text_to_index[text] = index
            if len(text) > width:
                width = len(text)

            cmd = conf_sel.get('cmd', None)
            orig_response = conf_sel.get('response', cmd)
            selection['response'] = orig_response

            selection['parameters'] = {}
            responses = self.server.expand_server_cmds(orig_response)
            for response in responses:
                base = cmd_base(response)
                response = response[len(base):]
                selection['parameters'][base] = response

            selection['cmd'] = cmd
            selection['blink'] = conf_sel.get('blink', False)
            selection['evalcmd'] = conf_sel.get('evalcmd', None)
            selection['evalresponse'] = conf_sel.get('evalresponse', None)
            self.selections.append(selection)

        if config_info.get('width', None) != None:
            width = config_info['width']
        elif self.container.childwidth != None:
            width = self.container.childwidth

        if height == 0:
            height = len(texts)

        # Define the style for this dropdown widget
        self.stylename = str(self) + '.TCombobox'
        self.style = ttk.Style()
        self.style.configure(self.stylename, background=self.bg, foreground=self.fg, selectbackground=self.selectbg, selectforeground=self.selectfg)

        self.val = tk.StringVar()

        self.combobox = ttk.Combobox(
                self.frame,
                textvar=self.val,
                font=self.font(),
                values=texts,
                height=height,
                width=width,
                state='readonly',
                justify=justify,
                style=self.stylename,
                )
        self.combobox.option_add('*TCombobox*Listbox*Font', self.font())
        self.combobox.option_add('*TCombobox*Listbox*Justify', 'center')

        self.val.trace('w', self.on_combobox_changed)

        self.combobox.grid(row=0, column=0, sticky='e')

        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        for selection in self.selections:
            self.server.subscribe_responses(selection['response'], self.on_response_received)

    def on_combobox_changed(self, var, index, mode):
        if self.server.warn_if_not_connected():
            return
        text = self.val.get()
        if text == '':
            return

        index = self.text_to_index.get(text, None)
        if index != None:
            self.index = index
            selection = self.selections[self.index]
            cmd = selection['cmd']
            evalcmd = selection['evalcmd']
            if evalcmd != None:
                cmd = self.eval_value(evalcmd)
            if cmd != None:
                self.server.expand_and_send_cmds(cmd)

    def compare_parameters(self, selection):
        text = selection['text']
        parameters = selection['parameters']
        for base in parameters.keys():
            k4_parameter = self.k4param(base)
            if selection['evalresponse'] != None and k4_parameter != None:
                k4_parameter = self.eval_value(selection['evalresponse'], base + k4_parameter + ';')[len(base):].rstrip(';')
            dprint3('compare :{text} s: {s}, b: {b}'.format(text=text, s=k4_parameter, b=parameters[base]))
            if parameters[base] != k4_parameter:
                dprint3(text, 'No match')
                return False
        dprint3(text, 'Match')
        return True

    def on_response_received(self, response):
        found = False
        for index, selection in enumerate(self.selections):
            if self.compare_parameters(selection):
                self.index = index
                self.combobox.state='normal'
                self.val.set(selection['text'])
                self.combobox.state='readonly'
                if selection['blink']:
                    self.blinkon()
                else:
                    self.blinkoff()
                found = True
        if not found:
            if self.unexpected_response != '':
                text = self.eval_value(self.unexpected_response, response)
            else:
                text = ''

            self.combobox.state='normal'
            self.val.set(text)
            self.combobox.state='readonly'

    def blinkon(self):
        Poll.add(Widget.blink_mS, self.blink)

    def blinkoff(self):
        Poll.remove(self.blink)

    def blink(self):
        self.blink_state = not self.blink_state
        if self.blink_state:
            self.style.configure(self.stylename, selectbackground=self.selectfg, selectforeground=selectbg)
        else:
            self.style.configure(self.stylename, selectbackground=self.selectbg, selectforeground=selectfg)

class Equalizers(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['length', 'label', 'leading', 'font', 'bg', 'fg', 'selectbg', 'selectfg']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        length = config_info.get('length', 150)
        selectbg=config_info.get('selectbg', self.bg)
        selectfg=config_info.get('selectfg', self.fg)

        # Define the style for equalizer comboboxes
        self.stylename = str(self) + '.TCombobox'
        self.style = ttk.Style()
        self.style.configure(self.stylename, background=self.bg, foreground=self.fg, selectbackground=selectbg, selectforeground=selectfg)

        self.alternates = ['Main']
        self.trs = ('Receive', 'Transmit')
        self.modes = ('CW','SSB', 'AM', 'FM')
        self.values = {}

        self.enabled_var = tk.IntVar()
        self.active_alt_var = tk.StringVar()
        self.alt_var = tk.StringVar()
        self.tr_mode_var = tk.StringVar()
        self.vfo_var = tk.StringVar()

        self.load_settings()

        active_frame = tk.LabelFrame(self.frame,
                                   text='Active Equalizers',
                                   font=self.label_font(),
                                   labelanchor='n',
                                   bd=4,
                                   relief='raised')
        active_frame.grid(row=0, column=0, sticky='w', pady=5)

        active_row0_frame = tk.Frame(active_frame)
        active_row0_frame.grid(row=0, column=0, sticky='w', pady=5)

        self.enabled_checkbutton = tk.Checkbutton(active_row0_frame, text='Disabled', var=self.enabled_var, onvalue=1, offvalue=0, indicatoron=False, fg=self.fg, bg='red', selectcolor=self.bg, width=len('Disabled'))
        self.enabled_checkbutton.grid(row=0, column=0, sticky='w', pady=5)
        self.enabled_var.trace('w', self.on_enabled_changed)

        select_label = tk.Label(active_row0_frame,
                    text='Select: ',
                    height=1,
                    bd='2',
                    font=self.font(),
                    justify='left',
                    fg=self.fg,
                    padx=2,
                    pady=2)
        select_label.grid(row=0, column=1, sticky='w', padx=(30,0))

        alts = self.alternates + ['Flat']
        width = 0
        for alt in alts:
            if len(alt) > width:
                width = len(alt)

        self.active_alt_combobox = ttk.Combobox(
                active_row0_frame,
                textvar=self.active_alt_var,
                font=self.font(),
                values=alts,
                height=10,
                width=width,
                justify='left',
                style=self.stylename,
                )
        self.active_alt_combobox.grid(row=0, column=2, sticky='w', padx=(0,30))

        self.active_tr_var = tk.StringVar()
        self.active_tr_var.set(self.k4_tr())
        tr_label = tk.Label(active_row0_frame,
                    textvar=self.active_tr_var,
                    height=1,
                    bd='2',
                    font=self.font(),
                    justify='left',
                    fg=self.fg,
                    bg=self.bg,
                    padx=2,
                    pady=2)
        tr_label.grid(row=0, column=3, sticky='w', padx=(10, 0))

        self.active_mode_var = tk.StringVar()
        self.active_mode_var.set(self.k4_mode())
        mode_label = tk.Label(active_row0_frame,
                    textvar=self.active_mode_var,
                    height=1,
                    bd='2',
                    font=self.font(),
                    justify='left',
                    fg=self.fg,
                    bg=self.bg,
                    padx=2,
                    pady=2)
        mode_label.grid(row=0, column=4, sticky='w')

        vfo_frame = tk.Frame(active_frame)
        vfo_frame.grid(row=2, column=0, columnspan=5, sticky='w', pady=5)

        text = 'Receive equalizer follows mode on K4 VFO:'
        label = tk.Label(vfo_frame, text=text, font=self.font(), width=len(text), justify='right', fg=self.fg, bg=self.bg, pady=2)
        label.grid(row=0, column=0, sticky='w')

        vfo_combobox = ttk.Combobox(
                vfo_frame,
                textvar=self.vfo_var,
                font=self.font(),
                values=('A', 'B'),
                height=2,
                width=2,
                state='readonly',
                justify='left',
                style=self.stylename,
                )

        vfo_combobox.grid(row=0, column=1, sticky='w', padx=2, pady=5)

        self.equalizer_frame = tk.LabelFrame(self.frame,
                                   font=self.label_font(),
                                   labelanchor='n',
                                   bd=4,
                                   relief='raised')
        self.equalizer_frame.grid(row=1, column=0, sticky='w', pady=10)

        column0_frame = tk.Frame(self.equalizer_frame)
        column0_frame.grid(row=0, column=0, rowspan=6)

        alts = self.alternates
        width = 0
        for alt in alts:
            if len(alt) > width:
                width = len(alt)

        self.alt_combobox = ttk.Combobox(
                column0_frame,
                textvar=self.alt_var,
                font=self.font(),
                values=self.alternates,
                height=8,
                width=width,
                state='readonly',
                justify='left',
                style=self.stylename,
                )

        self.alt_combobox.grid(row=0, column=0, sticky='w', pady=5)

        tr_modes = []
        width = 0
        for tr in self.trs:
            for mode in self.modes:
                tr_mode = self.join_tr_mode(tr, mode)
                if len(tr_mode) > width:
                    width = len(tr_mode)
                tr_modes.append(tr_mode)

        self.tr_mode_combobox = ttk.Combobox(
                column0_frame,
                textvar=self.tr_mode_var,
                font=self.font(),
                values=tr_modes,
                height=8,
                width=width,
                state='readonly',
                justify='left',
                style=self.stylename,
                )

        self.tr_mode_combobox.grid(row=1, column=0, sticky='w', pady=5)

        flat_button = tk.Button(column0_frame,
                    bd='2',
                    text='Set Flat',
                    font=self.font(),
                    width=8,
                    justify='center',
                    relief='raised',
                    fg=self.fg,
                    bg=self.bg,
                    activebackground=self.bg,
                    activeforeground=self.fg,
                    padx=2,
                    pady=2,
                    command=self.on_set_flat)
        flat_button.grid(row=2, column=0, sticky='w', pady=5)

        label = tk.Label(column0_frame, text='Add:', bd='2', font=self.font(), justify='center', fg=self.fg, bg=self.bg, padx=2, pady=2)
        label.grid(row=3, column=0, sticky='w')

        self.add_var = tk.StringVar()
        add_entry = tk.Entry(column0_frame, textvariable=self.add_var, width=width, justify='left', font=self.font(), fg=self.fg, bg=self.bg)
        add_entry.grid(row=4, column=0, sticky='w')
        add_entry.bind('<Return>', self.on_add_alt)

        self.remove_button =  tk.Button(column0_frame,
                    bd='2',
                    text='',
                    state='disabled',
                    font=self.font(),
                    width=0,
                    justify='center',
                    relief='raised',
                    fg=self.fg,
                    bg=self.bg,
                    activebackground=self.bg,
                    activeforeground=self.fg,
                    padx=2,
                    pady=2,
                    command=self.on_remove_alt)
        self.remove_button.grid(row=5, column=0, sticky='w', pady=2)

        self.scale_value_vars = []
        self.scales = []
        self.freqs = (100, 200, 400, 800, 1200, 1600, 2400, 3200)
        for i in range(len(self.freqs)):
            value = tk.IntVar()
            self.scale_value_vars.append(value)
            value.set(0)
            scale = tk.Scale(self.equalizer_frame,
                             from_=16,
                             to=-16,
                             resolution=1,
                             orient='vertical',
                             repeatdelay=0,
                             length=length,
                             font=self.font(),
                             bg=self.bg,
                             fg=self.fg,
                             variable=value)
            scale.grid(row=0, column=i+1, pady=0)
            value.trace('w', lambda var, index, mode, i=i: self.on_value_changed(var, index, mode, i))
            self.scales.append(scale)

            label = tk.Label(self.equalizer_frame,
                             text=self.freqs[i],
                             bd=0,
                             font=self.font(),
                             justify='center',
                             fg=self.fg,
                             bg=self.bg)
            label.grid(row=1, column=i+1, pady=0)

        self.vfo_var.trace('w', self.on_vfo_changed)
        self.alt_var.trace('w', self.on_alt_changed)
        self.tr_mode_var.trace('w', self.on_tr_mode_changed)
        self.active_alt_var.trace('w', self.on_active_alt_changed)

        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        self.server.subscribe_responses('TX;RX;MD;MD$;FT;', self.on_k4_mode_changed)
        self.set_k4_equalizer()
        self.configure()

    def on_enabled_changed(self, var, index, mode):
        self.set_k4_equalizer()
        self.configure()
        self.save_settings()

    def enabled(self):
        return int(self.enabled_var.get()) != 0

    def tr_mode(self):
        tr_mode = self.tr_mode_var.get()
        return self.split_tr_mode(tr_mode)

    def join_tr_mode(self, tr, mode):
        return f'{tr} - {mode}'

    def split_tr_mode(self, tr_mode):
        return tr_mode.rsplit(' - ', 1)

    def alt_tr_mode(self):
        alt = self.alt_var.get()
        tr, mode = self.tr_mode()
        return alt, tr, mode

    def join_alt_tr_mode(self, alt, tr, mode):
        return f'{alt} - {tr} - {mode}'

    def k4_tr(self):
        tr_index = 1 if self.k4param('TX') != None else 0
        return self.trs[tr_index]

    def k4_mode(self):
        tr = self.k4_tr()
        base = 'MD'
        if tr == 'Receive':
            if self.vfo_var.get() == 'B':
                base += '$'
        else:
            split = self.k4param('FT') == '1'
            if split:
                base += '$'

        k4_modes = ('', 'SSB', 'SSB', 'CW', 'FM', 'AM', '', 'CW', '', '')
        k4_mode = self.k4param(base)
        if k4_mode ==  None or k4_mode == '':
            return None
        mode = k4_modes[int(k4_mode)]
        return mode

    def values_str(self, values):
        strs = []
        for value in values:
            strs.append('{value:+03d}'.format(value=value))
        return ''.join(strs)

    def str_values(self, s):
        values = []
        for offset in range(0, 24, 3):
            values.append(int(s[offset:offset+3]))
        return values

    def set_k4_equalizer(self):
        if not self.enabled():
            return

        mode = self.k4_mode()
        if mode == None or mode == '':
            return

        alt = self.active_alt_var.get()
        tr = self.k4_tr()
        if tr == 'Receive':
            base = 'RE'
        else:
            base = 'TE'
        values = self.values[alt][tr][mode]
        cmd = base + self.values_str(values) + ';'
        self.server.send_cmds(cmd)

    def on_active_alt_changed(self, var, index, mode):
        self.set_k4_equalizer()
        self.configure()
        self.save_settings()

    def on_value_changed(self, var, index, mode, i):
        value = self.scale_value_vars[i].get()
        alt, tr, mode = self.alt_tr_mode()
        self.values[alt][tr][mode][i] = value
        self.set_k4_equalizer()
        self.save_settings()

    def on_alt_changed(self, var, index, mode):
        self.configure()
        self.set_k4_equalizer()
        self.save_settings()

    def on_tr_mode_changed(self, var, index, mode):
        self.configure()
        self.set_k4_equalizer()
        self.save_settings()

    def on_k4_mode_changed(self, response):
        mode = self.k4_mode()
        if mode == None or mode == '':
            return

        self.active_tr_var.set(self.k4_tr())
        self.active_mode_var.set(mode)
        self.set_k4_equalizer()
        self.configure()

    def on_set_flat(self):
        alt, tr, mode = self.alt_tr_mode()
        self.values[alt][tr][mode] = [0, 0, 0, 0, 0, 0, 0, 0]

        self.set_k4_equalizer()
        self.configure()
        self.save_settings()

    def on_add_alt(self, event):
        alt = self.add_var.get()
        if alt in self.alternates + ['Flat']:
            return
        self.alternates.append(alt)
        self.values[alt] = {}
        for tr in self.trs:
            self.values[alt][tr] = {}
            for mode in self.modes:
                self.values[alt][tr][mode] = [0, 0, 0, 0, 0, 0, 0, 0]
        self.alt_var.set(alt)
        self.add_var.set("")
        self.configure()
        self.save_settings()

    def on_remove_alt(self):
        alt = self.alt_var.get()
        if alt == 'Main':
            return

        self.alternates.remove(alt)
        del self.values[alt]

        alt = self.alternates[0]
        self.alt_var.set(alt)

        self.configure()
        self.set_k4_equalizer()
        self.save_settings()

    def on_vfo_changed(self, var, index, mode):
        self.set_k4_equalizer()
        self.configure()
        self.save_settings()

    def configure(self):
        if self.enabled():
            self.enabled_checkbutton.configure(text='Enabled')
        else:
            self.enabled_checkbutton.configure(text='Disabled')

        alts = self.alternates + ['Flat']
        width = 0
        for alt in alts:
            if len(alt) > width:
                width = len(alt)
        self.active_alt_combobox.configure(values=alts, width=width+1)

        alt, tr, mode = self.alt_tr_mode()
        for i, value in enumerate(self.values[alt][tr][mode]):
            if value != self.scale_value_vars[i].get():
                self.scale_value_vars[i].set(value)

        if alt == 'Main' or alt == self.active_alt_var.get():
            self.remove_button.configure(text='', width=0, state='disabled')
        else:
            text = 'Remove: ' + alt
            self.remove_button.configure(text=text, width=len(text), state='normal')

        alt_tr_mode = self.join_alt_tr_mode(alt, tr, mode)
        self.equalizer_frame.configure(text=alt_tr_mode)

        width = 0
        for alt in self.alternates:
            if len(alt) > width:
                width = len(alt)
        self.alt_combobox.configure(values=self.alternates, height=8, width=width)

        tr_modes = []
        width = 0
        for tr in self.trs:
            for mode in self.modes:
                tr_mode = self.join_tr_mode(tr, mode)
                if len(tr_mode) > width:
                    width = len(tr_mode)
                tr_modes.append(tr_mode)
        self.tr_mode_combobox.configure(values=tr_modes, height=8, width=width)

    def save_settings(self):
        category = 'Equalizers'
        previous_settings = Settings.get_category(category)
        Settings.clear_category(category)

        Settings.put(category, 'enabled', str(self.enabled_var.get()))
        Settings.put(category, 'active', self.active_alt_var.get())
        Settings.put(category, 'alternates', ', '.join(self.alternates))
        Settings.put(category, 'alt.tr.mode', '.'.join(self.alt_tr_mode()))
        
        for alt in self.alternates:
            for tr in self.trs:
                for mode in self.modes:
                    setting = '.'.join((alt, tr, mode))
                    values = self.values[alt][tr][mode]
                    values_str = self.values_str(values)
                    Settings.put(category, setting, values_str)

        settings = Settings.get_category(category)
        if settings != previous_settings:
            Settings.save()

    def load_settings(self):
        category = 'Equalizers'
        enabled = Settings.get(category, "enabled")
        if enabled == None:
            enabled = 0
        self.enabled_var.set(int(enabled))

        active = Settings.get(category, 'active')
        if active == None:
            active = self.alternates[0]
        self.active_alt_var.set(active)

        vfo = Settings.get(category, 'follows_vfo')
        if vfo == None:
            vfo = 'A'
        self.vfo_var.set(vfo)

        alternates = Settings.get(category, 'alternates')
        if alternates == None:
            alternates = 'Main'
        self.alternates = alternates.split(', ')

        alt_tr_mode = Settings.get(category, 'alt.tr.mode')
        if alt_tr_mode == None:
            alt = self.alternates[0]
            tr = self.trs[0]
            mode = self.modes[0]
        else:
            alt, tr, mode = alt_tr_mode.rsplit('.', 2)
        self.alt_var.set(alt)
        self.tr_mode_var.set(self.join_tr_mode(tr, mode))
        
        for alt in self.alternates + ['Flat']:
            self.values[alt] = {}
            for tr in self.trs:
                self.values[alt][tr] = {}
                for mode in self.modes:
                    setting = '.'.join((alt, tr, mode))
                    values_str = Settings.get(category, setting)
                    if values_str != None:
                        self.values[alt][tr][mode] = self.str_values(values_str)
                    else:
                        self.values[alt][tr][mode] = [0, 0, 0, 0, 0, 0, 0, 0]

def cmd_base(cmd):
    ucmd = cmd.upper()
    base = ucmd[0:2]
    if base in Server.k4_long_cmd_bases:
        for long_base in Server.k4_long_cmd_bases[base]:
            if ucmd.startswith(long_base):
                base = long_base
                break
    if len(cmd) > len(base):
        if cmd[len(base)] == '$':
            base += '$'
        elif cmd[len(base)] == '!':
            base += '!'
    return base

def cmd_get_format(cmd):
    base = cmd_base(cmd)
    get_base = base
    if base == 'ML':
        get_base = cmd[0:3]
    elif base == 'BR':
        get_base = cmd[0:3]
    elif base == 'PK':
        get_base = cmd[0:4]
    return get_base + ';'

def response_after_base(response):
    i = len(cmd_base(response))
    return response[i:]

def true_values(v):
    if v == True or v == 1:
        return True

    if not isinstance(v, str):
        return False

    v = v.lower()
    return v == 'true' or v == 'on' or v == '1' or v == 'yes'

class Menu_definition():
    def __init__(self, menu, d):
        self.menu = menu
        self.index = int(d[0])
        self.desc = hex_decode(d[1])
        self.area = d[2]
        self.type = d[3]
        self.locked = 'Unlocked' if d[4] == '0' else 'Locked' if d[4] == '1' else 'Unmodifiable' if d[4] == '2' else ''
        self.low = self.typed_value(d[5])
        self.high = self.typed_value(d[6])
        self.default = self.typed_value(d[7])
        self.current = self.typed_value(d[8])
        self.increment = self.typed_value(d[9])
        self.values = []
        for value in d[10:]:
            self.values.append(hex_decode(value))
        self.container = menu.container
        self.server = menu.server

        self.send_command = self.widget_send_command

        self.updated_desc = self.desc

        self.widget = None
        self.changeable = ''

        self.frame = tk.LabelFrame(self.menu.frame,
                                   text=self.desc,
                                   font=self.menu.label_font(),
                                   labelanchor='nw',
                                   bd=4,
                                   relief='raised')

        if len(self.values) > 0:
            self.listbox()
        elif self.type == 'BIN':
            self.range_listbox()
        elif self.type == 'VFOCRS':
            self.vfocrs()
        elif self.type == 'AOFS':
            self.aofs()
        elif self.type == 'M50Hz':
            self.m50hz()
        elif self.type == 'ZMON':
            self.zmon()
        elif self.type == 'D10mW':
            self.d10mw()
        elif self.type in ('DEC', 'REF', 'ms', 'ZOFF', 'MHz', 'Hz'):
            self.slider()
        elif self.type in ('IP', 'SN'):
            self.fixed_text()
        elif self.type == 'STR':
            self.text()

        self.locked_frame = tk.Frame(self.frame)
        self.locked_frame.grid(row=0, column=1)

        self.locked_button = tk.Button(self.locked_frame,
                    bd='2',
                    text=self.locked,
                    font=self.menu.font(),
                    width=12,
                    justify='center',
                    relief='raised',
                    fg=self.menu.fg,
                    bg=self.menu.bg,
                    activebackground=self.menu.abg,
                    activeforeground=self.menu.afg,
                    padx=2,
                    pady=2,
                    command=self.on_locked_changed)

        self.locked_button.grid(row=0, column=0)

        self.default_button = tk.Button(self.locked_frame,
                    bd='2',
                    text="Set to\nNormal",
                    font=self.menu.font(),
                    width=12,
                    justify='center',
                    relief='raised',
                    fg=self.menu.fg,
                    bg=self.menu.bg,
                    activebackground=self.menu.abg,
                    activeforeground=self.menu.afg,
                    padx=2,
                    pady=2,
                    command=self.on_default_clicked)

        self.default_button.grid(row=1, column=0)

    def null_update(self, current=None):
        pass

    def on_locked_changed(self):
        if self.locked == 'Locked':
            if self.changeable == 'Locked':
                self.changeable = 'Unlocked'
            else:
                self.changeable = 'Locked'

        self.update()

    def update(self, locked=None, current=None):
        self.update_widget(current=current)

        if locked != None:
            self.changeable = locked

        if self.changeable == 'Unmodifiable':
            self.default_button.grid_forget()
        elif self.changeable == 'Unlocked':
            self.default_button.grid(row=1, column=0)
            self.default_button.configure(state='normal')
        else:
            self.default_button.grid(row=1, column=0)
            self.default_button.configure(state='disabled')

        self.locked_button.configure(text=self.changeable)

        self.update_desc()

    def update_desc(self):
        desc = self.updated_desc
        if self.area == 'XV':
            if self.type == 'DEC':
                self.menu.xv_band = int(self.current)
            else:
                self.updated_desc = self.desc.replace('<n>', str(self.menu.xv_band))

            if self.updated_desc != desc:
                self.menu.listbox.delete(self.position)
                self.menu.listbox.insert(self.position, self.updated_desc)

        if self.type == 'ms':
            self.updated_desc = self.desc + "\n(mS)"

        if self.type == 'ZMON':
            self.updated_desc = self.desc + "\n(-1 = OFF, 0 = MON)"

        if self.type == 'ZOFF':
            self.updated_desc = self.desc + "\n(0 = OFF)"

        if self.type == 'MHz':
            self.updated_desc = self.updated_desc + "\n(MHz)"

        if self.type == 'D10mW':
            self.updated_desc = self.updated_desc + "\n(mW)"

        if self.type == 'Hz':
            self.updated_desc = self.updated_desc + "\n(Hz)"

        if self.updated_desc != desc:
            self.frame.configure(text=self.updated_desc)
        
    def current_desc(self):
        return self.updated_desc

    def on_default_clicked(self):
        if self.changeable == 'Unlocked':
            self.update(current=self.default)
            self.send_command()

    def show(self):
        self.update(locked=self.locked)
        self.frame.grid(row=0, column=2)

    def hide(self):
        self.frame.grid_forget()

    def listbox(self):
        self.update_widget = self.listbox_update
        self.widget = tk.Listbox(
                self.frame,
                font=self.menu.font(),
                justify='left',
                bg=self.menu.bg,
                fg=self.menu.fg,
                selectbackground=self.menu.selectbg,
                selectforeground=self.menu.selectfg,
                exportselection=False,
                )

        if self.low != 0:
            raise Exception('Unexpected listbox low ', self.low)

        high = self.high + 1
        if high < len(self.values):
            self.values = self.values[:high]
        
        width = 0
        for value in self.values:
            value = str(value)
            if len(value) > width:
                width = len(value)
            self.widget.insert(tk.END, value)

        width = int(round(width*1.1)+1)
        self.widget.configure(height=len(self.values), width=width)
        self.widget.selection_clear(0, tk.END)
        self.widget.selection_set(self.current)
        selections = self.widget.curselection()
        if len(selections) > 0:
            index = selections[0]

        self.widget.grid(row=0, column=0)
        self.widget.bind('<<ListboxSelect>>', self.on_listbox_selected)

    def on_listbox_selected(self, arg):
        if self.changeable != 'Unlocked':
            self.widget.selection_clear(0, tk.END)
            self.widget.selection_set(self.current)
            return

        selections = self.widget.curselection()
        index = selections[0]
        self.current = index
        self.send_command()

    def listbox_update(self, current=None):
        if current != None:
            self.current = current
        self.widget.selection_clear(0, tk.END)
        self.widget.selection_set(self.current)

    def vfocrs(self):
        self.values = ('0.1 kHz', '0.5 kHz', '1.0 kHz', '2.5 kHz')
        self.listbox()

    def m50hz(self):
        self.values = ('150 Hz', '200 Hz', '250 Hz', '300 Hz', '350 Hz', '400 Hz', '450 Hz', '500 Hz', '550 Hz', '600 Hz', '650 Hz', '700 Hz')
        self.high -= self.low
        self.low = 0
        self.listbox()
        self.send_command = self.m50hz_send_command
        self.update_widget = self.m50hz_update

    def m50hz_send_command(self):
        value = int(self.current) + 3
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def m50hz_update(self, current=None):
        if current != None:
            self.current = current - 3
        self.listbox_update()

    def aofs(self):
        self.low -= 8
        self.high -= 8
        self.slider()
        self.send_command = self.aofs_send_command
        self.update_widget = self.aofs_update

    def aofs_send_command(self):
        value = int(self.current) + 8
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def aofs_update(self, current=None):
        if current != None:
            self.current = current - 8
        self.slider_update()

    def zmon(self):
        self.current -= 1
        self.low -= 1
        self.high -= 1
        self.slider()
        self.send_command = self.zmon_send_command
        self.update_widget = self.zmon_update

    def zmon_send_command(self):
        value = int(self.current) + 1
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def zmon_update(self, current=None):
        if current != None:
            self.current = current - 1
        self.slider_update()

    def d10mw(self):
        self.low = float(self.low) / 10
        self.high = float(self.high) / 10
        self.increment = float(self.increment) / 10
        self.slider()
        self.send_command = self.d10mw_send_command
        self.update_widget = self.d10mw_update

    def d10mw_send_command(self):
        value = int(self.current * 10)
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def d10mw_update(self, current=None):
        if current != None:
            self.current = float(current) / 10
        self.slider_update()

    def range_listbox(self):
        for i in range(self.low, self.high+1, self.increment):
            self.values.append(i)
        self.high -= self.low
        self.low = 0
        self.listbox()
        self.send_command = self.range_listbox_send_command
        self.update_widget = self.range_listbox_update

    def range_listbox_update(self, current=None):
        if current != None:
            self.current = self.values.index(current)
        self.widget.selection_clear(0, tk.END)
        self.widget.selection_set(self.current)

    def range_listbox_send_command(self):
        value = int(self.values[self.current])
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def slider(self):
        self.update_widget = self.slider_update
        self.value = tk.DoubleVar()
        self.value.set(self.current)

        self.widget = tk.Scale(self.frame,
                         from_=self.high,
                         to=self.low,
                         orient='vertical',
                         resolution=self.increment,
                         width=20,
                         length=font_height(self.menu.font())*9,
                         font=self.menu.font(),
                         bg=self.menu.bg,
                         fg=self.menu.fg,
                         variable=self.value,
                         command=self.slider_value_changed)
        self.widget.grid(row=0, column=0)

    def slider_value_changed(self, event):
        if self.changeable != 'Unlocked':
            self.value.set(self.current)
            return

        self.current = self.value.get()
        self.send_command()

    def slider_update(self, current=None):
        if current != None:
            if isinstance(current, str) and current.find('-') > 0:
                current = current.lstrip('0')
            self.current = current
        self.value.set(self.current)

    def fixed_text(self):
        self.update_widget = self.fixed_text_update
        self.widget = tk.Label(self.frame,
            text=self.current,
            bd=2,
            font=self.menu.font(),
            justify='left',
            fg=self.menu.fg,
            bg=self.menu.bg,
            activebackground=self.menu.abg,
            activeforeground=self.menu.afg,
            padx=2,
            pady=2)
        self.widget.grid(row=0, column=0)

    def fixed_text_update(self, current=None):
        if current != None:
            self.current = current
        self.locked = 'Unmodifiable'
        self.widget.configure(text=self.current)

    def text(self):
        self.update_widget = self.text_update
        self.text_var = tk.StringVar()
        self.text_var.set(self.current)
        self.widget = tk.Entry(self.frame,
            textvariable=self.text_var,
            bd=2,
            font=self.menu.font(),
            justify='left',
            fg=self.menu.fg,
            bg=self.menu.bg)
        self.widget.grid(row=0, column=0)
        self.widget.bind('<Return>', self.set_text)
        self.widget.bind('<FocusOut>', self.set_text)

    def set_text(self, event):
        self.current = self.text_var.get()
        self.send_command()

    def text_update(self, current=None):
        if current != None:
            self.current = current
        self.text_var.set(self.current)

    def widget_send_command(self):
        if isinstance(self.current, str) or self.type == 'REF':
            self.server.send_str('ME{index:04d}.{value};'.format(index=self.index, value=self.current))
        else:
            value = int(round(self.current))
            self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def typed_value(self, n):
        if self.type == 'REF':
            return n
        try:
            n = float(n)
            if int(n) == n:
                n = int(n)
        except:
            pass
        return n

    def print(self):
        dprint('index', self.index)
        dprint('desc', self.desc)
        dprint('area', self.area)
        dprint('type', self.type)
        dprint('locked', self.locked)
        dprint('low', self.low)
        dprint('high', self.high)
        dprint('default', self.default)
        dprint('current', self.current)
        dprint('increment', self.increment)
        dprint('values', self.values)

class Menu(Widget):
    entries_displayed = 15

    def __init__(self, config_info, container):
        required = ['item']
        options = ['entries_displayed', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'selectbg', 'selectfg', 'font', 'label_font' ]
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        entries_displayed = config_info.get('entries_displayed', Menu.entries_displayed)

        self.current_md = None

        self.selectbg = config_info.get('selectbg', self.bg)
        self.selectfg = config_info.get('selectfg', self.fg)

        self.definitions = []
        self.lookup_definitions = {}

        self.xv_band = 0

        self.frame = tk.Frame(self.frame)
        self.frame.grid(row=0, column=0)

        self.listbox = tk.Listbox(
                self.frame,
                font=self.font(),
                height=entries_displayed,
                justify='left',
                bg=self.bg,
                fg=self.fg,
                selectbackground=self.selectbg,
                selectforeground=self.selectfg,
                exportselection=False,
                )

        self.scrollbar = tk.Scrollbar(self.frame)
        self.listbox.config(yscrollcommand=self.scrollbar.set)
        self.scrollbar.config(command=self.listbox.yview)

        self.listbox.bind('<<ListboxSelect>>', self.on_listbox_selected)
        self.server.subscribe_response('MEDF;', self.on_received_definition, send=False)

    def update_definition_list(self):
        self.listbox.delete(0, tk.END)

        width = 0
        for i, md in enumerate(self.definitions):
            md.position = i
            desc = md.current_desc()
            if len(desc) > width:
                width = len(desc)
            self.listbox.insert(tk.END, md.desc)

        self.listbox.configure(width=width)

    def received_all_definitions(self):
        self.server.subscribe_response('ME;', self.on_received_current, send=False)

        self.definitions = sorted(self.definitions, key=lambda d:d.current_desc().casefold())
        self.update_definition_list()

        self.server.send_str('ME0043;')         # request updated IP address. We know this has changed.
        self.server.send_str('ME0086;ME0078;ME0076;ME0079;ME0098;ME0077;')   # request current transverter band menu settings

        self.listbox.grid(row=0, column=0, sticky='w')
        self.scrollbar.grid(row=0, column=1, sticky='ns')

    def on_received_current(self, response):
        index, current_value = response[2:].split('.', 1)
        current_value = current_value.rstrip(';')
        index = int(index)
        md = self.lookup_definitions[index]
        current_value = md.typed_value(current_value)
        md.update(current=current_value)

    def on_listbox_selected(self, arg):
        selections = self.listbox.curselection()
        if len(selections) == 0:
            return

        index = selections[0]

        if self.current_md != None and self.current_md.widget != None:
            self.current_md.hide()

        md = self.definitions[index]
        self.current_md = md

        md.show()

    def on_received_definition(self, response):
        if response[4:8] == '0000':
            self.received_all_definitions()
            return

        definition_values = response[4:].rstrip(';').split(',')
        if len(definition_values) < 3 or definition_values[3] == 'NULL':                      # md.type
            return

        md = Menu_definition(self, definition_values)
        found = self.lookup_definitions.get(md.index, None)
        if found != None:
            return

        self.lookup_definitions[md.index] = md
        self.definitions.append(md)

class Audio():
    singleton = None
    input_channels = 1
    k4_input_channels = 2               # The K4 requires stereo, even though it transmits mono
    input_frame_size = 240
    output_channels = 2
    k4_sample_rate = 12000
    k4_sample_rate_code = 0
    max_input_sample_rate = 48000
    max_output_sample_rate = 48000
    encode_mode_raw32 = 0
    encode_mode_raw16 = 1
    encode_mode_opus = 2
    encode_mode_opus_float = 3
    input_encode_mode = encode_mode_opus_float
    server = None

    @classmethod
    def get_singleton(cls):
        if cls.singleton == None:
            cls.singleton = Audio()

        return cls.singleton

    @classmethod
    def close(cls):
        if cls.singleton == None:
            return

        self = cls.singleton
        self.transmit_audio = False
        if self.input_thread != None:
            self.input_thread.join()
        if self.output_thread != None:
            self.output_thread.join()

    @classmethod
    def set_input_device_name(cls, name):
        self = cls.get_singleton()
        dev_info = self.input_device_info_by_name(name)
        if dev_info != None:
            self.input_device_index = dev_info['index']

    @classmethod
    def set_output_device_name(cls, name):
        self = cls.get_singleton()
        dev_info = self.output_device_info_by_name(name)
        if dev_info != None:
            self.output_device_index = dev_info['index']

    @classmethod
    def input_device_name(cls):
        self = cls.get_singleton()
        if self.input_device_index < 0:
            return "None available"
        dev_info = self.input_device_infos[self.input_device_index]
        return dev_info['name']

    @classmethod
    def output_device_name(cls):
        self = cls.get_singleton()
        if self.output_device_index < 0:
            return "None available"
        dev_info = self.output_device_infos[self.output_device_index]
        return dev_info['name']

    @classmethod
    def input_device_info(cls):
        self = cls.get_singleton()
        if self.input_device_index < 0:
            return None
        return self.input_device_infos[self.input_device_index]


    @classmethod
    def output_device_info(cls):
        self = cls.get_singleton()
        if self.output_device_index < 0:
            return None
        return self.output_device_infos[self.output_device_index]

    @classmethod
    def input_device_index(cls):
        self = cls.get_singleton()
        return self.input_device_index

    @classmethod
    def output_device_index(cls):
        self = cls.get_singleton()
        return self.output_device_index

    @classmethod
    def input_device_names(cls):
        self = cls.get_singleton()
        names = []
        for index in self.input_device_infos:
            device_info = self.input_device_infos[index]
            names.append(device_info['name'])
        return names

    @classmethod
    def output_device_names(cls):
        self = cls.get_singleton()
        names = []
        for index in self.output_device_infos:
            device_info = self.output_device_infos[index]
            names.append(device_info['name'])
        return names

    @classmethod
    def input_device_sample_rate(cls):
        self = cls.get_singleton()
        if self.input_device_index < 0:
            return None
        info = self.input_device_infos[self.input_device_index]
        return info['input_sample_rate']

    @classmethod
    def output_device_sample_rate(cls):
        self = cls.get_singleton()
        if self.output_device_index < 0:
            return None
        info = self.output_device_infos[self.output_device_index]
        return info['output_sample_rate']

    @classmethod
    def control_k4_cmd(cls, base, cmd):
        self = cls.get_singleton()
        cmd = cmd[len(base):]

        if base == 'AG':
            Settings.put_save('Audio', 'main_volume', cmd)
            self.a_volume = float(cmd) / 60.0
        elif base == 'AG$':
            Settings.put_save('Audio', 'sub_volume', cmd)
            self.b_volume = float(cmd) / 60.0
        elif base == 'MG':
            Settings.put_save('Audio', 'mic_gain', cmd)
            self.mic_gain = float(cmd) / 80.0
        elif base == 'SB':
            self.sub_on = cmd != '0'

    @classmethod
    def local_audio_responses(cls):
        a_volume = Settings.get('Audio', 'main_volume')
        if a_volume == None:
            a_volume = '000'
        responses = 'AG' + a_volume + ';'

        b_volume = Settings.get('Audio', 'sub_volume')
        if b_volume == None:
            b_volume = '000'
        responses += 'AG$' + b_volume + ';'

        mic_gain = Settings.get('Audio', 'mic_gain')
        if mic_gain == None:
            mic_gain = '020'
        responses += 'MG' + mic_gain + ';'

        return responses

    @classmethod
    def server_connected(cls, server):
        self = cls.get_singleton()
        cls.server = server
        server.subscribe_responses('TX;RX;', lambda response: self.on_transmit_changed(server, response), send=False)
        server.subscribe_response('MX;', lambda response: self.on_mx_changed(server, response), send=False)
        server.subscribe_received_initial_parameters(cls.on_received_initial_parameters)

    @classmethod
    def on_received_initial_parameters(cls, server):
        self = cls.get_singleton()
        self.start_output_thread(cls.server.output_audio_queue)

    def pyaudio(self):
        fd = os.dup(2)
        os.close(2)              # Close stderr because pyaudio outputs a lot of disquieting messages
        pa = pyaudio.PyAudio()
        os.dup2(fd, 2)           # restore stderr
        os.close(fd)
        return pa

    def pa_get_host_api_info_by_index(self, pa, index):
        fd = os.dup(2)
        os.close(2)              # Close stderr because pyaudio outputs a lot of disquieting messages
        info = pa.get_host_api_info_by_index(index)
        os.dup2(fd, 2)           # restore stderr
        os.close(fd)
        return info

    def pa_is_format_supported(self, pa, sample_rate, **kwargs):
        supported = False
        fd = os.dup(2)
        os.close(2)              # Close stderr because pyaudio outputs a lot of disquieting messages
        try: 
            supported = pa.is_format_supported(sample_rate, **kwargs)
        except:
            pass
        os.dup2(fd, 2)           # restore stderr
        os.close(fd)
        return supported

    def __init__(self):
        self.input_thread = None
        self.output_thread = None
        self.input_device_index = -1
        self.output_device_index = -1
        self.input_device_infos = {}
        self.output_device_infos = {}
        self.sub_on = True
        self.transmit_audio = False

        a_volume = Settings.get('Audio', 'main_volume')
        if a_volume == None:
            a_volume = '015'
        self.a_volume = float(a_volume) / 60.0

        b_volume = Settings.get('Audio', 'sub_volume')
        if b_volume == None:
            b_volume = '010'
        self.b_volume = float(b_volume) / 60.0

        mic_gain = Settings.get('Audio', 'mic_gain')
        if mic_gain == None:
            mic_gain = '040'
        self.mic_gain = float(mic_gain) / 80.0

        pa = self.pyaudio()
        info = self.pa_get_host_api_info_by_index(pa, 0)

        numdevices = info.get('deviceCount')

        try: 
            default_input_device_index = pa.get_default_input_device_info()['index']
        except:
            default_input_device_index = None
        try:
            default_output_device_index = pa.get_default_output_device_info()['index']
        except:
            default_output_device_index = None

        for i in range(0, numdevices):
            info = pa.get_device_info_by_host_api_device_index(0, i)
            if info['name'] in [ 'dmix', 'lavrate', 'samplerate', 'speexrate', 'pulse', 'speex', 'upmix', 'vdownmix' ]:
                continue
            default_sample_rate = info['defaultSampleRate']

            input_device_info = { 'default_sample_rate': int(default_sample_rate), 'input_channels': 0 }

            begin_rate = Audio.k4_sample_rate
            end_rate = Audio.max_input_sample_rate + begin_rate
            step = begin_rate
            for input_sample_rate in range(begin_rate, end_rate, step):
                if self.pa_is_format_supported(pa, input_sample_rate,
                               input_device=info['index'],
                               input_channels=Audio.input_channels,
                               input_format=pyaudio.paFloat32):
                    input_device_info['index'] = info['index']
                    input_device_info['name'] = info['name']
                    input_device_info['input_channels'] = info['maxInputChannels']
                    input_device_info['input_sample_rate'] = input_sample_rate
                    if info['index'] == default_input_device_index or default_input_device_index == None:
                        self.input_device_index = info['index']
                    break

            if 'index' in input_device_info:
                self.input_device_infos[input_device_info['index']] = input_device_info
            elif Options.debug > 0:
                if self.pa_is_format_supported(pa, default_sample_rate,
                             input_device=info['index'],
                             input_channels=Audio.input_channels,
                             input_format=pyaudio.paFloat32):
                    dprint('Info:', info['name'], 'does not support multiple of K4 sample rate. supported rate:', default_sample_rate)

            output_device_info = { 'default_sample_rate': int(default_sample_rate), 'output_channels': 0 }

            begin_rate = Audio.k4_sample_rate
            end_rate = Audio.max_output_sample_rate + begin_rate
            step = begin_rate
            for output_sample_rate in range(begin_rate, end_rate, step):
                if self.pa_is_format_supported(pa, output_sample_rate,
                                   output_device=info['index'],
                                   output_channels=Audio.output_channels,
                                   output_format=pyaudio.paFloat32):
                    output_device_info['index'] = info['index']
                    output_device_info['name'] = info['name']
                    output_device_info['output_channels'] = info['maxOutputChannels']
                    output_device_info['output_sample_rate'] = output_sample_rate
                    if info['index'] == default_output_device_index or default_output_device_index == None:
                        self.output_device_index = info['index']
                    break

            if 'index' in output_device_info:
                self.output_device_infos[output_device_info['index']] = output_device_info
            elif Options.debug > 0:
                if self.pa_is_format_supported(pa, default_sample_rate,
                             output_device=info['index'],
                             output_channels=Audio.output_channels,
                             output_format=pyaudio.paFloat32):
                    dprint('Info:', info['name'], 'does not support multiple of K4 sample rate. supported rate:', default_sample_rate)

    def input_device_info_by_name(self, name):
        for index in self.input_device_infos:
            dev_info = self.input_device_infos[index]
            if dev_info['name'] == name:
                return dev_info
        return None

    def output_device_info_by_name(self, name):
        for index in self.output_device_infos:
            dev_info = self.output_device_infos[index]
            if dev_info['name'] == name:
                return dev_info
        return None

    def start_output_thread(self, queue):
        if self.output_device_index < 0:
            return
        self.output_queue = queue
        self.output_thread = threading.Thread(target=self.output_loop, name='audio_output_thread')
        self.output_thread.start()

    def output_loop(self):
        output_stream = None
        current_index = None
        warned = False

        while True:
            packet = self.output_queue.get()
            if len(packet) == 0:
                return

            if current_index != self.output_device_index:
                current_index = self.output_device_index
                encode_mode = packet[0]
                if encode_mode != Audio.encode_mode_opus_float:
                    raise Exception('Unsupported audio encode mode:', encode_mode)

                frame_size = packet[2] << 8 | packet[1]

                sample_rate = packet[3]
                if sample_rate != 0:
                    raise Exception('Unsupported audio sample rate:', sample_rate)

                opus = opuslib.Decoder(Audio.k4_sample_rate, Audio.output_channels)

                pa = self.pyaudio()

                if output_stream != None:
                    output_stream.close()
                    output_stream = None

                resample_ratio = int(Audio.output_device_sample_rate() / Audio.k4_sample_rate)

                retries = 2
                for retry in range(retries+1):
                    try:
                        output_stream = pa.open(format=pyaudio.paFloat32,
                                                channels=Audio.output_channels,
                                                rate=Audio.output_device_sample_rate(),
                                                frames_per_buffer=frame_size,
                                                output=True,
                                                output_device_index=self.output_device_index,
                                                )
                        warned = False
                        break
                    except:
                        if retry >= retries:
                            if not warned:
                                Popup.warning('Failed to open: ' + self.output_device_name())
                                warned = True
                        continue

            pcm = opus.decode_float(bytes(packet[4:]), frame_size)

            stereo = numpy.frombuffer(pcm, dtype=numpy.float32)
            a = stereo[0::2]                    # even samples are from the main receiver
            b = stereo[1::2]                    # odd samples are from the sub receiver

            a = a * self.a_volume * 32          # apply some amplification
            b = b * self.b_volume * 32
                                                # Possible self.ab settings
                                                # a.b
                                                # ab.ab
                                                # a.-a
                                                # a.ab
                                                # ab.b
                                                # ab.a
                                                # b.ab
                                                # b.b
                                                # b.a
                                                # a.a

            if not self.sub_on:
                b = a                      # take all audio from main

            leftsel, rightsel = self.ab.split('.')

            if leftsel == 'a':
                left = a
            elif leftsel == 'b':
                left = b
            elif leftsel == 'ab':
                left = (a + b) / 2

            if rightsel == 'b':
                right = b
            elif rightsel == 'a':
                right = a
            elif rightsel == 'ab':
                right = (a + b) / 2
            elif rightsel == '-a':
                right = -a

            if resample_ratio > 1:
                left = left.repeat(resample_ratio)
                right = right.repeat(resample_ratio)

            stereo = numpy.empty((left.size + right.size,), dtype=numpy.float32)
            stereo[0::2] = left
            stereo[1::2] = right
            output_stream.write(stereo.tobytes())

    def on_transmit_changed(self, server, response):
        transmit = server.k4_parameters.get('TX', None) != None
        tune = server.k4_parameters.get('TU', "0") != '0'
        if transmit and not tune:
            split = server.k4_parameters.get('FT') == '1'
            if split:
                mode = server.k4_parameters.get('MD$')
            else:
                mode = server.k4_parameters.get('MD')

            if mode in ("1", "2", "4", "5"):        # LSB, USB, FM, AM
                if not self.transmit_audio:
                    self.transmit_audio = True
                    self.start_input_thread(server)
                return

        self.transmit_audio = False
        if self.input_thread != None:
            self.input_thread.join()
            self.input_thread = None

    def on_mx_changed(self, server, response):
        self.ab = response[2:].lower().rstrip(';')

    def start_input_thread(self, server):
        if self.input_device_index < 0:
            return
        self.input_thread = threading.Thread(target=lambda: self.input_loop(server), name='audio_input_thread')
        self.input_thread.start()

    def input_loop(self, server):
        input_stream = None
        current_index = None
        warned = False

        while True:
            if current_index != self.input_device_index:
                current_index = self.input_device_index

                opus = opuslib.Encoder(Audio.k4_sample_rate, Audio.k4_input_channels, 'audio')

                pa = self.pyaudio()

                if input_stream != None:
                    input_stream.close()
                    input_stream = None

                retries = 2
                for retry in range(retries+1):
                    try:
                        input_stream = pa.open(format=pyaudio.paFloat32,
                                                channels=Audio.input_channels,
                                                rate=Audio.input_device_sample_rate(),
                                                frames_per_buffer=Audio.input_frame_size,
                                                input=True,
                                                input_device_index=self.input_device_index,
                                                )
                        warned = False
                        break
                    except:
                        if retry >= retries:
                            if not warned:
                                Popup.warning('Failed to open: ' + self.input_device_name())
                                warned = True
                        continue

                tries = 10
                for i in range(tries):
                    sampled = input_stream.read(Audio.input_frame_size, exception_on_overflow=False)
                    sampled = numpy.frombuffer(sampled, dtype=numpy.float32)
                    average = sum(numpy.abs(sampled)) / len(sampled)
                    if average != 0.0:
                        break
                    if i == tries-1:
                        Popup.warning("No input from audio device:\n  {name}".format(name=Audio.input_device_name()))
                        return

                resample_ratio = int(Audio.input_device_sample_rate() / Audio.k4_sample_rate)

            sampled = input_stream.read(Audio.input_frame_size * resample_ratio, exception_on_overflow=False)
            sampled = numpy.frombuffer(sampled, dtype=numpy.float32)

            if resample_ratio == 1:
                resampled = sampled
            elif resample_ratio == 2:
                s0 = sampled[0::2]
                s1 = sampled[1::2]
                resampled = (s0 + s1) / 2

            elif resample_ratio == 3:
                s0 = sampled[0::3]
                s1 = sampled[1::3]
                s2 = sampled[2::3]
                resampled = sum((s0, s1, s2)) / 3

            elif resample_ratio == 4:
                s0 = sampled[0::4]
                s1 = sampled[1::4]
                s2 = sampled[2::4]
                s3 = sampled[3::4]
                resampled = sum((s0, s1, s2, s3)) / 4

            resampled = resampled * self.mic_gain / 8  # apply some attenuation

            resampled = resampled.repeat(2)             # double-up samples. I consider this a K4 bug
            resampled_bytes = resampled.tobytes()

            frame_size = Audio.input_frame_size
            audio_packet = opus.encode_float(resampled_bytes, frame_size)

            if not self.transmit_audio:
                if input_stream != None:
                    input_stream.close()
                    input_stream = None
                return

            server.send_audio_packet(audio_packet, self.input_encode_mode, frame_size)

class Settings():
    settings_filename = 'settings.ini'
    settings = configparser.ConfigParser()
    settings.optionxform = str
    settings_loaded = False
    settings_changed = False

    @classmethod
    def put(cls, category, setting, value):
        if not cls.settings_loaded:
            cls.load()
        value = str(value)
        if not category in cls.settings:
            cls.settings[category] = {}
        previous_value = cls.settings[category].get(setting, None)
        if value != previous_value:
            cls.settings[category][setting] = value
            cls.settings_changed = True

    @classmethod
    def put_save(cls, category, setting, value):
        cls.put(category, setting, value)
        cls.save()

    @classmethod
    def get(cls, category, setting):
        if not cls.settings_loaded:
            cls.load()
        if category not in cls.settings:
            return None
        if setting not in cls.settings[category]:
            return None
        return cls.settings[category][setting]

    @classmethod
    def clear_category(cls, category):
        cls.settings[category] = {}

    @classmethod
    def get_category(cls, category):
        if not cls.settings_loaded:
            cls.load()
        settings = {}
        try:
            for k, v in cls.settings[category].items():
                settings[k] = v
        except:
            pass
        return settings

    @classmethod
    def platform_settings_filename(cls, filename):
        if sys.platform == 'darwin':
            from AppKit import NSSearchPathForDirectoriesInDomains
            # http://developer.apple.com/DOCUMENTATION/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSSearchPathForDirectoriesInDomains
            # NSApplicationSupportDirectory = 14
            # NSUserDomainMask = 1
            # True for expanding the tilde into a fully qualified path
            config_dir = os.path.join(NSSearchPathForDirectoriesInDomains(14, 1, True)[0], appname)
        elif sys.platform == 'win32':
            config_dir = os.path.join(os.environ['APPDATA'], appname)
        elif sys.platform == 'linux':
            home_dir = os.path.expanduser('~')
            config_dir = os.path.join(home_dir, '.config')
            if os.path.isdir(config_dir):
                config_dir = os.path.join(config_dir, appname)
            else:
                config_dir = os.path.join(home_dir, '.' + appname)
        else:
            dprint(f'{sys.platform} not supported.')

        if not os.path.isdir(config_dir):
            os.mkdir(config_dir, 0o755)
        filename = os.path.join(config_dir, filename)

        return filename

    @classmethod
    def save(cls):
        if not cls.settings_changed:
            return

        filename = cls.platform_settings_filename(cls.settings_filename)
        with open(filename, 'w') as settingsfile:
            cls.settings.write(settingsfile)
        cls.settings_changed = False

    @classmethod
    def load(cls):
        filename = cls.platform_settings_filename(cls.settings_filename)
        cls.settings.read(filename)
        cls.settings_loaded = True

class Settings_widget(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = [ 'label', 'leading', 'bg', 'fg', 'abg', 'afg', 'selectbg', 'selectfg', 'font', 'label_font' ]
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        input_device_name = Settings.get('Audio', 'input_device_name')
        if input_device_name != None:
            Audio.set_input_device_name(input_device_name)

        output_device_name = Settings.get('Audio', 'output_device_name')
        if output_device_name != None:
            Audio.set_output_device_name(output_device_name)

        self.selectbg = config_info.get('selectbg', self.bg)
        self.selectfg = config_info.get('selectfg', self.fg)

        self.frame = tk.LabelFrame(self.frame,
                              text='Settings',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')
        self.frame.grid(row=0, column=0)

        remote_frame = self.remote_settings()
        remote_frame.grid(row=0, column=0, sticky='w')
        audio_frame = self.audio_settings()
        audio_frame.grid(row=1, column=0, sticky='w', pady=8)

    def remote_settings(self):
        frame = tk.LabelFrame(self.frame,
                              text='K4 Remote',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')

        address_frame = self.k4_address_settings(frame)
        address_frame.grid(row=0, column=0, sticky='w', pady=2)

        password_frame = self.k4_password_settings(frame)
        password_frame.grid(row=1, column=0, sticky='w', pady=2)

        proxy_frame = self.k4_proxy_settings(frame)
        proxy_frame.grid(row=2, column=0, sticky='w', pady=2)

        return frame

    def k4_address_settings(self, remote_frame):
        frame = tk.LabelFrame(remote_frame,
                              text='Address',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')

        self.k4_address_var = tk.StringVar()
        k4_address = Settings.get('Elecraft K4', 'address')
        if k4_address == None:
            k4_address = ''

        self.k4_address_var.set(k4_address)
        self.set_k4_server_address()

        entry = tk.Entry(frame,
            textvariable=self.k4_address_var,
            bd=2,
            font=self.font(),
            justify='left',
            fg=self.fg,
            bg=self.bg)
        entry.grid(row=0, column=0)
        entry.bind('<Return>', self.set_k4_server_address)
        entry.bind('<FocusOut>', self.set_k4_server_address)

        return frame

    def set_k4_server_address(self, event=None):
        address = self.k4_address_var.get()
        Settings.put_save('Elecraft K4', 'address', address)
        self.server.set_address(address)

    def k4_password_settings(self, remote_frame):
        frame = tk.LabelFrame(remote_frame,
                              text='Password',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')

        self.password_var = tk.StringVar()
        h = Settings.get('Elecraft K4', 'insecure_password_hash')
        if h == None:
            pw = ''
        else:
            pw = Reversable_hash.unhash(h)
        if pw != '':
            self.server.set_password(pw)

        self.password_var.set(pw)
        entry = tk.Entry(frame,
            textvariable=self.password_var,
            bd=2,
            font=self.font(),
            show='*',
            justify='left',
            fg=self.fg,
            bg=self.bg)
        entry.grid(row=0, column=0)
        entry.bind('<Return>', self.set_k4_password)
        entry.bind('<FocusOut>', self.set_k4_password)

        return frame

    def set_k4_password(self, event=None):
        pw = self.password_var.get()
        h = Reversable_hash.hash(pw)
        Settings.put_save('Elecraft K4', 'insecure_password_hash', h)
        self.server.set_password(pw)

    def k4_proxy_settings(self, remote_frame):
        frame = tk.LabelFrame(remote_frame,
                              text='SOCKS5 Address:Port',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')

        self.k4_proxy_var = tk.StringVar()
        k4_proxy = Settings.get('Elecraft K4', 'proxy_address')
        if k4_proxy == None:
            k4_proxy = ''

        self.k4_proxy_var.set(k4_proxy)
        self.set_k4_server_proxy()

        entry = tk.Entry(frame,
            textvariable=self.k4_proxy_var,
            bd=2,
            font=self.font(),
            justify='left',
            fg=self.fg,
            bg=self.bg)
        entry.grid(row=0, column=0)
        entry.bind('<Return>', self.set_k4_server_proxy)
        entry.bind('<FocusOut>', self.set_k4_server_proxy)

        return frame

    def set_k4_server_proxy(self, event=None):
        proxy = self.k4_proxy_var.get()
        Settings.put_save('Elecraft K4', 'proxy_address', proxy)
        self.server.set_proxy(proxy)

    def audio_settings(self):
        frame = tk.LabelFrame(self.frame,
                              text='Audio Settings',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=4,
                              padx=4,
                              pady=4,
                              relief='raised')

        audio_input_frame = self.audio_input_settings(frame)
        audio_input_frame.grid(row=0, column=0, sticky='w')
        audio_output_frame = self.audio_output_settings(frame)
        audio_output_frame.grid(row=1, column=0, sticky='w', pady=4)
        audio_k4_control_frame = self.audio_k4_control_setting(frame)
        audio_k4_control_frame.grid(row=2, column=0, sticky='w')

        return frame

    def audio_input_settings(self, frame):
        input_device_name = Settings.get('Audio', 'input_device_name')
        if input_device_name == None or Audio.input_device_index() < 0:
            input_device_name = Audio.input_device_name()

        input_frame = tk.LabelFrame(frame,
                                    text='Current Input Device',
                                    font=self.label_font(),
                                    labelanchor='nw',
                                    bd=4,
                                    padx=4,
                                    pady=4,
                                    relief='raised')

        # Define the style for this combobox widget
        stylename = str(self) + 'input.TCombobox'
        style = ttk.Style()
        style.configure(stylename, background=self.bg, foreground=self.fg, selectbackground=self.selectbg, selectforeground=self.selectfg)

        input_names = Audio.input_device_names()
        width = 0
        for name in input_names + [input_device_name]:
            if len(name) > width:
                width = len(name)

        self.input_val = tk.StringVar()
        self.input_val.set(input_device_name)

        input_combobox = ttk.Combobox(
                input_frame,
                textvar=self.input_val,
                font=self.font(),
                values=input_names,
                height=len(input_names),
                width=width,
                state='readonly',
                justify='left',
                style=stylename,
                )
        input_combobox.grid(row=1, column=0, sticky='w')

        self.input_val.trace('w', self.on_input_combobox_changed)

        return input_frame

    def on_input_combobox_changed(self, var, index, mode):
        input_name = self.input_val.get()
        if input_name == '':
            return

        Settings.put_save('Audio', 'input_device_name', input_name)
        Audio.set_input_device_name(input_name)

    def audio_output_settings(self, frame):
        output_device_name = Settings.get('Audio', 'output_device_name')
        if output_device_name == None or Audio.output_device_index() < 0:
            output_device_name = Audio.output_device_name()

        output_frame = tk.LabelFrame(frame,
                                     text='Current Output Device',
                                     font=self.label_font(),
                                     labelanchor='nw',
                                     bd=4,
                                     padx=4,
                                     pady=4,
                                     relief='raised')

        # Define the style for this combobox widget
        stylename = str(self) + 'output.TCombobox'
        style = ttk.Style()
        style.configure(stylename, background=self.bg, foreground=self.fg, selectbackground=self.selectbg, selectforeground=self.selectfg)

        output_names = Audio.output_device_names()
        width = 0
        for name in output_names + [output_device_name]:
            if len(name) > width:
                width = len(name)

        self.output_val = tk.StringVar()
        self.output_val.set(output_device_name)

        output_combobox = ttk.Combobox(
                output_frame,
                textvar=self.output_val,
                font=self.font(),
                values=output_names,
                height=len(output_names),
                width=width,
                state='readonly',
                justify='left',
                style=stylename,
                )
        output_combobox.grid(row=0, column=0, sticky='w')

        self.output_val.trace('w', self.on_output_combobox_changed)

        return output_frame

    def on_output_combobox_changed(self, var, index, mode):
        output_name = self.output_val.get()
        if output_name == '':
            return

        Settings.put_save('Audio', 'output_device_name', output_name)
        Audio.set_output_device_name(output_name)

    def audio_k4_control_setting(self, frame):
        setting = true_values(Settings.get('Audio', 'control_k4_audio_settings'))
        if setting == None:
            setting = self.cat_only
        self.server.set_control_k4_audio(setting)

        control_frame = tk.LabelFrame(frame,
                                     text='Control K4 Audio Settings?',
                                     font=self.label_font(),
                                     labelanchor='nw',
                                     bd=4,
                                     padx=4,
                                     pady=4,
                                     relief='raised')

        # Define the style for this combobox widget
        stylename = str(self) + 'output.TCombobox'
        style = ttk.Style()
        style.configure(stylename, background=self.bg, foreground=self.fg, selectbackground=self.selectbg, selectforeground=self.selectfg)

        values = ('Yes', 'No')
        width = 3
        current_value = 'Yes' if setting else 'No'

        self.k4_control_audio_val = tk.StringVar()
        self.k4_control_audio_val.set(current_value)

        control_combobox = ttk.Combobox(
                control_frame,
                textvar=self.k4_control_audio_val,
                font=self.font(),
                values=values,
                height=len(values),
                width=width,
                state='readonly',
                justify='left',
                style=stylename,
                )
        control_combobox.grid(row=0, column=0, sticky='w')

        self.k4_control_audio_val.trace('w', self.on_k4_control_audio_combobox_changed)

        return control_frame

    def on_k4_control_audio_combobox_changed(self, var, index, mode):
        current_value = self.k4_control_audio_val.get()
        if current_value == '':
            return

        setting = current_value == 'Yes'

        Settings.put_save('Audio', 'control_k4_audio_settings', setting)
        self.server.set_control_k4_audio(setting)

class FWversions(Text):
    def __init__(self, config_info, container):

        config_info['justify'] = 'left'
        super().__init__(config_info, container)

        self.width = 0
        self.height = 1
        self.text = ''

        self.server.subscribe_response('RV;', self.on_received_versions)

    def on_received_versions(self, response):
        version = response.rstrip(';').lstrip('RV.')
        if len(version) > self.width:
            self.width = len(version)
        self.height += 1
        self.text += version + "\n"
        self.label.configure(text=self.text, height=self.height, width=self.width)

class Entry_Widget():
    def __init__(self, parent_frame, width=20, bd=2, justify='left', show='', font=Default.label_font, fg=Default.fg, bg=Default.bg):
        self.var = tk.StringVar()
        self.entry = tk.Entry(parent_frame, textvariable=self.var, width=width, bd=bd, justify=justify, show=show, font=font, fg=fg, bg=bg)

    def value(self, value=None):
        if value != None:
            self.var.set(value)
            self.entry.width = len(value)
        return self.var.get()

    def callback(self, callback):
        self.entry.bind('<Return>', callback)
        self.entry.bind('<FocusOut>', callback)

    def grid(self, **opts):
        self.entry.grid(**opts)

    def config(self, **opts):
        self.entry.config(*opts)

class Entry(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['width', 'show', 'bd', 'bg', 'fg', 'font', 'justify', 'label', 'leading']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        width = config_info.get('width', 20)
        show = config_info.get('show', '')
        bd = config_info.get('bd', 2)
        font = config_info.get('font', Default.label_font)
        justify = config_info.get('justify', 'left')

        self.entry = Entry_Widget(self.frame, show=show, width=width, bd=bd, bg=self.bg, fg=self.fg, font=self.font(), justify=justify)

class Startup_cmds(Entry):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['width', 'show', 'bd', 'bg', 'fg', 'font', 'justify', 'label', 'leading']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        self.settings_key = config_info['item']
        self.entry.callback(self.get_cmds)
        self.entry.grid(row=0, column=0, sticky='w')

        self.load_settings()

    def get_cmds(self, response):
        self.cmds = self.entry.value()
        if self.cmds != '' and not self.cmds.endswith(';'):
            self.cmds += ';'

        self.save_settings()
        self.got_cmds()

    def got_cmds(self):
        self.server.startup_cmds = self.cmds

    def load_settings(self):
        self.cmds = Settings.get('Elecraft K4', self.settings_key)
        if self.cmds == None:
            self.cmds = 'TS1;'
        self.entry.value(self.cmds)
        self.got_cmds()

    def save_settings(self):
        Settings.put_save('Elecraft K4', self.settings_key, self.cmds)

class Exit_cmds(Startup_cmds):
    def __init__(self, config_info, container):
        super().__init__(config_info, container)
        self.entry.grid(row=1, column=0, sticky='w')

    def got_cmds(self):
        self.server.exit_cmds = self.cmds

class Dropdown_Widget():
    def __init__(self, parent_frame, height=10, bd=2, padx=0, justify='left', font=Default.label_font,
                 fg=Default.fg, bg=Default.bg, abg=Default.abg, afg=Default.afg, selectbg=None, selectfg=None):
        if afg == None:
            afg = fg
        if selectbg == None:
            selectbg = bg
        if selectfg == None:
            selectfg = fg

        # Define the style for this dropdown widget
        self.stylename = str(self) + '.TCombobox'
        self.style = ttk.Style()
        self.style.configure(self.stylename, background=bg, foreground=fg, selectbackground=selectbg, selectforeground=selectfg)
        self.style.configure(self.stylename, margins=(20, 0, 20, 0))

        self.combobox = ttk.Combobox(
                parent_frame,
                font=font,
                height = height,
                state='readonly',
                justify=justify,
                style=self.stylename,
                )

    def value(self, value=None):
        if value != None:
            self.combobox.set(value)
        return self.combobox.get()

    def index(self, index=None):
        if index != None:
            self.combobox.current(index)
        return self.combobox.current()

    def values(self, values=None):
        if values != None:
            self.config(values=values)
        return self.combobox.cget('values')

    def callback(self, callback):
        self.combobox.bind('<<ComboboxSelected>>', callback)

    def grid(self, **opts):
        self.combobox.grid(**opts)

    def config(self, **opts):
        self.combobox.config(**opts)
        if 'values' in opts:
            width = 0
            for value in self.values():
                if len(value) > width:
                    width = len(value)
            self.combobox.config(width=int(width+2))

    def cget(self, **opts):
        return self.combobox.cget(*opts)

class Antenna(Widget):
    def __init__(self, config_info, container):
        self.ar_names = ('None', 'RX2', '=TX ANT', 'x', 'RX1', 'ANT1', 'ANT2', 'ANT3')
        self.rx_names = ('None', 'ANT1', 'ANT2', 'ANT3', 'RX1', 'RX2', '=TX ANT')
        self.tx_names = ('x', 'ANT1', 'ANT2', 'ANT3')
        self.rx_select_bases = {'main':'AR', 'sub':'AR$'}

        required = ['item', 'type']
        options = ['bd', 'bg', 'fg', 'selectbg', 'selectfg', 'justify', 'height', 'font', 'label', 'leading', 'padx']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        bd = config_info.get('bd', 2)
        selectbg = config_info.get('selectbg', self.bg)
        selectfg = config_info.get('selectfg', self.fg)
        justify = config_info.get('justify', 'left')
        height = config_info.get('height', 10)
        padx = config_info.get('padx', 0)
        self.kind = config_info['type']

        if self.kind in ('main', 'sub', 'tx'):
            self.dropdown = Dropdown_Widget(self.frame, bd=bd, padx=padx, bg=self.bg, fg=self.fg, abg=self.abg,
                                            selectbg=selectbg, selectfg=selectfg,
                                            font=self.font(), justify=justify, height=height)
            self.dropdown.grid(row=0, column=0)
        else:
            raise Exception(f'unknown type: {self.kind} in item antenna.')

        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        self.server.subscribe_responses('ACN1;ACN2;ACN3;ACN4;ACN5;', self.on_received_name)
        self.dropdown.callback(self.on_select)
        self.server.subscribe_response('AN;', self.on_k4_select_tx)

        if self.kind == 'tx':
            self.set_values_tx()
            self.server.subscribe_response('ACT;', self.on_k4_config_tx)
        elif self.kind == 'main':
            self.set_values_rx()
            self.server.subscribe_response('AR;', self.on_k4_select_rx)
            self.server.subscribe_response('ACM;', self.on_k4_config_rx)
        elif self.kind == 'sub':
            self.set_values_rx()
            self.server.subscribe_response('AR$;', self.on_k4_select_rx)
            self.server.subscribe_response('ACS;', self.on_k4_config_rx)

    def on_select(self, event):
        value = self.dropdown.value()
        if self.kind == 'tx':
            index = self.tx_short_names.index(value)
            cmd = f'AN{index};'
        else:
            index = self.rx_short_names.index(value)
            name = self.rx_names[index]
            ar_index = self.ar_names.index(name)
            cmd = f'{self.rx_select_bases[self.kind]}{ar_index};'
        self.server.send_cmds(cmd)

    def on_k4_select_rx(self, response):
        base = self.rx_select_bases[self.kind]
        ar_index = int(self.k4param(base))
        name = self.ar_names[ar_index]
        index = self.rx_names.index(name)
        value = self.rx_short_names[index]
        tx_index = int(self.k4param('AN'))

        if index == tx_index or value == '=TX ANT':
            value = self.tx_short_names[tx_index]

        self.dropdown.value(value)

    def on_k4_select_tx(self, response):
        if self.kind == 'tx':
            tx_index = int(self.k4param('AN'))
            value = self.tx_short_names[tx_index]
            self.dropdown.value(value)
        else:
            self.set_names()

    def on_k4_config_rx(self, response):
        self.set_values_rx()

    def on_k4_config_tx(self, response):
        self.set_values_tx()

    def set_names(self):
        self.tx_short_names = list(self.tx_names)
        for i in range(1, 4):
            name = self.k4param(f'ACN{i}')
            if name != '' and name != self.tx_names[i]:
                self.tx_short_names[i] = f'{i}:{name}'
            else:
                self.tx_short_names[i] = f'{self.rx_names[i]}'

        tx_index = int(self.k4param('AN'))
        self.rx_short_names = list(self.rx_names)

        for i in range(1, 6):
            tx = ' (TX)' if i == tx_index else ''
            name = self.k4param(f'ACN{i}')
            if name != '' and name != self.rx_names[i]:
                self.rx_short_names[i] = f'{i}:{name}{tx}'
            else:
                self.rx_short_names[i] = f'{i}:{self.rx_names[i]}{tx}'

        if self.kind == 'tx':
            self.set_values_tx()
        else:
            self.set_values_rx()

    def on_received_name(self, response):
        self.set_names()

    def set_values_rx(self):
        has_ATU = 'A' in self.k4param('OM')
        tx_ant = int(self.k4param('AN'))

        values = list(self.rx_short_names)
        if self.kind == 'main':
            mask = self.k4param('ACM')
        else:
            mask = self.k4param('ACS')
        if mask[0] == '0':
            for i in range(6, 0, -1):
                if not has_ATU and (i == 2 or i == 3) or mask[i] == '0':
                    values.pop(i)

        self.dropdown.values(values)

    def set_values_tx(self):
        has_ATU = 'A' in self.k4param('OM')
        if has_ATU:
            values = self.tx_short_names[1:]
            mask = self.k4param('ACT')
            if mask[0] == '0':
                for i in range(3, 0, -1):
                    if mask[i] == '0':
                        values.pop(i-1)
        else:
            values = self.tx_short_names[1:2]

        self.dropdown.values(values)

class CWText(tk.Text):
    def __init__(self, container, **kwargs):
        super().__init__(container, **kwargs)
        self.tag_config('space', wrap='char')

    def append(self, value):
        space_indexes = []
        for i, c in enumerate(value):
            if c == ' ':
                space_indexes.append(i)
        self.mark_set('old_end', tk.END)
        self.mark_gravity('old_end', tk.LEFT)
        previous_state = self.cget('state')
        self.config(state='normal')
        self.insert(tk.END, value)
        self.see('1.0')
        self.config(state=previous_state)
        for i in space_indexes:
            index = f'old_end+{i}c'
            self.tag_add('space', index)

    def scroll_up(self):
        width = self.cget('width')
        ax, ay, aw, ah, au = self.dlineinfo('1.0')
        high = width + 1
        low = 0
        while low <= high:
            mid = (high + low) // 2
            bx, by, bw, bh = self.bbox(f'1.{mid}')
            if by > ay:    # line-wrapped
                high = mid - 1
            else:
                low = mid + 1
        if by <= ay:
            mid += 1
        self.config(state='normal')
        self.delete('1.0', f'1.{mid}')
        self.config(state='disabled')
        return mid

    def text(self, delete=False):
        text = self.get('1.0', tk.END+'-1c')
        if delete:
            self.delete('1.0', tk.END)
        return text

class CW(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        options = ['bd', 'bg', 'fg', 'type_height', 'tx_height', 'rx_height', 'width', 'columns',
                   'font', 'label', 'leading', 'rows', 'columns', 'button_width']
        validate_config_options(config_info, required, options)

        super().__init__(config_info, container)

        bd = config_info.get('bd', 2)
        self.type_height = config_info.get('type_height', 3)
        if self.type_height < 1:
            self.type_height = 1
        self.tx_height = config_info.get('tx_height', 3)
        if self.tx_height < 1:
            self.tx_height = 1
        self.rx_height = config_info.get('rx_height', 2)
        if self.rx_height < 1:
            self.rx_height = 1
        self.width = config_info.get('width', 60)
        self.button_width = config_info.get('button_width', 30)
        self.rows = config_info.get('rows', 4)
        self.columns = config_info.get('columns', 2)
        font = self.font()
        self.monospaced_font = ('DejaVu Sans Mono', font['size'])

        self.tx_poll_interval = 10 # 10 mS
        self.tx_line_len = self.width
        self.tx_send_offset = 0
        self.tx_remaining_count = 0
        self.sending = False

        self.load_settings()

        top_frame = tk.Frame(self.frame)
        top_frame.grid(row=0, column=0)
        self.edit_button = tk.Button(top_frame, bd='2', text='Edit Buttons', font=self.font(), width=15,
             justify='center', relief='raised', fg=self.fg, bg=self.bg, padx=2, pady=2, command=self.on_edit_button)
        self.edit_button.grid(row=0, column=0, columnspan=self.columns, sticky='n')

        self.main_enabled = False
        self.sub_enabled = False

        self.buttons_frame = tk.Frame(self.frame)
        self.buttons_frame.grid(row=1, column=0, sticky='w')

        self.buttons = []
        self.button_properties = []

        row = 1
        column = 0
        for i, value in enumerate(self.button_values):
            if row >= self.rows:
                break
            button = tk.Text(self.buttons_frame, bd=2, padx=1, pady=0, bg=self.bg, fg=self.fg,
                             font=self.monospaced_font, height=1, width=self.button_width,
                             cursor='hand2', relief='raised', wrap='none')
            button.grid(row=row, column=column, sticky='w', padx=2, pady=2)
            self.buttons.append(button)
            self.button_properties.append({'editing': False})
            self.load_button_value(i)
            button.bind('<Return>', lambda event, i=i: self.store_button_value(i))
            button.bind('<FocusOut>', lambda event, i=i: self.store_button_value(i))
            button.bind('<Button-1>', lambda event, i=i: self.on_button1_click(i))
            button.bind('<Button-3>', lambda event, i=i: self.on_button3_click(i))
            column += 1
            if column >= self.columns:
                row += 1
                column = 0

        type_frame = tk.LabelFrame(self.frame, text='Typing buffer (Hit enter to send.)',
            font=self.label_font(), labelanchor='nw', bd=2, padx=1, pady=1, relief='raised')
        type_frame.grid(row=2, column=0, sticky='w', pady=5)
        self.type_text = CWText(type_frame, bd=bd, bg=self.bg, fg=self.fg,
            font=self.monospaced_font, height=self.type_height, width=self.width, wrap='word')
        self.type_text.grid(row=0, column=0, sticky='w')
        self.type_text.bind('<Return>', self.on_type_text_modified)

        tx_frame = tk.LabelFrame(self.frame, text='Tx', font=self.label_font(),
             labelanchor='nw', bd=2, padx=1, pady=1, relief='raised')
        tx_frame.grid(row=3, column=0, sticky='w', pady=5)
        self.tx_text = CWText(tx_frame, bd=bd, bg=self.bg, fg=self.fg, font=self.monospaced_font,
            height=self.tx_height, width=self.width, wrap='word', state='disabled')
        self.tx_text.grid(row=0, column=0, sticky='w')
        self.tx_text.tag_config('underline', underline=1)

        self.main_frame = tk.LabelFrame(self.frame, text='Main Rx', font=self.label_font(),
            labelanchor='nw', bd=2, padx=1, pady=1, relief='raised')
        self.main_text = CWText(self.main_frame, bd=bd, bg=self.bg, fg=self.fg, font=self.monospaced_font,
            height=self.rx_height, width=self.width, wrap=None, state='disabled')
        self.main_text.grid(row=0, column=0, sticky='w', pady=1)
        self.sub_frame = tk.LabelFrame(self.frame, text='Sub Rx', font=self.label_font(),
            labelanchor='nw', bd=2, padx=1, pady=2, relief='raised')
        self.sub_text = CWText(self.sub_frame, bd=bd, bg=self.bg, fg=self.fg, font=self.monospaced_font,
            height=self.rx_height, width=self.width, wrap=None, state='disabled')
        self.sub_text.grid(row=0, column=0, sticky='w')

        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        self.server.subscribe_response('TD;', self.on_main_text_decode)
        self.server.subscribe_response('TD$;', self.on_sub_text_decode)
        self.server.subscribe_response('TB;', self.on_main_text_buffer)
        self.server.subscribe_response('TB$;', self.on_sub_text_buffer)
        self.server.subscribe_response('ACN1;', self.on_transmit_ack)

    def load_button_value(self, index, edit=False):
        value = self.button_values[index]
        label = self.button_labels[index]
        if label != '':
            value = f'{label}|{value}' if edit else label
        button = self.buttons[index]
        button.config(state='normal')
        button.delete('1.0', tk.END)
        button.insert('1.0', value)
        button.see('1.0')
        if edit:
            button.config(bg='Yellow', state='normal', cursor='')
            self.button_properties[index]['editing'] = True
        else:
            button.config(bg=self.bg, state='disabled', cursor='hand2')
            self.button_properties[index]['editing'] = False

    def store_button_value(self, index):
        if not self.button_properties[index]['editing']:
            return
        button = self.buttons[index]
        value = button.get('1.0', tk.END).strip()
        fields = value.split('|', 1)
        if len(fields) == 2:
            label, value = fields
        else:
            label = ''
        self.button_values[index] = value
        self.button_labels[index] = label
        if label != '':
            value = label
        button.config(state='normal')
        button.delete('1.0', tk.END)
        button.insert('1.0', value)
        button.see('1.0')
        button.config(bg=self.bg, state='disabled', cursor='hand2')
        self.button_properties[index]['editing'] = False
        self.save_settings()

        return 'break'

    def on_button1_click(self, index):
        if self.button_properties[index]['editing']:
            return
        value = self.button_values[index]
        if value == '':
            self.on_button3_click(index)
            return
        value += ' '
        self.tx_text.append(value)
        self.send_cw()

    def on_button3_click(self, index):
        self.load_button_value(index, edit=True)
        self.buttons[index].focus()

    def send_cw(self):
        if self.tx_remaining_count > 5:
            Poll.call(self.tx_poll_interval, self.send_cw)
            return

        index = f'1.{self.tx_send_offset}'
        end_index = f'1.{self.tx_send_offset+4}'
        chunk = self.tx_text.get(index, end_index)
        chunk_len = len(chunk)
        if chunk_len > 0:
            self.tx_send_offset += chunk_len

            if self.tx_remaining_count == 0:
                chunk_len -= 1
            self.tx_remaining_count += chunk_len
            self.server.send_cmds(f'KY {chunk};ACN1;')
            self.sending = True
            Poll.call(self.tx_poll_interval, self.send_cw)

    def on_main_text_decode(self, response):
        if self.k4param('TD')[0] == '0':
            self.main_frame.grid_forget()
            self.main_enabled = False
            if self.sub_enabled:
                self.sub_frame.grid(row=4, column=0, sticky='w', pady=5)
            return

        self.main_frame.grid(row=4, column=0, sticky='w', pady=10)
        self.main_enabled = True
        if self.sub_enabled:
            self.sub_frame.grid(row=5, column=0, sticky='w', pady=5)

    def on_sub_text_decode(self, response):
        if self.k4param('TD$')[0] == '0':
            self.sub_frame.grid_forget()
            self.sub_enabled = False
            return

        self.sub_enabled = True
        row=4
        if self.main_enabled:
            row += 1
        self.sub_frame.grid(row=row, column=0, sticky='w', pady=5)

    def update_sending_offset(self):
        text = self.tx_text
        sending_offset = self.tx_send_offset - self.tx_remaining_count-1
        index = f'1.{sending_offset}'
        text.update_idletasks()
        if text.bbox(index) == None:            # is character not visible? 
            deleted_count = text.scroll_up()
            self.tx_send_offset -= deleted_count
            sending_offset -= deleted_count
            index = f'1.{sending_offset}'

        self.tx_text.tag_remove('underline', '1.0', tk.END)
        self.tx_text.tag_add('underline', index)

    def on_transmit_ack(self, response):
        self.sending = False

    def on_text_buffer(self, response, widget):
        param = response_after_base(response).rstrip(';')
        if not self.sending:
            r = int(param[0])
            self.tx_remaining_count = r
            self.update_sending_offset()
        new_text = param[3:]
        if new_text == '':
            return

        widget.append(new_text)
        widget.update_idletasks()
        if widget.bbox('end-1c') == None:            # is last line invisible? 
            widget.scroll_up()

    def on_main_text_buffer(self, response):
        self.on_text_buffer(response, self.main_text)

    def on_sub_text_buffer(self, response):
        self.on_text_buffer(response, self.sub_text)

    def on_edit_button(self):
        if self.edit_button.cget('text').startswith('Edit'):
            for i, button in enumerate(self.buttons):
                self.load_button_value(i, edit=True)
            self.edit_button.config(text='Enable Buttons')
        else:
            for i, button in enumerate(self.buttons):
                self.store_button_value(i)
            self.edit_button.config(text='Edit Buttons')

    def on_type_text_modified(self, event):
        text = self.type_text.text(delete=True)
        self.tx_text.append(text + ' ')
        self.send_cw()
        return 'break'

    def load_settings(self):
        category = 'CW'
        self.button_values = []
        self.button_labels = []
        buttons = Settings.get(category, 'buttons')
        if buttons != None:
            values = buttons.split('\n')
            for value in values:
                value = value.strip()
                fields = value.split('|', 1)
                if len(fields) == 2:
                    label, value = fields
                else:
                    label = ''
                self.button_values.append(value)
                self.button_labels.append(label)
        total_buttons = self.rows * self.columns
        while len(self.button_values) < total_buttons:
            self.button_values.append('')
            self.button_labels.append('')

    def save_settings(self):
        category = 'CW'
        previous_settings = Settings.get_category(category)
        Settings.clear_category(category)

        values = []
        for i, value in enumerate(self.button_values):
            label = self.button_labels[i]
            if label != '':
                value = f'{label}|{value}'
            values.append(value)
        while values[len(values)-1] == '':
            values.pop()
        buttons = '\n '.join(values)
        Settings.put(category, 'buttons', buttons)

        settings = Settings.get_category(category)
        if settings != previous_settings:
            Settings.save()

# A simple reversable string hash function
# Not in any way cryptographically secure
class Reversable_hash():
    @classmethod
    def rhash(cls, n):
        return "%08x" % (n * 387420489 % 4000000000)

    @classmethod
    def un_rhash(cls, h):
        return int(h, 16) * 3513180409 % 4000000000

    @classmethod
    def hash(cls, s):
        hashes = []
        for c in s:
            hashes.append(cls.rhash(ord(c)))
        return ''.join(hashes)

    @classmethod
    def unhash(cls, s):
        i = 0
        chars = []
        for i in range(0, len(s), 8):
            h = s[i:i+8]
            chars.append(chr(cls.un_rhash(h)))
        return ''.join(chars)

class Config():
    main_block_name = ' main'

    @staticmethod
    def preprocess(filename):
        self = Config()
        return self.process(filename)

    def process(self, filename):
        self.filename = filename
        self.blocks = {}
        self.errors = 0

        block_stack = []
        current_block = { 'name':Config.main_block_name, 'lines':[] }
        self.blocks[Config.main_block_name] = current_block
        in_block = False
        line_count = 0
        with open(filename) as stream:
            while True:
                line = stream.readline()
                if line == '':
                    break
                line_count += 1
                match = re.search("^([ \t]*)#(define|end|include)([ \t]+([_A-Za-z][-_A-Za-z0-9]*)([ \t]*)(.*)$)?", line)
                if not match:
                    current_block['lines'].append(line)
                else:
                    indent = match.group(1)
                    directive = match.group(2)
                    after_directive = match.group(3)
                    block_name = match.group(4)
                    trailing = match.group(6)
                    if directive == 'define':
                        if indent != '':
                            dprint('Error ({filename}:{line_count}): #define must be in column 1'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif block_name == None:
                            dprint('Error ({filename}:{line_count}): Invalid block name after #define'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif trailing != '':
                            dprint('Error ({filename}:{line_count}): unexpected characters after #define {name}'.format(filename=filename, line_count=line_count, name=block_name))
                            self.errors += 1
                            continue
                        elif in_block:
                            pname = current_block['name']
                            dprint('Error ({filename}:{line_count}): #define {name}, encountered while defining {pname}'.format(filename=filename, line_count=line_count, name=block_name, pname=pname))
                            self.errors += 1
                            continue
                        elif block_name in self.blocks:
                            dprint('Error ({filename}:{line_count}): #define {name}, redefined. Previously defined at line {pline_count}'.format(filename=filename, line_count=line_count, name=block_name, pline_count=self.blocks[block_name]['line_count']))
                            self.errors += 1
                            continue

                        block_stack.append(current_block)
                        current_block = { 'name':block_name, 'lines':[], 'line_count':line_count }
                        self.blocks[block_name] = current_block
                        in_block = True
                    elif directive == 'end':
                        if not in_block:
                            dprint('Error ({filename}:{line_count}): #end encountered while not defining a block'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif after_directive != None:
                            dprint('Error ({filename}:{line_count}): extra characters found after #end'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        current_block = block_stack.pop()
                        if current_block['name']:
                            in_block = False
                    elif directive == 'include':
                        if block_name == None:
                            dprint('Error ({filename}:{line_count}): Invalid block name after #include'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif trailing != '':
                            dprint('Error ({filename}:{line_count}): unexpected characters after #include {name}'.format(filename=filename, line_count=line_count, name=block_name))
                            self.errors += 1
                            continue
                        line = { 'indent':indent, 'block_name':block_name, 'line_count':line_count }
                        current_block['lines'].append(line)

        if in_block:
            block_name = current_block['name']
            dprint('Error ({filename}:{line_count}): End of file while defining block {block_name}'.format(filename=filename, line_count=line_count, block_name=block_name))
            self.errors += 1

        self.writing_blocks = {}
        indents = []

        if Options.yaml_file != None:
            with open(Options.yaml_file, 'w') as stream:
                self.write_block(stream, Config.main_block_name, '', 1)
        else:
            tmpfile = tempfile.TemporaryFile(mode='w+')
            self.write_block(tmpfile, Config.main_block_name, '', 1)

        if self.errors > 0:
            sys.exit()

        if Options.yaml_file != None:
            sys.exit()

        tmpfile.seek(0)
        return tmpfile

    def write_block(self, file, block_name, indent, line_count):
        if block_name in self.writing_blocks:
            previous_line_count = self.writing_blocks[block_name]
            dprint('Error ({filename}:{line_count}): #include {block_name}, recursively included, previously at {previous_line_count}'.format(filename=self.filename, line_count=line_count, block_name=block_name, previous_line_count=previous_line_count))
            self.errors += 1
            sys.exit()

        self.writing_blocks[block_name] = line_count

        block = self.blocks[block_name]
        for line in block['lines']:
            if isinstance(line, str):
                if line != "\n":
                    line = indent + line
                file.write(line)
            else:
                block_name = line['block_name']
                if block_name not in self.blocks:
                    line_count = line['line_count']
                    dprint('Error ({filename}:{line_count}): #include of undefined block {block_name}.'.format(filename=self.filename, line_count=line_count, block_name=block_name))
                    self.errors += 1
                    continue

                self.write_block(file, block_name, indent + line['indent'], line_count)

        del self.writing_blocks[block['name']]

def read_config(config_file_name):
    with Config.preprocess(config_file_name) as stream:
        try:
            config = yaml.safe_load(stream)
        except yaml.YAMLError as exc:
            dprint(exc)

        for config_info in config:
            item = config_info['item']
            if item == 'page':
                Page(config_info)
            elif item == 'server':
                Server(config_info)
            elif item == 'defaults':
                Default(config_info)
            else:
                raise Exception("Unexpected top level item '{item}' in '{filename}'.".format(item=item, filename=config_file_name))

def font_height(font):
    return font.metrics("linespace")

class poll_info():
    def __init__(self, interval, id=None):
        self.interval = interval
        self.id = id

class Poll():
    infos = {}

    def set_top(top):
        Poll.top = top

    def add(interval, callback, repeat=True):
        if callback in Poll.infos:
            Poll.remove(callback)

        callback_interval = interval
        if not repeat:
            callback_interval = None
        info = poll_info(callback_interval)
        Poll.infos[callback] = info

        info.id = Poll.top.after(interval, lambda: Poll.callback(callback))

    def remove(callback):
        info = Poll.infos.get(callback, None)
        if info == None:
            return
        Poll.top.after_cancel(info.id)
        del Poll.infos[callback]

    def remove_all():
        for callback in list(Poll.infos):
            try:
                Poll.remove(callback)
            except:
                pass

    def callback(callback):
        callback()
        info = Poll.infos.get(callback, None)
        if info == None or info.interval == None:
            try:
                del Poll.infos[callback]
            except:
                pass
        else:
            info.id = Poll.top.after(info.interval, lambda : Poll.callback(callback))

    def call(interval, callback):
        Poll.add(interval, callback, repeat=False)

class Options():
    config_file = None
    verbose = 0
    debug = 0
    yaml_file = None

    @staticmethod
    def Parse():
        parser = OptionParser(version=version)
        parser.add_option('-c', '--config', dest='config_file', default='k4companion.yaml',
                          help="use config file FILE", metavar="FILE")
        parser.add_option('-v', '--verbose', action='count', dest='verbose', default = 0,
                          help="output additional status messages")
        parser.add_option('-d', '--debug', action='count', dest='debug', default=0,
                          help="output debugging messages")
        parser.add_option('--yaml', dest='yaml_file', default=None,
                          help="output preprocessed YAML to FILE", metavar="FILE")
        (options, args) = parser.parse_args()

        Options.config_file = options.config_file
        Options.verbose = options.verbose
        Options.debug = options.debug
        Options.yaml_file = options.yaml_file

        if Options.debug > 0 and Options.verbose == 0:
            Options.verbose = Options.debug

        if len(args) != 0:
            parser.error("Unexpected argument '{arg}'".format(arg=args[0]))

def clean_up():
    for server in Server.servers():
        server.close()

    Audio.close()
    Poll.remove_all()

def exit():
    for server in Server.servers():
        server.exit()

    Audio.close()
    Poll.remove_all()

    Page.top.quit()

class Popup():
    queue = queue.Queue()
    poll_interval = 200          # 200 mS
    previous_popup = None

    @classmethod
    def show_popup(cls, msg, title, timeout, font, color):
        if isinstance(msg, str):
            msg = [ msg ]
        msg = "\n\n".join(msg)
        popup = cls(title=title, timeout=timeout, font=font, color=color)
        label = tk.Label(popup.frame, text=msg, anchor='center', justify='left', font=font, bg=color)
        label.grid(row=0, column=0)
        popup.show()

    @classmethod
    def show_popups(cls):
        cls.remove_previous()
        cls.dequeue_popups()

    @classmethod
    def dequeue_popups(cls):
        while True:
            try:
                msg, title, timeout, font, color = cls.queue.get_nowait()
                cls.show_popup(msg, title, timeout, font, color)
            except queue.Empty:
                break

        Poll.call(cls.poll_interval, cls.dequeue_popups)

    @classmethod
    def popup(cls, msg='', title='', timeout=None, font=None, color='yellow'):
        if threading.current_thread() == threading.main_thread():
            cls.show_popup(msg, title, timeout, font, color)
        else:
            cls.queue.put((msg, title, timeout, font, color))

    @classmethod
    def warning(cls, msg, timeout=2000):
        if isinstance(msg, str):
            msg = 'Warning: ' +  msg
        else:
            msg[0] = 'Warning: ' + msg[0]
        dprint(msg)
        cls.popup(msg=msg, title='Warning', timeout=timeout, font=None, color='yellow')

    @classmethod
    def error(cls, msg, timeout=5000):
        if isinstance(msg, str):
            msg = 'Error: ' +  msg
        else:
            msg[0] = 'Error: ' + msg[0]
        dprint(msg)
        cls.popup(msg=msg, title='Error', timeout=timeout, font=None, color='yellow')

    @classmethod
    def remove_previous(cls):
        if cls.previous_popup != None:
            try:
                cls.previous_popup.destroy()
            except:
                pass
            cls.previous_popup = None

    def __init__(self, title='', timeout=None, font=None, color='yellow', modal=False):
        self.__class__.remove_previous()
        if timeout == 0:
            timeout = None
        self.timeout = timeout
        self.popup = tk.Toplevel(Page.top)
        self.popup.title(title)
        if font == None:
            font = Page.main().font()
        size = font.cget('size')
        self.frame = tk.Frame(self.popup, padx=size*2, pady=size*2, bg=color)
        self.popup.attributes('-topmost', True)
        self.__class__.previous_popup = self.popup

    def show(self):
        self.frame.grid()
        if self.timeout != None:
            Poll.call(self.timeout, self.popup.destroy)

    def wait(self):
        self.frame.grid()
        self.frame.wait_window()

    def close(self, event=None):
        self.popup.destroy()

    def password_button_clicked(self):
       if self.password_show_button.cget('text') == 'Show':
           self.password_show_button.configure(text='Hide')
           self.password_entry.configure(show='')
       else:
           self.password_show_button.configure(text='Show')
           self.password_entry.configure(show='*')

    def password_entered(self, event=None):
        if self.password_var.get() != '':
            self.close()

    def password(msg='', title='', font=None, color='yellow'):
        if isinstance(msg, str):
            msg = [ msg ]
        msg = "\n\n".join(msg)
        popup = Popup(title=title, font=font, color=color, modal=True)
        label = tk.Label(popup.frame, text=msg, anchor='w', justify='left', font=font, bg=color)
        label.grid(row=0, column=0, sticky='w')
        var = tk.StringVar()
        frame = tk.Frame(popup.frame, bg=color)
        frame.grid(row=1, column=0, sticky='w')
        entry = tk.Entry(frame, textvariable=var, show='*', justify='left', font=font, bg=color)
        entry.grid(row=0, column=0)
        entry.focus()
        entry.bind('<Return>', popup.password_entered)
        show_button = tk.Button(frame, text='Show', font=font, bg=color,
                                command=popup.password_button_clicked)
        show_button.grid(row=0, column=1)
        submit_button = tk.Button(popup.frame, text='Submit', font=font, bg=color,
                                command=popup.close)
        submit_button.grid(row=2, column=0, sticky='w')
        popup.password_var = var
        popup.password_entry = entry
        popup.password_show_button = show_button
        popup.frame.grid()
        popup.popup.transient(Page.top)
        popup.popup.grab_set()
        popup.popup.protocol('WM_DELETE_WINDOW', popup.close)
        Page.top.wait_window(popup.popup)
        return var.get()

class Timer():
    timers = {}

    @classmethod
    def timer(cls, name):
        return cls.timers.get(name, None)

    def __init__(self, name, entries):
        self.entries = entries
        self.times = []
        self.index = 0
        for i in range(0, entries):
            self.times.append(0)
        self.timers[name] = self

    def add(self):
        self.times[self.index] = time.time_ns()

        self.index += 1
        if self.index >= self.entries:
            self.index = 0

    def values(self):
        return self.times

    def deltas(self):
        deltas = []
        for i in range(self.entries):
            if i == 0:
                previous = self.entries - 1
            else:
                previous = i - 1
            deltas.append(self.times[i] - self.times[previous])

        return deltas

def validate_config_options(dictionary, requireds, options, name=None):
    if name == None:
        name = dictionary['item']

    id = ''
    for key in ['label', 'text', 'tabname']:
        if key in dictionary:
            id = dictionary[key]
            break

    options.extend(requireds)
    for option in dictionary.keys():
        if option not in options:
            raise Exception("Unrecognized option '{option}' in item '{name}'{id}.".format(option=option, name=name, id=id))

    for option in requireds:
        if option not in dictionary or dictionary[option] == None:
            if id != '':
                id = ' ({id})'.format(id=id)
            raise Exception("Required option '{option}' missing in item '{name}'{id}.".format(option=option, name=name, id=id))

def hex_decode(string):
    return re.sub('%(..)', lambda m: chr(int(m[1], 16)), string)

def dprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def dprint1(*args, **kwargs):
    if Options.debug >= 1:
        print(*args, file=sys.stderr, **kwargs)

def dprint2(*args, **kwargs):
    if Options.debug >= 2:
        print(*args, file=sys.stderr, **kwargs)

def dprint3(*args, **kwargs):
    if Options.debug >= 3:
        print(*args, file=sys.stderr, **kwargs)

def dprint4(*args, **kwargs):
    if Options.debug >= 4:
        print(*args, file=sys.stderr, **kwargs)

def vprint1(*args, **kwargs):
    if Options.verbose >= 1:
        print(*args, **kwargs)

def vprint2(*args, **kwargs):
    if Options.verbose >= 2:
        print(*args, **kwargs)

def tprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def trace_stack():
    traceback.print_stack()

def main_page_visible(self):
    page = Page.main()
    server = page.server
    if server.connect_on_start:
        server.connect()

def start():
    Poll.set_top(Page.top)
    Popup.show_popups()

    read_config(Options.config_file)

    page = Page.main()
    page.frame.bind('<Visibility>', main_page_visible)
    Page.show_page(page.name)

def restart():
    clean_up()
    Page.main().frame.destroy()
    start()

def close_splash_screen():
    try:
        import pyi_splash
        pyi_splash.close()
    except ImportError:
        pass

def main():
    close_splash_screen()

    Options.Parse()

    top = tk.Tk()
    top.title('K4-Companion ' + version)
    top.protocol("WM_DELETE_WINDOW", exit)
    Page.top = top

    start()

    top.mainloop()

if __name__ == '__main__':
    main()

# vim: set expandtab ts=4 sw=4:
