#!/usr/bin/env python3

# K4-Companion is an application written in python3 that can remotely
# control and Elecraft K4 tranceiver via TCP/IP.  It currently controls
# the main K4 features and is very useable as is, but new features are
# being added all the time.  K4-Companion is very configurable.
#
# K4-Companion began life as a simple macro-sending program called
# K4Macro-Python, created by Charles Powell, NK8O. It has now grown far
# beyond a simple macro-sending program into a full-fledged remote control
# program for the K4.
#
# Please send problem reports either: by sending an email, by entering
# an issue on github, or by making a pull request. Problem reports and
# suggesions are greatly appreciated.
#
# Configuration information is maintained in a separate YAML file named,
# by default, k4companion.yaml.
#
# Dale Farnsworth, W7DA
# dale@farnsworth.org
#
# Copyright (C) 2025  Dale Farnsworth
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

import configparser
import ctypes
import glob
import hashlib
import math
import numpy
import opuslib
import optparse
import os
import pathlib
import platform
import pyaudio
import queue
import re
import select
import socket
import socks
import ssl
import subprocess
import sys
import tempfile
import textwrap
import threading
import time
import tkinter as tk
import tkinter.ttk as ttk
import tkinter.font as tkFont
import traceback
import yaml

appname = 'k4companion'
version = "1.4"

python_version = platform.python_version_tuple()
python_major = int(python_version[0])
python_minor = int(python_version[1])
python_patchlevel = int(python_version[2])

try:
    # Create our own stderr so we can print to stderr while fd 2 is closed.
    stderr = os.fdopen(os.dup(2), 'w')
except:
    # If running in a PyInstaller bundle, fdopen of dup doesn't work.
    stderr = sys.stderr

class Default():
# may be overriden by values in the config file
    bg = 'maroon1'
    abg = 'yellow'
    fg = 'black'
    afg = None        # None means same as fg
    selectcolor = 'lightgreen'
    label_font =  { 'family': 'Helvetica', 'size': 10, 'weight': 'normal' }
    button_font = { 'family': 'Helvetica', 'size': 10, 'weight': 'normal' }

    def __init__(self, config_info):
        required = ['item']
        optional = ['bg', 'abg', 'fg', 'afg', 'selectcolor', 'label_font', 'button_font']
        validate_options(config_info, required, optional)

        Default.bg = config_info.get('bg', Default.bg)
        Default.abg = config_info.get('abg', Default.abg)
        Default.fg = config_info.get('fg', Default.fg)
        Default.afg = config_info.get('afg', Default.afg)
        Default.selectcolor = config_info.get('selectcolor', Default.selectcolor)
        Default.label_font = config_info.get('label_font', Default.label_font)
        Default.button_font = config_info.get('button_font', Default.button_font)

class Server():
    k4_name = ''
    k4_server = None
    k4_section = 'Elecraft K4'
    settings = None

    receive_poll_interval = 1           # poll every 1 mS
    ping_poll_interval = 2000           # poll every 2 seconds
    packet_header_len = 8
    packet_trailer_len = 4
    begin_packet_marker = bytes((0xFE, 0xFD, 0xFC,  0xFB))
    end_packet_marker = bytes((0xFB, 0xFC, 0xFD, 0xFE))
    payload_type_cat = 0
    payload_type_audio = 1
    payload_type_pan = 2
    payload_type_minipan = 3
    cat_version_number = 0
    cat_sequence_number = 0
    control_k4_audio_cmd_bases = ( 'AG', 'AG$', 'MG' )
    audio_version_number = 1

    k4_get_cmd_bases = [         # For future use
        '#A',
        'AC',
        'ACM',
        'ACN1',
        'ACN2',
        'ACN3',
        'ACN4',
        'ACN5',
        'ACs',
        'ACT',
        'AF',
        'AG$',
        'AI',
        'AL',
        'AN',
        'AP$',
        '#AR',
        'AR$',
        'AT',
        '#AVG',
        'BG',
        'BI',
        'BL',
        'BN$',
        'BR',
        'BS',
        'BW$',
        '#C',
        'CC',
        '#CUR$',
        'CW',
        '#D',
        'DA',
        'DB$',
        'DN',
        'DO',
        '#DPM',
        'DR$',
        '#DSM',
        'DT$',
        'DV',
        'DW',
        'ER',
        'ES',
        '#F',
        'FA',
        'FB',
        'FC$',
        'FI$',
        'FP$',
        '#FPS',
        'FR',
        '#FRZ',
        'FT',
        'FX',
        '#FXA',
        '#FXT',
        'GT$',
        '#H',
        'HD',
        '#HDPM',
        '#HDSM',
        '#HREF$',
        '#HWBS',
        '#HWFC',
        'ID',
        'IF',
        'IP',
        'IS$',
        'K4',
        'KCL',
        'KP',
        'KS',
        'KZ',
        'KZF',
        'LB',
        'LI',
        'LK$',
        'LN',
        'LO',
        '#M',
        'MA$',
        'MD$',
        'ME',
        'MEDF',
        'MG',
        'MI',
        'ML',
        '#MP$',
        'MS',
        'MX',
        '#N',
        'NA$',
        '#NB$',
        'NB$',
        '#NBL$',
        'NM$',
        'NR$',
        'OM',
        'OV$',
        '#P',
        'PA$',
        'PC',
        'PING',
        'PK',
        '#PKM',
        'PL$',
        'PONG',
        'PP',
        '#R',
        'RA$',
        'RE',
        '#REF$',
        'RG$',
        'RL',
        'RO$',
        'RP',
        'RR',
        'RRC',
        'RRP',
        'RS',
        'RT$',
        'RV',
        '#S',
        'SB',
        'SC',
        '#SCL',
        'SD',
        '#SFL',
        'SI',
        'SL',
        'SM$',
        'SMH',
        'SMH$',
        'SN',
        '#SPM',
        '#SPN$',
        'SQ$',
        'SW',
        'TA',
        'TB$',
        'TD$',
        'TE',
        'TG',
        'TQ',
        'TS',
        'TX',
        'UP',
        'UT',
        '#V',
        'VC',
        '#VFA',
        '#VFB',
        'VG',
        'VI',
        'VO$',
        'VT$',
        'VX',
        '#W',
        '#WBS',
        '#WFC',
        'WM',
        'XT',
        'XV',
        'XV$',
        # The following are pseudo commands/responses
        'TR',
        '!ES0',
        '!ES1',
    ]
    k4_long_cmd_bases = {
        '#A': ['#AR', '#AVG'],
        'AC': ['ACM', 'ACS', 'ACT', 'ACN1', 'ACN2', 'ACN3', 'ACN4', 'ACN5'],
        'BR': ['BR0', 'BR1', 'BR2'],
        '#C': ['#CAL', '#CUR'],
        '#D': ['#DPM', '#DSM'],
        'DN': ['DNB'],
        '#F': ['#FPS', '#FRZ', '#FXA', '#FXT'],
        '#H': ['#HDPM', '#HDSM', '#HREF', '#HWBS', '#HWFC', '#HWFH'],
        'KZ': ['KZL', 'KZF'],
        'LO': ['LOG'],
        '!M': ['!MACROS'],
        'ME': ['MEDF'],
        'ML': ['ML0', 'ML1', 'ML2'],
        '#M': ['#MP'],
        '#N': ['#NBL', '#NB'],
        'PC': ['PCX'],
        'PI': ['PING'],
        'PK': ['PK0', 'PK1', 'PK2'],
        'PO': ['PONG'],
        '#P': ['#PKM'],
        '#R': ['#REF'],
        'RR': ['RRT', 'RRC', 'RRP'],
        'SD': ['SD0', 'SD1', 'SDC', 'SDV', 'SDD'],           # Differentiate between the cmd variants
        'SI': ['SIDA', 'SIDD', 'SIDU', 'SIFP', 'SIRF', 'SIRC'],         # SIDU is first after param dump
        'SM': ['SMH'],
        '#S': ['#SCL', '#SFL', '#SPM', '#SPN'],
        'SW': ['SWT', 'SWH'],
        'UP': ['UPB'],
        'VG': ['VGV', 'VGD'],
        'VX': ['VXV', 'VXC'],
        '#V': ['#VFA', '#VFB'],
        '#W': ['#WBS', '#WFC', '#WFH'],
        'XV': ['XVN', 'XVM', 'XVR', 'XVI', 'XVO', 'XVP '],
# Directives:
        'CO': ['CONNECT!'],
        'EX': ['EXIT!'],
        'QU': ['QUIT!'],
        'RE': ['RESTART!'],
        'TU': ['TUNE!'],
        'SH': ['SHOW!'],
    }

    # commands that end in +, -, /, \, ^, > are also pseudo set-only commands
    k4_set_only_cmd_bases = {
        'AB': True,
        'DE': True,
        'DM': True,
        'DNB': True,
        'DN': True,
        'EC': True,
        'LI': True,     # where total length of cmd is <= 6 characters
        'MS': True,     # where total length of cmd is <= 4 characters
        'PING': True,
        'RC$': True,
        'RC': True,
        'RD$': True,
        'RD': True,
        'RU$': True,
        'RU': True,
        'SI': True,
        'SP$': True,
        'SP': True,
        'SWH': True,
        'SW': True,
        'SWT': True,
        'UPB': True,
        'UP': True,
# Directives:
        'QUIT': True,
        'SHOW': True,
    }

    set_only_suffixes = {
        '+': True,
        '-': True,
        '/': True,
        '\\': True,
    }

    k4_get_only_cmd_bases = {
        'BG': True,
        'IF': True,
        'MA$': True,
        'MA': True,
        'OM': True,
        'PONG': True,
        'PP': True,
        'RV': True,
        'SM$': True,
        'SMH$': True,
        'SMH': True,
        'SM': True,
        'SN': True,
        'TA': True,
        'TG': True,
        'TQ': True,
        'UT': True,
    }

    @staticmethod
    def k4_set_only_cmd(base, cmd):
        if base in Server.k4_set_only_cmd_bases:
            if base == 'LI' and len(cmd) > 6:
                return False
            elif base == 'MS' and len(cmd) > 4:
                return False
            else:
                return True
        elif base[-1] in Server.set_only_suffixes:
            return True
        elif base in 'KY' and len(cmd) > 2:
            return True
        else:
            return False

    @staticmethod
    def k4_get_only_cmd(base):
        return base in Server.k4_get_only_cmd_bases

    @staticmethod
    def send_cmds_with_server(cmd_list):
        for server_name, cmds in cmd_list:
            if server_name == Server.k4_server.name:
                server = Server.k4_server
                server.send_cmds(cmds)
            elif server_name == 'delay':
                delay = float(cmd_dict[server_name]) / 1000
                time.sleep(delay)
            else:
                raise Exception("Unknown server name '{name}'".format(name=server_name))

    @staticmethod
    def split_cmd(cmd):
        if cmd[-1] == ';':
            cmd = cmd[0:-1]
        return cmd.split(';')

    def __init__(self):
        Server.k4_server = self
        Server.settings = Settings()

        section = Server.k4_section
        self.name = Server.settings.get(section, 'name', '*new*')
        self.address_port = Server.settings.get(section, 'address', '')
        self.password = self.password_from_settings()
        self.proxy_address_port =  Server.settings.get(section, 'proxy_address', '')
        self.type = 'k4'
        self.startup_cmds = ''
        self.exit_cmds = ''
        self.address = ''
        self.port = 9205
        self.proxy_address = ''
        self.proxy_port = ''
        self.socket = None
        self.recv_buffer = ''
        self.send_queue = queue.Queue()
        self.recv_queue = queue.Queue()
        self.output_audio_queue = None
        self.send_thread = None
        self.recv_thread = None
        self.connected = False
        self.k4_subscriptions = {}
        self.k4_parameters = {}
        self.connect_callbacks = []
        self.partial_packet = None
        self.password = None
        self.control_k4_audio = Server.settings.getbool('Audio', 'control_k4_audio_settings')
        self.buffered_audio_packets = Server.settings.getint('Audio', 'buffered_packets', 1, minimum=1, maximum=100)
        self.audio_sequence_number = 0
        self.received_initial_parameters = False
        self.received_initial_parameters_callbacks = []
        self.cat_only = False
        self.printed_connection_warning = False
        self.last_tune_cmd = Server.settings.get(section, 'tune_cmd', 'TU3;')
        self.received_cat_cmd = False

        self.set_address(self.address_port)
        self.set_proxy(self.proxy_address_port)

        set_page_title(self.name)

        self.ignored_errors = {}

        self.subscribe_response('ER;', self.on_error_code, send=False)
        self.subscribe_response('SIDU', self.on_received_initial_parameters, send=False)
        self.subscribe_connect(self.on_server_connect)

    def on_server_connect(self):
        self.request_initial_parameters()
        self.update_local_audio_parameters()
        if self.type == 'k4' and not self.cat_only:
            Audio.server_connected(self)
        Page.main().select_tab('Main')

    def on_error_code(self, response):
        response = response.rstrip(';')
        try:
            code, text = response.split(':', 1)
            Popup.warning(msg=[code, text])
        except:
            Popup.warning(msg=response)

    def subscribe_connect(self, callback):
        if self.connected:
            callback()
        else:
            self.connect_callbacks.append(callback)

    def update_k4_parameter(self, base, parameter):
        if base in ('TX', 'RX', 'SD0', 'SD1', 'ES', 'TB', 'TB$'):
            if base == 'TX':
                self.update_k4_parameter('TR', 'T')
            elif base == 'RX':
                self.update_k4_parameter('TR', 'R')
            elif base in ('SD0', 'SD1'):   # Differentiate between the variants
                base, parameter = base[0:2] + parameter[0], base[2] + parameter[1:]
            elif base == 'ES':
                if parameter[0] == '0':
                    self.update_k4_parameter('!ES0', parameter[1:])
                elif parameter[0] == '1':
                    self.update_k4_parameter('!ES1', parameter[1:])
            elif base in ('TB', 'TB$'):
                if len(parameter) < 3:
                    return

        old = self.k4_parameters.get(base, None)
        self.k4_parameters[base] = parameter

        callbacks = self.k4_subscriptions.get(base, [])
        for callback in callbacks:
            callback(base + parameter + ';')

        return  old != parameter

    def k4_parameter(self, base):
        return self.k4_parameters.get(base, None)

    def connect(self):
        if self.connected and self.received_cat_cmd:
            return True

        if self.address == '':
            Popup.error("No server address. Add the address to the Server tab.")
            return False

        self.cat_only = self.port == 9200

        vprint1('Connecting to {name}, address {addr}, port {port}'.format(
              name=self.name, addr=self.address, port=self.port))

        if python_major >= 3 and python_minor >= 13:
            context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            context.maximum_version = ssl.TLSVersion.TLSv1_2
            context.set_ciphers('PSK')
            psk = '1234567890'.encode()
            context.set_psk_client_callback(lambda hint: (None, psk))

        if self.proxy_address == '':
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        else:
            sock = socks.socksocket(socket.AF_INET, socket.SOCK_STREAM)
            if self.proxy_port == '':
                sock.set_proxy(socks.SOCKS5, self.proxy_address) # SOCKS5 uses port 1080 by default
            else:
                sock.set_proxy(socks.SOCKS5, self.proxy_address, self.proxy_port)

        try:
            sock.settimeout(5)
            if python_major >= 3 and python_minor >= 13 and self.port == 9204:
                sock = context.wrap_socket(sock)
            sock.connect((self.address, self.port))
            self.connected = True
            self.printed_connection_warning = False
            self.socket = sock
            self.send_thread = threading.Thread(target=self.send_loop, name=self.name+'.send_thread')

            self.send_thread.start()
            if self.cat_only:
                recv_loop = self.cat_only_recv_loop
            else:
                recv_loop = self.recv_loop

            self.recv_thread = threading.Thread(target=recv_loop, name=self.name+'.recv_thread')
            self.recv_thread.start()
            if self.type == 'k4':
                if self.cat_only:
                    self.dequeue_k4_cat()

                    self.send_str('PING;')               # Trigger a response: PONG;
                else:
                    self.output_audio_queue = queue.Queue()

                    if self.password == None:
                        self.password = Popup.password(title="Connect to K4",
                            msg="Enter your k4 remote password:")
                        if self.password == '':
                            Page.main().select_tab('Server')
                            Page.show_page(Page.main().name)
                            return False

                    h = hashlib.sha384(self.password.encode()).hexdigest()
                    self.send_str(h, force_as_string=True)

                    self.wait_for_k4_received_data()
                    self.receive_non_audio_packets()

                    Poll.add(Server.ping_poll_interval, self.ping)

                for callback in self.connect_callbacks:
                    callback()
            error = None

            if not self.cat_only:
                Poll.call(4000, self.check_for_received_cat_cmd)

        except socket.gaierror:
            error = 'Address not found: {addr}'.format(addr=self.address)
        except:
            error = "Failed to connect to {name}, address {addr}, port {port}\n".format(
                name=self.name, addr=self.address, port=self.port)
            if self.proxy_address != '':
                port = self.proxy_port
                if port == '':
                    port = 'default'
                error += '  via proxy address {addr}, port {port}'.format(
                      name=self.name, addr=self.proxy_address, port=port)

        if error != None:
            Page.main().select_tab('Server')
            Page.show_page(Page.main().name)
            Popup.error(error, timeout=None)
            return False

        return True

    def check_for_received_cat_cmd(self):
        if not self.received_cat_cmd:
            self.connnected = False

            error = 'No response received from: {name}'.format(name=self.name)

            pw = self.password_from_settings()
            if pw == '' and self.password != '':
                Popup.modal(error, timeout=1000)
                restart()
            else:
                error += "\n\nCheck the K4 password in the Server tab."
                Page.main().select_tab('Server')
                Page.show_page(Page.main().name)
                Popup.error(error, timeout=None)

    def request_initial_parameters(self):
        self.send_str('K41;')                # request K4 to respond in advanced mode
        self.send_str('EM3;')                # request opus-float encoded audio
        self.send_str('AI4;')                # request K4 to send updates immediately
        self.send_str('ER1;')                # request long format error messages
        self.send_cmds('MD;MD$;')            # cache the mode response for later use in setting the vfo step

        if self.startup_cmds != '':
            self.send_cmds(self.startup_cmds)# send user-specified startup commands

        self.send_str('RDY;')

        self.send_str('SIDA0;')              # Disable AI4 delivery of DAP info reports
        self.send_str('SIDD0;')              # Disable AI4 delivery of DDC info reports
        self.send_str('SIFP0;')              # Disable AI4 delivery of FP info reports
        self.send_str('SIRF0;')              # Disable AI4 delivery of RFB info reports
        self.send_str('SIRC0;')              # Disable AI4 delivery of RMT connection info

        self.send_str('BI;')                 # Request Band Independence status
        self.send_str('RL;')                 # Request the software release line
        self.send_str('RO$;')                # Request the VFO B RIT offset status
        self.send_str('RT$;')                # Request the VFO B RIT on/off status
        self.send_str('MX;')                 # Request the audio mixer status

    def subscribe_received_initial_parameters(self, callback):
        if self.received_initial_parameters:
            callback(self)
        else:
            self.received_initial_parameters_callbacks.append(callback)

    def on_received_initial_parameters(self, response):
        self.send_str('SIDU0;')              # Disable AI4 delivery of DUC info reports
        self.received_initial_parameters = True
        for callback in self.received_initial_parameters_callbacks:
            callback(self)

        cmd = self.last_tune_cmd
        if cmd != None:
            base = cmd_base(cmd)
            orig_param = self.k4_parameter(base)
            self.update_k4_parameter(cmd_base(cmd), cmd_parameter(cmd))
            if orig_param != None:
                self.update_k4_parameter(cmd_base(cmd), orig_param)

    def close(self):
        self.connected = False
        if self.type == 'k4':
            self.send_queue.put('shutdown')
            if self.output_audio_queue != None:
                self.output_audio_queue.put([])
            if self.send_thread != None:
                self.send_thread.join()
            if self.recv_thread != None:
                self.recv_thread.join()
            if self.socket != None:
                self.socket.shutdown(socket.SHUT_RDWR)
                self.socket.close()

    def exit(self):
        if self.connected:
            if self.type == 'k4' and self.exit_cmds != '':
                self.send_cmds(self.exit_cmds)
            self.send_cmds('PING;')

            # wait for commands to be sent
            while not self.send_queue.empty():
                time.sleep(.01)

        self.close()

    def send_str(self, cmd, force_as_string=False):
        if self.cat_only or force_as_string:
            self.send_queue.put((cmd.encode(), ))
        else:
            self.send_cat_packet(cmd.encode())

    def send_cat_packet(self, cat_bytes):
        self.send_queue.put((
            Server.begin_packet_marker,
            self.encode_len(len(cat_bytes)+3),
            bytes((Server.payload_type_cat, Server.cat_version_number, Server.cat_sequence_number)),
            cat_bytes,
            Server.end_packet_marker))

    def send_audio_packet(self, audio_bytes, encode_mode, frame_size):
        high = frame_size>>8
        low = frame_size & 0xff
        self.send_queue.put((
            Server.begin_packet_marker,
            self.encode_len(len(audio_bytes)+7),
            bytes((Server.payload_type_audio, Server.audio_version_number, self.audio_sequence_number)),
            bytes((encode_mode, low, high, Audio.k4_sample_rate_code)),
            audio_bytes,
            Server.end_packet_marker))
        self.audio_sequence_number += 1
        if self.audio_sequence_number > 0xff:
            self.audio_sequence_number = 0

    def encode_len(self, l):
        return bytearray(((l>>24)&0xff, (l>>16)&0xff, (l>>8)&0xff, l&0xff))

    def directive(self, base, cmd):
        lbase = base.lower()
        lcmd = cmd.lower()
        if lcmd == 'connect!':
            self.connect()
        elif lcmd == 'quit!' or lcmd == 'exit!':
            exit()
        elif lcmd == 'tune!':
            self.tune_directive()
        elif lcmd == 'restart!':
            restart()
        elif lbase == 'show!':
            page = lcmd[len(base):].strip()
            if page == 'previous':
                Page.show_previous()
            else:
                Page.show_page(page)
        else:
           raise Exception('Unknown directive: ', directive)

    def save_last_tune_cmd(self, cmd):
        self.last_tune_cmd = cmd + ';'
        Server.settings.put_save(Server.k4_section, 'tune', self.last_tune_cmd)

    def tune_directive(self):
        if self.k4_parameters.get('TU') == '0':
            cmd = self.last_tune_cmd
        else:
            cmd = 'TU0;'
        self.send_cmds(cmd)

    def send_cmds(self, cmds):
        send = True
        if isinstance(cmds, str):
            cmds = Server.split_cmd(cmds)
        for cmd in cmds:
            if cmd == '':
                continue
            base = cmd_base(cmd)
            if self.is_directive(base):
                self.directive(base, cmd)
                continue
            if base in ('TR', 'SDC', 'SDV', 'SDD', 'SB', 'TU', '!MACROS') + Server.control_k4_audio_cmd_bases:
                if base == 'TR':
                    if cmd[2] == 'T':
                        self.update_k4_parameter('TR', 'T')
                        self.send_str('TX;')
                    else:
                        self.update_k4_parameter('TR', 'R')
                        self.send_str('RX;')
                    return
                elif base in ('SDC', 'SDV', 'SDD'):
                    cmd = cmd[0:2] + cmd[3] + cmd[2] + cmd[4:]
                    base = cmd[0:3]
                elif base == 'SB':
                    Audio.control_k4_cmd(base, cmd)
                elif base in Server.control_k4_audio_cmd_bases:
                    Audio.control_k4_cmd(base, cmd)
                    if not self.cat_only and not self.control_k4_audio:
                        continue
                elif base == 'TU' and cmd != 'TU0' and len(cmd) > 2:
                    self.save_last_tune_cmd(cmd)
                elif base == '!MACROS':
                    send = False
            if self.warn_if_not_connected():
                return
            if (Server.k4_set_only_cmd(base, cmd) or self.update_k4_parameter(base, cmd[len(base):])) and send:
                cmd += ';'
                self.send_str(cmd)

    def warn_if_not_connected(self):
        if self.connected:
            return False
        if not self.printed_connection_warning and self.received_cat_cmd:
            Popup.warning("Server '{name}' not connected.".format(name=self.name))
        self.printed_connection_warning = True
        return True

    def send_loop(self):
        while True:
            bs = self.send_queue.get()
            if not self.connected:
                return

            try:
                self.socket.sendmsg(bs)
            except:
                for b in bs:
                    try:
                        self.socket.send(b)
                    except:
                        dprint1('socket.send error')
                        self.lost_connection()
                        return

            if Options.debug >= 1:
                cmds = None
                if self.cat_only:
                    cmds = bs[0]
                elif bs[0] == Server.begin_packet_marker and bs[2][0] == Server.payload_type_cat:
                    cmds = bs[3]

                if cmds != None:
                    cmds = cmds.decode()
                    if cmds in ('PING;', 'ACN1;'):
                        dprint3('{name}: sent: {cmds}'.format(name=self.name, cmds=cmds))
                    else:
                        dprint1('{name}: sent: {cmds}'.format(name=self.name, cmds=cmds))

    def expand_cmds(self, cmds):
        if isinstance(cmds, str):
            return [[self.name, Server.split_cmd(cmds)]]
        elif isinstance(cmds, dict):
            cmd_dict = cmds
            ret = []
            for name in cmd_dict:
                cmd = cmd_dict[name]
                ret.append(name, Server.split_cmd(cmd_dict[name]))
            return ret
        elif isinstance(cmds, list):
            ret = []
            for cmd_dict in cmds:
                if not isinstance(cmd_dict, dict):
                    raise Exception("Unknown server sub-command '{cmd}'".format(cmd=cmd_dict))
                for name in cmd_dict:
                    cmd = cmd_dict[name]
                    ret.append(name, Server.split_cmd(cmd_dict[name]))
            return ret
        else:
            raise Exception("Error: bad cmd format: '{cmds}'".format(cmds=cmds))

    def expand_server_cmds(self, cmds):
        if isinstance(cmds, str):
            return Server.split_cmd(cmds)
        ret = []
        for name, cmds in self.expand_cmds(cmds):
            if name == self.name:
                ret.extend(cmds)
        return ret

    def expand_and_send_cmds(self, cmds):
        expanded_cmds = self.expand_cmds(cmds)
        Server.send_cmds_with_server(expanded_cmds)

    def server_cmds(self, cmds):
        ret = []
        expanded_cmds = self.expand_cmds(cmds)
        for server_name, cmds in expanded_cmds:
            if server_name != self.name:
                continue
            for cmd in cmds:
                ret.append(cmd)
        return ret

    def subscribe_responses(self, cmds, callback, send=True):
        for cmd in self.server_cmds(cmds):
            self.subscribe_response(cmd, callback, send=send)

    def unsubscribe_responses(self, cmds, callback):
        for cmd in self.server_cmds(cmds):
            self.unsubscribe_response(cmd, callback)

    def ping(self):
        self.send_str('PING;')

    def wait_for_k4_received_data(self):
        select.select([self.socket.fileno()], [], [self.socket], 1)

    def receive_non_audio_packets(self):
        packet_offset = 0

        while True:
            try:
                payload_type, payload = self.recv_queue.get_nowait()
            except queue.Empty:
                Poll.call(Server.receive_poll_interval, self.receive_non_audio_packets)
                break

            if payload_type == self.payload_type_cat:
                responses = payload.decode().split(';')[:-1]
                self.receive_k4_responses(responses)
            elif payload_type == self.payload_type_pan:
                self.received_pan(payload)
            elif payload_type == self.payload_type_minipan:
                self.received_minipan(payload)

    def received_pan(self, data):
        #dprint('pan: len:', len(data))
        pass

    def received_minipan(self, data):
        #dprint('minipan: len:', len(data))
        pass

    def dequeue_k4_cat(self):
        while True:
            responses = []

            try:
                recv_bytes = self.recv_queue.get_nowait()
            except queue.Empty:
                Poll.call(Server.receive_poll_interval, self.dequeue_k4_cat)
                break

            recv_str = recv_bytes.decode()
            responses = recv_str.split(';')
            if len(responses) == 0:
                continue

            if self.partial_packet != None:
                responses[0] = self.partial_packet + responses[0]
                self.partial_packet = ''

            if responses[-1] != '':
                self.partial_packet = responses[-1]

            responses = responses[0:-1]
            self.receive_k4_responses(responses)

    def receive_k4_responses(self, responses):
        self.received_cat_cmd = True
        for response in responses:
            base = cmd_base(response)
            if base == 'SB':
                Audio.control_k4_cmd(base, response)
            if Options.debug >= 1:
                if base in ('SM', 'SM$', 'SMH', 'SMH$', 'TM', 'PONG', 'DA', 'ACN1', 'TB', 'TB$'):
                    dprint3('{name}: received: {response};'.format(name=self.name, response=response))
                else:
                    dprint1('{name}: received: {response};'.format(name=self.name, response=response))
            if not self.control_k4_audio and base in self.control_k4_audio_cmd_bases:
                continue
            response = response[len(base):]
            if response == '?' and base not in self.ignored_errors:
                Popup.warning('Received error response from K4: ' + base + response)
            self.update_k4_parameter(base, response)

    def cat_only_recv_loop(self):
        while True:
            readable, writable, in_error = select.select([self.socket.fileno()], [], [self.socket], 1)
            if not self.connected:
                return
            if len(in_error) > 0:
                dprint1('select.select error')
                self.lost_connection()
                return
            if len(readable) == 0:
                continue

            try:
                recv_bytes = self.socket.recv(16384)
            except:
                dprint1('socket.recv error')
                recv_bytes = []
            if len(recv_bytes) == 0:
                self.lost_connection()
                return

            try:
                self.recv_queue.put(recv_bytes)
            except queue.ShutDown:
                pass

    def recv_loop(self):
        packet_offset = 0

        while True:
            readable, writable, in_error = select.select([self.socket.fileno()], [], [self.socket], 1)
            if not self.connected:
                return
            if len(in_error) > 0:
                dprint1('select.select error')
                self.lost_connection()
                return
            if len(readable) == 0:
                continue

            try:
                rb = self.socket.recv(16384)
            except:
                dprint1('socket.recv error')
                rb = []
            if len(rb) == 0:
                self.lost_connection()
                return

            if self.partial_packet != None:
                rb = self.partial_packet + rb
                self.partial_packet = None

            while True:
                remaining_length = len(rb)
                if remaining_length < 8:
                    self.partial_packet = rb
                    break
                if rb[0:4] != Server.begin_packet_marker:
                    raise Exception('bad received packet header', rb[0:4])
                payload_length = (rb[4]<<24) | rb[5]<<16 | rb[6]<<8 | rb[7]
                end_offset = 12 + payload_length
                if remaining_length < end_offset:
                    self.partial_packet = rb
                    break
                if rb[end_offset-4:end_offset] != Server.end_packet_marker:
                    raise Exception('bad received packet trailer', rb[end_offset-4:end_offset])
                #dprint('payload type', rb[8], 'version', rb[9], 'sequence', rb[10])

                payload_type = rb[8]
                payload = rb[11:end_offset-4]
                if payload_type != self.payload_type_audio:
                    try:
                        self.recv_queue.put((payload_type, payload))
                    except queue.ShutDown:
                        pass
                else:
                    # If we're behind in emptying the queue, don't bother adding to it.
                    if self.output_audio_queue.qsize() < self.buffered_audio_packets+1:
                        self.output_audio_queue.put(payload)

                if remaining_length == end_offset:
                    break
                rb = rb[end_offset:]

    def subscribe_response(self, cmd, callback, send=True):
        base = cmd_base(cmd)
        if not base in self.k4_subscriptions:
            self.k4_subscriptions[base] = []
        if not callback in self.k4_subscriptions[base]:
            self.k4_subscriptions[base].append(callback)

        if self.is_directive(base):
            send = False

        if send == True:
            parameter = self.k4_parameters.get(base, None)
            if parameter != None:
                callback(base + parameter + ';')
            elif self.connected:
                if not base.startswith('!'):
                    self.send_str(base + ';')

    def unsubscribe_response(self, cmd, callback):
        base = cmd_base(cmd)
        try:
            self.k4_subscriptions[base].remove(callback)
        except:
            pass

    def cancel_k4_subscriptions(self):
        self.k4_subscriptions.clear()

    def add_ignored_error(self, base):
        self.ignored_errors[base] = True

    def set_name(self, name):
        self.name = name
        set_page_title(self.name)

    def split_address_port(self, string):
        match = re.search('^(.*):([0-9]+)', string)
        if match == None:
            return string, ''
        return match[1], match[2]

    def set_address(self, address_port):
        address, port = self.split_address_port(address_port)
        if address != '':
            self.address = address
        if port != '':
            self.port = int(port)
            if self.port > 65535:
                self.bad_port()
        previous_address_port = self.address_port
        if address_port != previous_address_port and previous_address_port != None:
            if self.password != None:
                restart()

    def set_proxy(self, proxy_address_port):
        address, port = self.split_address_port(proxy_address_port)
        if address != '':
            self.proxy_address = address
        if port != '':
            self.proxy_port = int(port)
            if self.proxy_port > 65535:
                self.bad_port()
        previous_proxy_address_port = self.proxy_address_port
        if proxy_address_port != previous_proxy_address_port and previous_proxy_address_port != None:
            if self.address != '' and self.password != None:
                restart()

    def bad_port(self):
        Popup.error('Port must be less than 65536', timeout=None)

    def set_password(self, password):
        self.password = password

    def set_new_password(self, password):
        previous_password = self.password
        self.password = password
        self.__class__.password = password
        if password != previous_password:
            if self.address != '':
                restart()

    def set_control_k4_audio(self, val):
        self.control_k4_audio = val

    def set_buffered_audio_packets(self, val):
        self.buffered_audio_packets = val

    def update_local_audio_parameters(self):
        responses = Audio.local_audio_responses()
        responses = responses.split(';')[:-1]
        for response in responses:
            base = cmd_base(response)
            response=response[len(base):]
            self.update_k4_parameter(base, response)
        if self.control_k4_audio:
            self.receive_k4_responses(responses)

    def is_directive(self, base):
        return base.endswith('!')

    def password_from_settings(self):
        h = Server.settings.get(Server.k4_section, 'insecure_password_hash')
        if h == None:
            pw = ''
        else:
            pw = Reversable_hash.unhash(h)
        return pw

    def lost_connection(self):
        if self.received_cat_cmd:
            Popup.error('Lost connection to ' + self.name, timeout=None)
        self.connected = False

    def connect_on_start(self):
        if self.address == '':
            return False
        if Settings.server_count() == 1:
            return True
        return Settings.restarting()

class Widget():
    blink_mS = 500
    default_leading = 0
    default_label_leading = 1
    by_id = {}

    def __init__(self, config_info, container):
        self.config_info = config_info
        self.container = container
        self.bg = config_info.get('bg', Default.bg)
        if self.bg == 'None':
            self.bg = Page.top.cget('bg')
        self.fg = config_info.get('fg', Default.fg)
        self.abg = config_info.get('abg', Default.abg)
        self.afg = config_info.get('afg', Default.afg)
        if self.afg == None:
            self.afg = self.fg
        self.padx = config_info.get('padx', 0)
        self.pady = config_info.get('pady', 0)
        self.sticky = '' if config_info.get('sticky', None) == 'center' else 'nw'

        self.tabcount = 0
        self.tabids = {}
        self.tabnames = {}
        self.current_tabname = None

        self.cached_font = None
        self.cached_button_font = None
        self.cached_label_font = None

        if self.container != None:
            self.server = self.container.server

        if self.container != None:
            self.frame = self.label_and_leading_frame()

    def k4param(self, base):
        if self.server.type == 'k4':
            return self.server.k4_parameter(base)
        else:
            return None

    def len_k4param(self, base):
        param = self.k4param(base)
        if param == None:
            return 0
        return len(param)

    def eval_value(self, s, value=""):
        try:
            ret = eval(str(s))
        except Exception as err:
            dprint('value: "{value}", eval("{s}")'.format(value=value, s=s))
            dprint('exception: {err}'.format(err=err))
            raise
        return ret

    def label_font(self):
        if self.cached_label_font != None:
            return self.cached_label_font
        if 'label_font' in self.config_info:
            font = self.config_info['label_font']
            font = tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])
        else:
            font = self.container.label_font()
            self.cached_label_font = font
        return font

    def button_font(self):
        if self.cached_button_font != None:
            return self.cached_button_font
        if 'button_font' in self.config_info:
            font = self.config_info['button_font']
            font = tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])
        else:
            font = self.container.button_font()
            self.cached_button_font = font
        return font

    def font(self):
        if self.cached_font != None:
            return self.cached_font
        if 'font' in self.config_info:
            font = self.config_info['font']
            font = tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])
        else:
            font = self.button_font()
            self.cached_font = font
        return font

    def label_and_leading_frame(self):
        container = self.container
        config_info = self.config_info
        if 'column' in config_info:
            column = config_info['column']
            if column < container.column:
                container.next_row()
            container.column = column

        columnspan = config_info.get('columnspan', 1)
        rowspan = config_info.get('rowspan', 1)

        self.outer_frame = tk.Frame(container.frame)

        label = config_info.get('label', None)

        if 'label' in config_info:
            default_leading = Widget.default_label_leading
        else:
            default_leading = Widget.default_leading

        leading = config_info.get('leading', default_leading)

        self.outer_frame.grid(row=container.row, column=container.column,
            rowspan=rowspan, columnspan=columnspan,
            sticky=self.sticky, padx=self.padx, pady=self.pady)

        if label == None and leading == 0:
            return self.outer_frame

        row = 0
        if leading != 0:
            family = self.label_font().cget('family')
            weight = self.label_font().cget('weight')
            leading_font = tkFont.Font(family=family, size=leading, weight=weight)
            leading_label = tk.Label(self.outer_frame, text=' ', font=leading_font)
            leading_label.grid(row=0, column=0, sticky='nw')
            row=1

        if label == None:
            inner_frame = tk.Frame(self.outer_frame)
        else:
            inner_frame = tk.LabelFrame(self.outer_frame, text=label,
                font=self.label_font(), labelanchor='nw', bd=1, relief='raised')
        inner_frame.grid(row=row, column=0, sticky=self.sticky)

        return inner_frame

    def notebook_frame(self, parent_frame):
        frame = ttk.Notebook(parent_frame)
        self.notebook = frame
        frame.bind("<<NotebookTabChanged>>", self.on_tab_changed)
        return self.notebook

    def on_tab_changed(self, event):
        tabid = self.notebook.select()
        tabname = self.tabnames[tabid]
        self.current_tabname = tabname

    def select_tab(self, tab_name):
        self.notebook.select(self.tabids[tab_name])

    def add_tab(self, frame, tabname):
            self.notebook.add(frame, text=tabname)
            tabid = str(frame)
            self.tabids[tabname] = tabid
            self.tabnames[tabid] = tabname

class Container(Widget):
    depth = -1

    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        if isinstance(self, Page):
            self.childwidth = config_info.get('childwidth', None)
        else:
            self.childwidth = config_info.get('childwidth', container.childwidth)
        self.columns = config_info.get('columns', len(self.config_info['contains']))
        self.row = 0
        self.column = 0
        self.children = []

    def next_column(self):
        self.column += 1
        if self.column >= self.columns:
            self.column = 0
            self.next_row()

    def next_row(self):
        self.row += 1

    def show_widgets(self):
        Container.depth += 1
        if len(self.config_info['contains']) == 0:
            raise Exception('item: group requires a contains: option')
        for config_info in self.config_info['contains']:
            widget_type = config_info['item'].lower()
            if widget_type == 'group':
                if Options.debug > 0:
                    label = config_info.get('label', '')
                    indent = '    ' * Container.depth
                child = Group(config_info, self)
            elif widget_type == 'button':
                child = Button(config_info, self)
            elif widget_type == 'radiobutton':
                child = Radiobutton(config_info, self)
            elif widget_type == 'vfo':
                child = VFO(config_info, self)
            elif widget_type == 'rit':
                child = RIT(config_info, self)
            elif widget_type == 'slider':
                child = Slider(config_info, self)
            elif widget_type == 'togglebutton':
                child = Togglebutton(config_info, self)
            elif widget_type == 'getvalue':
                child = Getvalue(config_info, self)
            elif widget_type == 'bargraph':
                child = Bargraph(config_info, self)
            elif widget_type == 'text':
                child = Text(config_info, self)
            elif widget_type == 'notebook':
                child = Notebook(config_info, self)
            elif widget_type == 'dropdownbutton':
                child = Dropdownbutton(config_info, self)
            elif widget_type == 'equalizers':
               child = Equalizers(config_info, self)
            elif widget_type == 'menu':
                child = Menu(config_info, self)
            elif widget_type == 'serversettings':
                child = ServerSettings_widget(config_info, self)
            elif widget_type == 'appsettings':
                child = AppSettings_widget(config_info, self)
            elif widget_type == 'fwversions':
                child = FWversions(config_info, self)
            elif widget_type == 'startup_cmds':
                child = Startup_cmds(config_info, self)
            elif widget_type == 'exit_cmds':
                child = Exit_cmds(config_info, self)
            elif widget_type == 'antenna':
                child = Antenna(config_info, self)
            elif widget_type == 'cw':
                child = CW(config_info, self)
            elif widget_type == 'macros':
                child = Macros(config_info, self)
            else:
                raise Exception('Error: config file: unknown item "{type}"'.format(type=widget_type))

            id = config_info.get('id', None)
            if id != None:
                Widget.by_id[id] = child

            self.children.append(child)

            self.next_column()

        Container.depth -= 1

    def items_width(self):
        width = 0
        for config_info in self.config_info['contains']:
            text = str(config_info.get('text', ''))
            for line in text.split('\n'):
                if len(line) > width:
                    width = len(line)
            for config_info in config_info.get('selections', []):
                text = str(config_info.get('text', ''))
                for line in text.split('\n'):
                    if len(line) > width:
                        width = len(line)
        return width

    def has_tabnames(self):
        if self.tabcount > 0:
            return True

        children = self.config_info['contains']
        for child in children:
            tabname = child.get('tabname', None)
            if child.get('item', None) == 'group' and tabname != None:
                self.tabcount += 1
        if self.tabcount > 0 and self.tabcount != len(children):
            raise Exception('Error: Some, but not all contained items specify a tabname')

        return self.tabcount > 0

class Page(Container):
    pages = {}
    name_stack = []
    top = None

    @staticmethod
    def show_page(page_name):
        if len(Page.name_stack) > 0:
            #            current_page_name = Page.name_stack[-1]
            #current_page = Page.pages[current_page_name]
            #current_page.hide()
            Page.current().hide()
        if page_name in Page.pages:
            Page.name_stack.append(page_name)
            Page.pages[page_name].show()
        else:
           raise Exception("Page:'{name}' not found.".format(name=page_name))


    @staticmethod
    def current():
        if len(Page.name_stack) == 0:
            return None
        return Page.pages[Page.name_stack[-1]]

    @staticmethod
    def show_previous():
        if len(Page.name_stack) < 2:
            return
        current_page_name = Page.name_stack.pop()
        page_name = Page.name_stack.pop()
        Page.name_stack.append(current_page_name)
        Page.show_page(page_name)

    @staticmethod
    def main():
        first_page_name = list(Page.pages.keys())[0]
        return Page.pages[first_page_name]

    def __init__(self, config_info):
        required = ['item', 'name', 'contains']
        optional = ['columns', 'childwidth', 'label_font', 'button_font']
        validate_options(config_info, required, optional)

        self.server = Server.k4_server

        super().__init__(config_info, None)

        self.name = config_info['name']
        Page.pages[self.name] = self

        self.top_frame = tk.Frame(Page.top)
        self.top_frame.grid(row=0, column=0, sticky='w')

        if self.has_tabnames():
            self.frame = self.notebook_frame(self.top_frame)
        else:
            self.frame = tk.Frame(self.top_frame)

        self.show_widgets()

    def on_tab_changed(self, event):
        super().on_tab_changed(event)
        if self.current_tabname == 'Main':
            Page.top.bind('<space>', self.toggle_tr)
        else:
            Page.top.unbind('<space>')

    def toggle_tr(self, event):
        if self.k4param('TR') == 'T':
            self.server.send_cmds('TRR;')
        else:
            self.server.send_cmds('TRT;')

    def set_geometry(self):
        Page.top.update_idletasks()
        screen_width = Page.top.winfo_screenwidth()
        screen_height = Page.top.winfo_screenheight()
        w, h = self.top_frame.winfo_width(), self.frame.winfo_height()
        Server.settings.load()
        geometry = Server.settings.get('Window', 'root.geometry')
        if geometry != None:
            _w, _h, x, y = split_geometry(geometry)
        else:
            # center the main window
            x = screen_width // 2 - w // 2
            y = screen_height // 2 - h // 2
        x_offset = screen_width - (x + w)
        y_offset = screen_height - (y + h)
        if x_offset < 0:
            x += x_offset
        if y_offset < 0:
            y += y_offset
        if x < 0:
            x = 0
        if y < 0:
            y = 0
        geometry = f'{w}x{h}{x:+}{y:+}'
        Page.top.geometry(geometry)

    def show(self):
        self.frame.grid()
        if self == Page.main():
            self.set_geometry()
            Page.top.focus_set()

    def hide(self):
        self.frame.grid_forget()

    def label_font(self):
        font = self.config_info.get('label_font', Default.label_font)
        return tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])

    def button_font(self):
        font = self.config_info.get('button_font', Default.button_font)
        return tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])

class Group(Container):
    def __init__(self, config_info, container):
        required = ['item', 'contains']
        optional = ['columns', 'column', 'columnspan', 'rowspan', 'childwidth',
            'sticky', 'label_font', 'button_font', 'tabname', 'label', 'leading',
            'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)
        self.tabname = config_info.get('tabname', '')

        self.show_widgets()

        if isinstance(container.frame, ttk.Notebook):
            container.add_tab(self.outer_frame, self.tabname)

class ButtonWidget():
    def __init__(self, caller, frame, options):
        self.caller = caller
        self.server = caller.server

        font = options['font']
        width = options['width']
        bg = options['bg']
        fg = options['fg']
        abg = options['abg']
        afg = options['afg']

        text = str(options.get('text', ''))
        cmd = options.get('cmd', None)
        justify = options.get('justify', 'center')

        if cmd != None:
            command = lambda: self.server.expand_and_send_cmds(cmd)

        button = tk.Button(frame,
                    bd='2',
                    text=text,
                    font=font,
                    width=width,
                    justify=justify,
                    relief='raised',
                    fg=fg,
                    bg=bg,
                    activebackground=abg,
                    activeforeground=afg,
                    padx=2,
                    pady=2,
                    command=command)

        button.grid(row=0, column=0, sticky='w')

class Button(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        optional = ['text', 'cmd', 'bg', 'abg', 'fg', 'afg', 'justify', 'font',
            'label', 'leading', 'button_font', 'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        config_info['font'] = self.font()
        config_info['bg'] = self.bg
        config_info['fg'] = self.fg
        config_info['abg'] = config_info.get('abg', self.bg)
        config_info['afg'] = config_info.get('afg', self.fg)
        config_info['width'] = container.items_width()

        ButtonWidget(self, self.frame, config_info)

class ToggleWidget():
    def __init__(self, caller, frame, options):
        self.caller = caller
        self.server = caller.server

        font = options['font']
        width = options['width']

        self.wraparound = true_values(options.get('wraparound', True))
        self.justify = options.get('justify', 'left')
        self.index = int(options.get('initialindex', 0))

        self.blink_state = False

        self.selections = []

        selection_options = options.get('selections', None)
        for sel_opt in selection_options:
            index = len(self.selections)
            selection = {}

            required = []
            optional = ['text', 'cmd', 'evalcmd', 'response', 'evalresponse', 'bg', 'abg', 'fg', 'afg', 'blink', 'font', 'button_font', 'hidden']
            validate_options(sel_opt, required, optional, name='togglebutton.selection')

            selection['text'] = sel_opt.get('text', '')

            cmd = sel_opt.get('cmd', None)
            orig_response = sel_opt.get('response', cmd)
            selection['response'] = orig_response

            selection['parameters'] = {}

            if orig_response != None:
                responses = self.server.expand_server_cmds(orig_response)
                for response in responses:
                    base = cmd_base(response)
                    response = response[len(base):]
                    selection['parameters'][base] = response

            selection['cmd'] = cmd
            selection['bg'] = sel_opt.get('bg', Default.bg)
            selection['fg'] = sel_opt.get('fg', Default.fg)
            selection['abg'] = sel_opt.get('abg', Default.abg)
            selection['afg'] = sel_opt.get('afg', Default.afg)
            if selection['afg'] == None:
                selection['afg'] = selection['fg']
            selection['blink'] = sel_opt.get('blink', False)
            selection['evalcmd'] = sel_opt.get('evalcmd', None)
            selection['evalresponse'] = sel_opt.get('evalresponse', None)
            selection['hidden'] = true_values(sel_opt.get('hidden', False))
            self.selections.append(selection)

        self.button = tk.Button(frame,
                    bd='2',
                    font=font,
                    width=width,
                    relief='raised',
                    padx=2,
                    pady=2,
                    command=self.do_selection)
        self.button.grid(row=0, column=0, sticky='w')

        self.configure()

        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        for selection in self.selections:
            response = selection['response']
            if response != None:
                self.server.subscribe_responses(response, self.on_response_received)

    def configure(self):
        selection = self.selections[self.index]
        self.button.configure(
                    text=selection['text'],
                    fg=selection['fg'],
                    bg=selection['bg'],
                    activebackground=selection['abg'],
                    activeforeground=selection['afg'],
                    justify=self.justify)
        if selection['blink']:
            self.blinkon(selection)
        else:
            self.blinkoff(selection)

    def next_selection(self):
        while True:
            self.index += 1
            if self.index >= len(self.selections):
                if self.wraparound:
                    self.index = 0
                else:
                    self.index = len(self.selections) - 1

            selection = self.selections[self.index]
            if not selection['hidden']:
                break

        self.configure()

    def do_selection(self):
        self.button.focus_set()
        self.next_selection()
        self.configure()

        selection = self.selections[self.index]
        cmd = selection['cmd']
        evalcmd = selection['evalcmd']
        if evalcmd != None:
            cmd = self.caller.eval_value(evalcmd)
        if cmd != None:
            self.server.expand_and_send_cmds(cmd)

    def compare_parameters(self, selection):
        text = selection['text']
        parameters = selection['parameters']
        for base in parameters.keys():
            k4_parameter = self.caller.k4param(base)
            if selection['evalresponse'] != None and k4_parameter != None:
                k4_parameter = self.caller.eval_value(selection['evalresponse'], base + k4_parameter + ';')[len(base):].rstrip(';')
            dprint2('compare :{text} s: {s}, b: {b}'.format(text=text, s=k4_parameter, b=parameters[base]))
            if parameters[base] != k4_parameter:
                dprint2(text, 'No match')
                return False
        dprint2(text, 'Match')
        return True

    def on_response_received(self, response):
        for index, selection in enumerate(self.selections):
            if self.compare_parameters(selection):
                self.index = index
                self.configure()

    def blinkon(self, selection):
        Poll.add(Widget.blink_mS, self.blink)

    def blinkoff(self, selection):
        Poll.remove(self.blink)

    def blink(self):
        selection = self.selections[self.index]
        self.blink_state = not self.blink_state
        if self.blink_state:
            self.button.configure(bg=selection['fg'], fg=selection['bg'])
        else:
            self.button.configure(bg=selection['bg'], fg=selection['fg'])

class Togglebutton(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        optional = ['wraparound', 'justify', 'selections', 'label', 'leading', 'width',
            'padx', 'pady', 'initialindex']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        config_info['caller'] = self
        config_info['server'] = self.server
        config_info['font'] = self.font()
        if not 'width' in config_info:
            config_info['width'] = container.items_width()

        ToggleWidget(self, self.frame, config_info)

class Radiobutton(Widget):
    variables = {}
    button_counter = 0

    def __init__(self, config_info, container):
        required = ['item', 'groupid']
        optional = ['text', 'cmd', 'response', 'indicator', 'selectcolor', 'label',
            'leading', 'bg', 'abg', 'fg', 'afg', 'blink', 'font', 'button_font',
            'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        Radiobutton.button_counter += 1

        self.text = str(config_info.get('text', ''))
        self.cmd = config_info.get('cmd', None)
        self.response = config_info.get('response', self.cmd)
        indicator = config_info.get('indicator', 1)
        selectcolor = config_info.get('selectcolor', Default.selectcolor)
        self.blink = config_info.get('blink', False)
        self.blink_state = False
        self.group_id = config_info.get('groupid', None)

        self.parameters = {}

        if not self.group_id in Radiobutton.variables:
            Radiobutton.variables[self.group_id] = tk.StringVar
        variable = Radiobutton.variables[self.group_id]

        width = container.items_width()

        self.button = tk.Radiobutton(self.frame,
                    bd='2',
                    text=self.text,
                    font=self.font(),
                    width=width,
                    relief='raised',
                    fg=self.fg,
                    bg=self.bg,
                    activebackground=self.abg,
                    activeforeground=self.afg,
                    padx=2,
                    pady=2,
                    command=self.on_clicked,
                    indicator=indicator,
                    selectcolor=selectcolor,
                    variable=variable,
                    value=Radiobutton.button_counter)

        self.button.grid(row=0, column=0, sticky='w')

        cmds = self.server.expand_server_cmds(self.cmd)
        responses = self.server.expand_server_cmds(self.response)
        for response in responses:
            base = cmd_base(response)
            response = response[len(base):]
            self.parameters[base] = response

        self.server.subscribe_responses(self.response, self.on_response_received)

    def on_clicked(self):
        if self.cmd != None:
            self.server.expand_and_send_cmds(self.cmd)

    def compare_parameters(self, group, text):
        parameters = self.parameters
        for base in parameters.keys():
            dprint2('compare {group}:{text} s: {s}, b: {b}'.format(group=group, text=text, s=self.k4param(base), b=parameters[base]))
            if parameters[base] != self.k4param(base):
                dprint2(text, 'No match')
                return False
        dprint2(text, 'Match')
        return True

    def on_response_received(self, response):
        if self.compare_parameters(self.group_id, self.text):
            self.button.select()
            if self.blink:
                self.blinkon()
        else:
            self.button.deselect()
            if self.blink:
                self.blinkoff()

    def blinkon(self):
        Poll.add(Widget.blink_mS, self.blink)

    def blinkoff(self):
        Poll.remove(self.blink)

    def blink(self):
        self.blink_state = not self.blink_state
        if self.blink_state:
            self.button.select()
        else:
            self.button.deselect()

class VFO(Widget):
    step = (1, 10, 100, 1000, 10000)
    step_index = {1: 0, 10: 1, 100: 2, 1000: 3, 10000:4}
    low_frequency_limit=100000
    high_frequency_limit=54000000

    def __init__(self, config_info, container):
        required = ['item', 'AorB']
        optional = ['width', 'activecolor', 'transmitcolor', 'label', 'leading',
            'bg', 'abg', 'fg', 'afg', 'blink', 'font', 'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        self.AorB = config_info.get('AorB', 'A').upper()

        self.width = config_info.get('width', 9)

        self.step_text_index = {}
        for i, step in enumerate(VFO.step):
            text_index = f'1.{self.width-i-(1 if i < 3 else 2)}'
            self.step_text_index[step] = text_index

        self.active_color = config_info.get('activecolor', self.bg)
        self.transmit_color = config_info.get('transmitcolor', self.bg)

        self.freq = 14100000
        self.step = 100

        frame = tk.Frame(self.frame)
        frame.grid(row=0, column=0, sticky='w')

        self.tb = tk.Text(frame, bd=2, bg='pink', fg='black', font=self.font(), height=1, width=self.width, cursor='hand2', wrap=tk.NONE)
        tb = self.tb
        tb.grid(row=0, column=0, sticky='w')

        for event in ('<Return>', '<FocusOut>'):
            tb.bind(event, lambda event : self.validate_frequency(event, send=True))

        for key in ('<Left>', '<Right>', '<KP_Left>', '<KP_Right>'):
            tb.bind(key, self.on_change_step)
        for key in ('<Up>', '<Down>', '<KP_Up>', '<KP_Down>'):
            tb.bind(key, self.on_bump_frequency)
        for key in ('<Next>', '<Prior>', '<KP_Next>', '<KP_Prior>'):
            tb.bind(key, self.on_jump_frequency)
        tb.bind('<ButtonRelease-2>', lambda event: self.validate_frequency(event, send=False))
        if sys.platform in ('win32', 'darwin'):
            mouse_buttons = ('<MouseWheel>',)
        elif sys.platform == 'linux':
            mouse_buttons = ('<Button-4>', '<Button-5>')
        for button in mouse_buttons:
            tb.bind(button, self.on_mouse_wheel)

        tb.bind('<Key>', self.on_keypress)
        tb.bind('<KeyRelease>', self.on_keyrelease)

        for step in VFO.step:
            tb.tag_bind(f'step_{step}', '<Button-1>', lambda response, step=step: self.on_button_one(step))

        tb.tag_config('underline', underline=1)
        tb.tag_config('right_justify', justify=tk.RIGHT)

        self.add_tags()

        step_cmd = f'VT{"$" if self.AorB == "B" else ""};'
        self.server.subscribe_response(step_cmd, self.on_step_received)
        self.server.subscribe_response(f'F{self.AorB};', self.on_frequency_received)
        # subscribe to split and transmit on/off changes
        self.server.subscribe_responses('FT;TR;', self.set_vfo_bg)
        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        self.set_vfo_bg()

    def on_keypress(self, event):
        keys = ('Left', 'Right', 'KP_Left', 'KP_Right',
            'Up', 'Down', 'KP_Up', 'KP_Down',
            'Next', 'Prior', 'KP_Next', 'KP_Prior',
            'BackSpace', 'period', 'Return', 'space',
            'Delete')
        keysym = event.keysym
        if keysym in '0123456789' or keysym in keys:
            return
        return 'break'

    def on_keyrelease(self, event):
        if event.keysym == 'space':
            self.validate_frequency(send=False)

    def on_button_one(self, step):
        self.set_step(step)

    def add_tags(self):
        for step in VFO.step:
            self.tb.tag_add(f'step_{step}', self.step_text_index[step])
        for i in range(0, self.width-len(VFO.step)-1):
            self.tb.tag_add(f'step_{VFO.step[len(VFO.step)-1]}', f'1.{i}')
        self.tb.tag_add('right_justify', '1.0')
        self.add_underline_tag()

    def add_underline_tag(self):
        self.tb.tag_remove('underline', '1.0', '1.0 lineend')
        self.tb.tag_add('underline', self.step_text_index[self.step])

    def validate_frequency(self, event=None, send=False):
        if self.tb.edit_modified():
            self.add_tags()
            self.tb.edit_modified(False)
        try:
            freq = round(float(self.tb.get('1.0', '1.0 lineend')) * 1000)
        except:
            freq = self.freq
            self.set_frequency(freq, send=False)
            return
        self.set_frequency(freq, send=send)
        return 'break'

    def set_frequency(self, freq, send=False):
        if freq < VFO.low_frequency_limit:
            freq = VFO.low_frequency_limit
        if freq > VFO.high_frequency_limit:
            freq = VFO.high_frequency_limit
        freq_str = f'{freq / 1000:12.3f}'[12-self.width:]
        if freq_str != self.tb.get('1.0', '1.0 lineend'):
            cursor_index = self.tb.index(tk.INSERT)
            self.tb.delete('1.0', '1.0 lineend')
            self.tb.insert('1.0', freq_str)
            if cursor_index != f'1.{self.width+1}':
                cursor_index += '-1c'
            self.tb.mark_set(tk.INSERT, cursor_index)
            self.add_tags()
        if send:
            cmd = f'F{self.AorB}{freq:011.0f};'
            self.server.send_cmds(cmd)
        self.freq = freq
        self.set_vfo_bg()

    def on_frequency_received(self, response):
        freq = cmd_parameter(response)
        self.set_frequency(float(freq))

    def set_step(self, step):
        self.step = step
        self.add_underline_tag()
        suffix = '$' if self.AorB == 'B' else ''
        index = VFO.step_index[step]
        mode = self.current_mode_index()
        cmd = f'VT{suffix}{index}{mode};'
        self.server.send_cmds(cmd)

    def on_step_received(self, response):
        step_str = cmd_parameter(response)
        step_index = int(step_str[0])
        if step_index == 5:                             # Work around an apparent K4 bug
            cmd = f'VT{"$" if self.AorB == "B" else ""}2;'
            self.server.send_cmds(cmd)
            step_index = 2
        self.set_step_index(step_index)

    def set_step_index(self, step_index):
        if step_index < 0:
            step_index = 0
        elif step_index > 4:
            step_index = 4
        self.step = VFO.step[step_index]
        self.add_underline_tag()

    def on_change_step(self, event):
        step_index = VFO.step_index[self.step]
        if event.keysym in ('Left', 'KP_Left'):
            step_index += 1
        else:
            step_index -= 1
        self.set_step_index(step_index)

    def adjust_frequency(self, step):
        freq = self.freq + step
        mod = freq % self.step
        freq -= mod
        if mod != 0 and step < 0:
            freq -= step
        self.set_frequency(freq, send=True)

    def on_bump_frequency(self, event):
        step = self.step
        if event.keysym in ('Down', 'KP_Down'):
            step = -step
        self.adjust_frequency(step)

    def on_jump_frequency(self, event):
        orig_step = self.step
        step_index = VFO.step_index[self.step]
        if step_index < 4:
            step_index += 1
        step = VFO.step[step_index]
        if event.keysym in ('Next', 'KP_Next'):
            step = -step
        self.set_frequency(self.freq + step, send=True)
        self.add_underline_tag()

    def on_mouse_wheel(self, event):
        step = self.step * mouse_wheel_mult(event)
        self.adjust_frequency(step)

    def current_mode_index(self):
        base = f'MD{"$" if self.AorB == "B" else ""}'
        return self.k4param(base)

    def transmit_vfo(self):
        split = self.k4param('FT') == '1'
        return 'B' if split else 'A'

    def set_vfo_bg(self, arg=None):
        if self.AorB == self.transmit_vfo():
            if self.k4param('TR') == 'T':
                self.tb.configure(bg=self.transmit_color)
            else:
                self.tb.configure(bg=self.active_color)
        else:
            self.tb.configure(bg=self.bg)

class RIT(Widget):
    step = (1, 10, 100, 1000)
    step_index = {1: 0, 10: 1, 100: 2, 1000: 3}
    low_offset_limit=-9999
    high_offset_limit=9999

    def __init__(self, config_info, container):
        required = ['item', 'AorB']
        optional = ['width', 'ritcolor', 'xitcolor', 'ritxitcolor', 'label',
            'leading', 'bg', 'abg', 'fg', 'afg', 'blink', 'font', 'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        self.AorB = config_info.get('AorB', 'A').upper()
        self.suffix = '' if self.AorB == 'A' else '$'

        self.width = 6

        self.step_text_index = {}
        for i, step in enumerate(RIT.step):
            text_index = f'1.{self.width-i-(1 if i < 3 else 2)}'
            self.step_text_index[step] = text_index

        self.rit_color = config_info.get('ritcolor', self.bg)
        self.xit_color = config_info.get('xitcolor', self.bg)
        self.ritxit_color = config_info.get('ritxitcolor', self.bg)

        self.offset = 0
        self.step = 1000
        step_index = 3

        frame = tk.Frame(self.frame)
        frame.grid(row=0, column=0, sticky='w')

        self.tb = tk.Text(frame, bd=2, bg='pink', fg='black', font=self.font(), height=1, width=self.width, cursor='hand2', wrap=tk.NONE)
        tb = self.tb
        tb.grid(row=0, column=0, sticky='w')

        for event in ('<Return>', '<FocusOut>'):
            tb.bind(event, self.validate_offset)

        for key in ('<Left>', '<Right>', '<KP_Left>', '<KP_Right>'):
            tb.bind(key, self.on_change_step)
        for key in ('<Up>', '<Down>', '<KP_Up>', '<KP_Down>'):
            tb.bind(key, self.on_bump_offset)
        for key in ('<Next>', '<Prior>', '<KP_Next>', '<KP_Prior>'):
            tb.bind(key, self.on_jump_offset)
        if sys.platform in ('win32', 'darwin'):
            mouse_buttons = ('<MouseWheel>',)
        elif sys.platform == 'linux':
            mouse_buttons = ('<Button-4>', '<Button-5>')
        for button in mouse_buttons:
            tb.bind(button, self.on_mouse_wheel)

        for step in RIT.step:
            tb.tag_bind(f'step_{step}', '<Button-1>', lambda response, step=step: self.on_button_one(step))

        tb.tag_config('underline', underline=1)
        tb.tag_config('right_justify', justify=tk.RIGHT)

        self.add_tags()

        self.set_step_index(step_index)

#        self.server.subscribe_response(f'VT{self.suffix};', self.on_step_received)
        self.server.subscribe_response(f'RO{self.suffix};', self.on_offset_received)
        # subscribe to split and transmit on/off changes
        cmds = f'RT{self.suffix};XT;FT;TR;'
        self.server.subscribe_responses(cmds, self.set_rit_bg)
        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        self.set_rit_bg()

    def on_button_one(self, step):
        self.set_step(step)

    def add_tags(self):
        for step in RIT.step:
            self.tb.tag_add(f'step_{step}', self.step_text_index[step])
        self.tb.tag_add('right_justify', '1.0')
        self.add_underline_tag()

    def add_underline_tag(self):
        self.tb.tag_remove('underline', '1.0', '1.0 lineend')
        self.tb.tag_add('underline', self.step_text_index[self.step])

    def validate_offset(self, event):
        if self.tb.edit_modified():
            self.add_tags()
            self.tb.edit_modified(False)
        try:
            offset = int(round(float(self.tb.get('1.0', '1.0 lineend')) * 1000))
            self.set_offset(offset)
            if offset < RIT.low_offset_limit:
                offset = RIT.low_offset_limit
            if freq > RIT.high_offset_limit:
                offset = RIT.high_offset_limit
        except:
            self.set_offset(self.offset)
        return 'break'

    def set_offset(self, offset):
        offset_str = f'{float(offset) / 1000:+2.3f}'
        if offset_str != self.tb.get('1.0', '1.0 lineend'):
            self.tb.delete('1.0', '1.0 lineend')
            self.tb.insert('1.0', offset_str)
            self.add_tags()
        if offset != self.offset:
            self.offset = offset
            self.send_offset(offset)
        self.set_rit_bg()

    def send_offset(self, offset):
        cmd = f'RO{self.suffix}{offset:+05d};'
        self.server.send_cmds(cmd)

    def on_offset_received(self, response):
        offset = cmd_parameter(response)
        self.set_offset(int(offset))

    def set_step(self, step):
        self.step = step
        self.add_underline_tag()

    def set_step_index(self, step_index):
        if step_index < 0:
            step_index = 0
        elif step_index > 3:
            step_index = 3
        self.step = RIT.step[step_index]
        self.add_underline_tag()

    def on_change_step(self, event):
        step_index = RIT.step_index[self.step]
        if event.keysym in ('Left', 'KP_Left'):
            step_index += 1
        else:
            step_index -= 1
        self.set_step_index(step_index)

    def adjust_offset(self, step):
        offset = self.offset + step
        mod = offset % self.step
        offset -= mod
        if mod != 0 and step < 0:
            offset -= step
        self.set_offset(offset)

    def on_bump_offset(self, event):
        step = self.step
        if event.keysym in ('Down', 'KP_Down'):
            step = -step
        self.adjust_offset(step)

    def on_jump_offset(self, event):
        orig_step = self.step
        step_index = RIT.step_index[self.step]
        if step_index < 3:
            step_index += 1
        step = RIT.step[step_index]
        if event.keysym in ('Next', 'KP_Next'):
            step = -step
        self.set_offset(self.offset + step)
        self.add_underline_tag()

    def on_mouse_wheel(self, event):
        step = self.step * mouse_wheel_mult(event)
        self.adjust_offset(step)

    def current_mode_index(self):
        base = f'MD{self.suffix}'
        return self.k4param(base)

    def transmit_vfo(self):
        split = self.k4param('FT') == '1'
        return 'B' if split else 'A'

    def set_rit_bg(self, arg=None):
        rit_on = self.k4param(f'RT{self.suffix}') == '1'
        xit_on = self.k4param(f'XT') == '1'

        if rit_on:
            if xit_on and self.AorB == self.transmit_vfo():
                self.tb.configure(bg=self.ritxit_color)
            else:
                self.tb.configure(bg=self.rit_color)
        else:
            if xit_on and self.AorB == self.transmit_vfo():
                self.tb.configure(bg=self.xit_color)
            else:
                self.tb.configure(bg=self.bg)

class SliderWidget():
    def __init__(self, caller, frame, options):
        self.caller = caller
        self.server = caller.server

        self.bg = options['bg']
        self.fg = options['fg']
        font = options['font']

        self.from_ = options['from']
        self.to = options['to']
        self.evalcmd = options['evalcmd']
        self.evalresponse = options['evalresponse']
        orient = options.get('orient', 'horizontal')
        self.evalincrement = options.get('evalincrement', 1.0)
        showvalue = options.get('showvalue', True)
        width = options.get('width', 15)
        length = options.get('length', 100)
        self.eval_length = options.get('evallength', None)
        self.label = options.get('label', None)

        self.value_var = tk.DoubleVar()
        self.value_var.set(0.0)
        self.previous_value = 0.0

        from_ = self.caller.eval_value(self.from_, self.value_var.get())
        to = self.caller.eval_value(self.to, self.value_var.get())
        self.resolution = self.caller.eval_value(self.evalincrement, self.value_var.get())

        self.scale = tk.Scale(frame,
                         from_=from_,
                         to=to,
                         resolution=self.resolution,
                         orient=orient,
                         repeatdelay=0,
                         width=width,
                         length=length,
                         showvalue=showvalue,
                         font=font,
                         bg=self.bg,
                         fg=self.fg,
                         bd=2,
                         variable=self.value_var)
        self.scale.grid(row=0, column=0, sticky='nw')

        self.value_var.trace('w', self.value_changed)

        if sys.platform in ('win32', 'darwin'):
            mouse_buttons = ('<MouseWheel>',)
        elif sys.platform == 'linux':
            mouse_buttons = ('<Button-4>', '<Button-5>')
        for button in mouse_buttons:
            self.scale.bind(button, self.on_mouse_wheel)

        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        self.scale.update_idletasks()
        cmd = self.caller.eval_value(self.evalcmd, self.value_var.get())
        if cmd != "":
            self.server.subscribe_response(cmd, self.on_response_received)
        if self.eval_length != None:
            length = self.caller.eval_value(self.eval_length)
            if self.label != None:
                length -= 8             # account for width of the LabelFrame
            self.scale.config(length=length)

    def on_mouse_wheel(self, event):
        incr = self.resolution * mouse_wheel_mult(event)
        value = round(self.value_var.get() + incr, 10)
        self.value_var.set(value)

    def value_changed(self, var, index, mode):
        value = self.value_var.get()
        next_value = value
        if self.previous_value == value:
            return
        if self.previous_value < value:
            next_value = value + self.caller.eval_value(self.evalincrement, value)
        self.resolution = self.caller.eval_value(self.evalincrement, next_value)
        self.scale.configure(resolution=self.resolution)
        cmd = self.caller.eval_value(self.evalcmd, value)
        self.previous_value = value
        self.server.send_cmds(cmd)

    def on_response_received(self, response):
        value = float(self.caller.eval_value(self.evalresponse, response))
        if value < 0:
            return
        self.resolution = self.caller.eval_value(self.evalincrement, value)
        self.scale.configure(resolution=self.resolution)
        self.scale.configure(from_=self.caller.eval_value(self.from_, value), to=self.caller.eval_value(self.to, value))
        self.value_var.set(value)
        self.previous_value = value

class Slider(Widget):
    def __init__(self, config_info, container):
        required = ['item', 'evalcmd', 'from', 'to', 'evalresponse']
        optional = ['orient', 'width', 'length', 'evallength', 'evalincrement',
            'showvalue', 'label', 'leading', 'bg', 'abg', 'fg', 'afg', 'font',
            'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        config_info['caller'] = self
        config_info['server'] = self.server
        config_info['font'] = self.font()
        config_info['bg'] = self.bg
        config_info['fg'] = self.fg

        SliderWidget(self, self.frame, config_info)

class Getvalue(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        optional = ['cmd', 'response', 'evalresponse', 'label', 'leading',
            'bg', 'abg', 'fg', 'afg', 'font', 'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        cmd = config_info.get('cmd', None)
        response = config_info.get('response', cmd)
        self.evalresponse = config_info.get('evalresponse', cmd)
        justify = config_info.get('justify', 'center')

        self.server.expand_and_send_cmds(cmd)

        self.label = tk.Label(self.frame,
                    bd='2',
                    font=sef.font(),
                    justify=justify,
                    fg=self.fg,
                    bg=self.bg,
                    activebackground=self.abg,
                    activeforeground=self.afg,
                    padx=2,
                    pady=2)

        self.label.grid(row=0, column=0, sticky='w')

        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        self.server.subscribe_response(response, self.on_response_received)

    def on_response_received(self, response):
        value = self.eval_value(self.evalresponse, response)
        self.label.configure(text=value)

class Bargraph(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        optional = ['cmd', 'response', 'evalresponse', 'orient', 'maximum',
            'evalmaximum', 'length', 'lengthpercent', 'lefttext', 'bottomtext',
            'evalbottomtext', 'label', 'leading', 'bg', 'abg', 'fg', 'afg',
            'font', 'id', 'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        self.cmd = config_info.get('cmd', None)
        self.response = config_info.get('response', self.cmd)
        self.evalresponse = config_info.get('evalresponse', self.response)
        orient = config_info.get('orient', 'horizontal')
        self.maximum = config_info.get('maximum', 100)
        self.evalmaximum = config_info.get('evalmaximum', None)
        self.length = config_info.get('length', 100)
        self.length_percent = config_info.get('lengthpercent', None)

        self.left_text = config_info.get('lefttext', '')
        self.bottomtext = config_info.get('bottomtext', '')
        self.evalbottomtext = config_info.get('evalbottomtext', None)

        bar_frame = tk.Frame(self.frame)

        self.left_frame = tk.Frame(bar_frame)
        if self.left_text != '':
            left_label = tk.Label(self.left_frame,
                text=self.left_text,
                bd=0,
                font=self.font(),
                justify='left',
                fg=self.fg,
                bg=self.bg,
                activebackground=self.abg,
                activeforeground=self.afg,
                padx=0,
                pady=2)

            left_label.grid(row=0, column=0, sticky='w')
        self.left_frame.grid(row=0, column=0, sticky='w')

        self.progressvalue = tk.IntVar()
        self.progressbar = ttk.Progressbar(bar_frame,
                    orient=orient,
                    variable=self.progressvalue,
                    maximum=self.maximum + .001,
                    length=self.length)

        self.progressbar.grid(row=0, column=1, sticky='w')

        bar_frame.grid(row=0, column=0, sticky='w')

        self.bottom_frame = tk.Frame(self.frame)
        if self.bottomtext != None or self.evalbottomtext != None:
            self.bottom_label = tk.Label(self.bottom_frame,
                text=self.bottomtext,
                bd=0,
                font=self.font(),
                justify='left',
                fg=self.fg,
                bg=self.bg,
                activebackground=self.abg,
                activeforeground=self.afg,
                padx=0,
                pady=2)

            self.bottom_label.grid(row=0, column=0, sticky='w')
        self.bottom_frame.grid(row=1, column=0, sticky='w')

        self.server.subscribe_connect(self.on_server_connect)
        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_server_connect(self):
        self.frame.bind('<Visibility>', self.configure)
        self.server.expand_and_send_cmds(self.cmd)

    def on_received_initial_parameters(self, response):
        self.server.subscribe_response(self.response, self.on_response_received)

    def on_response_received(self, response):
        value = int(self.eval_value(self.evalresponse, response))
        self.progressvalue.set(value)
        if self.server.connected:
            self.configure()

    def configure(self, event=None):
        bottomtext = self.bottomtext
        if self.evalbottomtext != None:
            bottomtext = self.eval_value(self.evalbottomtext, None)
        self.bottom_label.configure(text=bottomtext)
        try:
            if self.bottom_label.winfo_viewable():
                self.bottom_frame.update()
            bottom_width = self.bottom_frame.winfo_width()
            left_width = self.left_frame.winfo_width()
        except:
            bottom_width = 20
            left_width = 20
        length = self.length
        if self.length_percent != None:
            length = (bottom_width - left_width) * self.length_percent / 100.0
        maximum = self.maximum
        if self.evalmaximum != None:
            maximum = float(self.eval_value(self.evalmaximum, None)) + .001
        self.progressbar.configure(length=length, maximum=maximum)

class Text(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        optional = ['text', 'evaltext', 'label', 'leading', 'fg', 'bg',
            'justify', 'font', 'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        text = config_info.get('text', '')
        evaltext = config_info.get('evaltext', None)
        justify = config_info.get('justify', 'center')

        if evaltext != None:
            text = self.eval_value(evaltext)

        lines = text.split("\n")
        height = len(lines)
        width = 0
        for line in lines:
            if len(line) > width:
                width = len(line)

        self.label = tk.Label(self.frame,
                    text=text,
                    height=height,
                    width=width,
                    bd='2',
                    font=self.font(),
                    justify=justify,
                    fg=self.fg,
                    bg=self.bg,
                    padx=2,
                    pady=2)

        self.label.grid(row=0, column=0, sticky='w')

class Notebook(Container):
    def __init__(self, config_info, container):
        required = ['item', 'contains']
        optional = ['server', 'childwidth', 'label_font', 'button_font']

        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        if not self.has_tabnames():
            raise Exception('notebook contains items without tabnames')

        self.frame = None
        self.show_widgets()

        notebook = ttk.Notebook(self.frame)
        notebook.grid()

        for child in self.children:
            if not isinstance(child, Group):
                raise Exception('Notebook contains an item that is not a group', child)
            self.add_tab(child.frame, child.tabname)

class DropdownWidget():
    def __init__(self, caller, frame, options):
        self.caller = caller
        self.server = caller.server

        texts = []
        self.text_to_index = {}

        self.index = 0

        self.selections = []

        self.bg = options['bg']
        self.fg = options['fg']

        font = options['font']
        justify = options.get('justify', 'right')
        height = options.get('height', 0)
        self.from_ = options.get('from', None)
        self.to = options.get('to', None)
        self.evalincrement = options.get('evalincrement', None)
        self.evalcmd = options.get('evalcmd', None)

        self.unexpected_response = options.get('unexpectedresponse', '')

        width = 0

        selection_options = options.get('selections', None)
        for index, sel_opt in enumerate(selection_options):
            index = len(self.selections)
            selection = {}

            required = []
            optional = ['text', 'cmd', 'evalcmd', 'response', 'evalresponse', 'bg']
            validate_options(sel_opt, required, optional, name='dropdownbutton.selection')

            text = sel_opt.get('text', '')
            selection['text'] = text
            texts.append(text)
            self.text_to_index[text] = index
            if len(text) > width:
                width = len(text)

            cmd = sel_opt.get('cmd', None)
            orig_response = sel_opt.get('response', cmd)
            selection['response'] = orig_response

            selection['parameters'] = {}
            responses = self.server.expand_server_cmds(orig_response)
            for response in responses:
                base = cmd_base(response)
                response = response[len(base):]
                selection['parameters'][base] = response

            selection['cmd'] = cmd
            evalcmd = sel_opt.get('evalcmd', None)
            selection['evalcmd'] = evalcmd
            selection['evalresponse'] = sel_opt.get('evalresponse', None)
            bg = sel_opt.get('bg', None)
            if bg == None:
                bg = self.bg
            selection['bg'] = bg
            self.selections.append(selection)
        width += 1

        if 'width' in options:
            width = options['width']

        if height == 0:
            height = len(texts)

        self.defer_selections = False
        self.deferred_selection = False

        # Define the style for this dropdown widget
        self.stylename = str(self) + '.TCombobox'
        self.style = ttk.Style()
        self.style.theme_use('alt')
        self.style.map(self.stylename, fieldbackground=[('readonly', self.bg)]),
        self.style.configure(self.stylename, background=self.bg, foreground=self.fg,
            selectbackground=self.bg, selectforeground=self.fg, padding=(2,2,2,2))

        state = 'readonly' if self.evalcmd == None else 'normal'
        no_space_wrapper = (Page.top.register(self.no_space), '%d', '%S')

        self.combobox = ttk.Combobox(
                frame,
                font=font,
                values=texts,
                height=height,
                width=width,
                state=state,
                justify=justify,
                style=self.stylename,
                validate='key',
                validatecommand=no_space_wrapper,
                )
        self.combobox.option_add('*TCombobox*Listbox*Font', font)
        self.combobox.option_add('*TCombobox*Listbox*Justify', 'center')
        if self.evalcmd != None:
            self.combobox.bind('<Return>', self.update_value)
            self.combobox.bind('<FocusOut>', self.update_value)

        if self.evalincrement != None:
            for key in ('<Up>', '<Down>', '<KP_Up>', '<KP_Down>'):
                self.combobox.bind(key, self.on_increment)

        self.combobox.bind('<<ComboboxSelected>>', self.on_combobox_selected)

        self.combobox.grid(row=0, column=0, sticky='e')

        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        for selection in self.selections:
            self.server.subscribe_responses(selection['response'], self.on_response_received)

    def on_increment(self, event):
        value = float(self.combobox.get())
        if event.keysym in ('Down', 'KP_down'):
            value -= .00000000001       # account for incr vs decr
        else:
            value += .00000000001
        incr = float(self.caller.eval_value(self.evalincrement, value))
        if event.keysym in ('Down', 'KP_down'):
            incr = -incr
        value += incr
        self.set_value(value)
        return 'break'

    def set_value(self, value):
        if self.server.warn_if_not_connected():
            return

        if value < self.from_:
            value = self.from_
        elif value > self.to:
            value = self.to
        if self.evalcmd != None:
            cmd = self.caller.eval_value(self.evalcmd, value)
        self.server.expand_and_send_cmds(cmd)

    def update_value(self, event):
        text = self.combobox.get().strip()
        try:
            value = float(text)
        except:
            return

        self.set_value(value)

    def set_val(self, value):
        self.combobox.state='normal'
        self.combobox.set(value)
        self.combobox.state='readonly'

    def undefer_selections(self):
        self.defer_selections = False
        if self.deferred_selection:
            self.on_combobox_selected()

    def on_combobox_selected(self, event=None):
        if self.server.warn_if_not_connected():
            return

        text = self.combobox.get()
        if text == '':
            return

        if self.defer_selections:
            self.deferred_selection = True
            Poll.call(1500, self.undefer_selections)
            return

        self.deferred_selection = False

        index = self.text_to_index.get(text, None)
        if index != None:
            self.index = index
            selection = self.selections[self.index]
            cmd = selection['cmd']
            evalcmd = selection['evalcmd']
            if evalcmd != None:
                cmd = self.caller.eval_value(evalcmd)
            if cmd != None:
                self.server.expand_and_send_cmds(cmd)

        self.defer_selections = True
        Poll.call(1500, self.undefer_selections)

    def compare_parameters(self, selection, response):
        response = response.rstrip(';')
        response_base = cmd_base(response)
        response_parameter = cmd_parameter(response)

        text = selection['text']
        parameters = selection['parameters']
        for base in parameters.keys():
            if base == response_base:
                k4_parameter = response_parameter
            else:
                k4_parameter = self.server.k4_parameter(base)
            if selection['evalresponse'] != None and k4_parameter != None:
                k4_parameter = self.caller.eval_value(selection['evalresponse'], base + k4_parameter + ';')[len(base):].rstrip(';')
            dprint2('compare :{text} s: {s}, b: {b}'.format(text=text, s=k4_parameter, b=parameters[base]))
            if parameters[base] != k4_parameter:
                dprint2(text, 'No match')
                return False
        dprint2(text, 'Match')
        return True

    def on_response_received(self, response):
        found = False
        for index, selection in enumerate(self.selections):
            if self.compare_parameters(selection, response):
                self.index = index
                self.set_val(selection['text'])
                self.style.map(self.stylename, fieldbackground=[('readonly', selection['bg'])])
                self.style.configure(self.stylename, background=selection['bg'])
                found = True
                return
        if not found:
            if self.unexpected_response != '':
                text = self.caller.eval_value(self.unexpected_response, response)
                text = str(self.caller.eval_value(self.unexpected_response, response))
            else:
                text = ''

            self.set_val(text)

    def no_space(self, action, key):
        if action != '1':
            return True
        if key != ' ':
            return True
        return False

class Dropdownbutton(Widget):
    def __init__(self, config_info, container):
        required = ['item', 'selections']
        optional = ['bg', 'abg', 'fg', 'afg',
            'width', 'height', 'justify', 'unexpectedresponse', 'label',
            'leading', 'evalincrement', 'evalcmd', 'from', 'to', 'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        config_info['caller'] = self
        config_info['server'] = self.server
        config_info['font'] = self.font()
        config_info['bg'] = self.bg
        config_info['fg'] = self.fg

        if 'width' not in config_info and self.container.childwidth != None:
            config_info['width'] = self.container.childwidth

        DropdownWidget(self, self.frame, config_info)

class Equalizers(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        optional = ['length', 'width', 'label', 'leading', 'font',
            'bg', 'fg', 'selectbg', 'selectfg', 'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        length = config_info.get('length', 150)
        slider_width = config_info.get('width', 15)
        selectbg=config_info.get('selectbg', self.bg)
        selectfg=config_info.get('selectfg', self.fg)

        # Define the style for equalizer comboboxes
        self.stylename = str(self) + '.TCombobox'
        self.style = ttk.Style()
        self.style.configure(self.stylename, background=self.bg, foreground=self.fg, selectbackground=selectbg, selectforeground=selectfg)

        self.alternates = ['Main']
        self.trs = ('Receive', 'Transmit')
        self.modes = ('CW','SSB', 'AM', 'FM')
        self.values = {}

        self.enabled_var = tk.IntVar()
        self.active_alt_var = tk.StringVar()
        self.alt_var = tk.StringVar()
        self.tr_mode_var = tk.StringVar()
        self.vfo_var = tk.StringVar()

        self.load_settings()

        active_frame = tk.LabelFrame(self.frame,
                                   text='Active Equalizers',
                                   font=self.label_font(),
                                   labelanchor='n',
                                   bd=4,
                                   relief='raised')
        active_frame.grid(row=0, column=0, sticky='w', pady=5)

        active_row0_frame = tk.Frame(active_frame)
        active_row0_frame.grid(row=0, column=0, sticky='w', pady=5)

        self.enabled_checkbutton = tk.Checkbutton(active_row0_frame, text='Disabled', var=self.enabled_var, onvalue=1, offvalue=0,
            indicatoron=False, font=self.font(), fg=self.fg, bg='yellow', selectcolor=self.bg, width=len('Disabled'))
        self.enabled_checkbutton.grid(row=0, column=0, sticky='w', pady=5)
        self.enabled_var.trace('w', self.on_enabled_changed)

        select_label = tk.Label(active_row0_frame,
                    text='Select: ',
                    height=1,
                    bd='2',
                    font=self.font(),
                    justify='left',
                    fg=self.fg,
                    padx=2,
                    pady=2)
        select_label.grid(row=0, column=1, sticky='w', padx=(30,0))

        alts = self.alternates + ['Flat']
        width = 0
        for alt in alts:
            if len(alt) > width:
                width = len(alt)

        self.active_alt_combobox = ttk.Combobox(
                active_row0_frame,
                textvar=self.active_alt_var,
                font=self.font(),
                values=alts,
                height=10,
                width=width,
                justify='left',
                style=self.stylename,
                )
        self.active_alt_combobox.grid(row=0, column=2, sticky='w', padx=(0,30))

        self.active_tr_var = tk.StringVar()
        self.active_tr_var.set(self.k4_tr())
        tr_label = tk.Label(active_row0_frame,
                    textvar=self.active_tr_var,
                    height=1,
                    bd='2',
                    font=self.font(),
                    justify='left',
                    fg=self.fg,
                    bg=self.bg,
                    padx=2,
                    pady=2)
        tr_label.grid(row=0, column=3, sticky='w', padx=(10, 0))

        self.active_mode_var = tk.StringVar()
        self.active_mode_var.set(self.k4_mode())
        mode_label = tk.Label(active_row0_frame,
                    textvar=self.active_mode_var,
                    height=1,
                    bd='2',
                    font=self.font(),
                    justify='left',
                    fg=self.fg,
                    bg=self.bg,
                    padx=2,
                    pady=2)
        mode_label.grid(row=0, column=4, sticky='w')

        vfo_frame = tk.Frame(active_frame)
        vfo_frame.grid(row=2, column=0, columnspan=5, sticky='w', pady=5)

        text = 'Receive equalizer follows mode on K4 VFO:'
        label = tk.Label(vfo_frame, text=text, font=self.font(), width=len(text), justify='right', fg=self.fg, bg=self.bg, pady=2)
        label.grid(row=0, column=0, sticky='w')

        vfo_combobox = ttk.Combobox(
                vfo_frame,
                textvar=self.vfo_var,
                font=self.font(),
                values=('A', 'B'),
                height=2,
                width=2,
                state='readonly',
                justify='left',
                style=self.stylename,
                )

        vfo_combobox.grid(row=0, column=1, sticky='w', padx=2, pady=5)

        self.equalizer_frame = tk.LabelFrame(self.frame,
                                   font=self.label_font(),
                                   labelanchor='n',
                                   bd=4,
                                   relief='raised')
        self.equalizer_frame.grid(row=1, column=0, sticky='w', pady=10)

        column0_frame = tk.Frame(self.equalizer_frame)
        column0_frame.grid(row=0, column=0, rowspan=6)

        alts = self.alternates
        width = 0
        for alt in alts:
            if len(alt) > width:
                width = len(alt)

        self.alt_combobox = ttk.Combobox(
                column0_frame,
                textvar=self.alt_var,
                font=self.font(),
                values=self.alternates,
                height=8,
                width=width,
                state='readonly',
                justify='left',
                style=self.stylename,
                )

        self.alt_combobox.grid(row=0, column=0, sticky='w', pady=5)

        tr_modes = []
        width = 0
        for tr in self.trs:
            for mode in self.modes:
                tr_mode = self.join_tr_mode(tr, mode)
                if len(tr_mode) > width:
                    width = len(tr_mode)
                tr_modes.append(tr_mode)

        self.tr_mode_combobox = ttk.Combobox(
                column0_frame,
                textvar=self.tr_mode_var,
                font=self.font(),
                values=tr_modes,
                height=8,
                width=width,
                state='readonly',
                justify='left',
                style=self.stylename,
                )

        self.tr_mode_combobox.grid(row=1, column=0, sticky='w', pady=5)

        flat_button = tk.Button(column0_frame,
                    bd='2',
                    text='Set Flat',
                    font=self.font(),
                    width=8,
                    justify='center',
                    relief='raised',
                    fg=self.fg,
                    bg=self.bg,
                    activebackground=self.bg,
                    activeforeground=self.fg,
                    padx=2,
                    pady=2,
                    command=self.on_set_flat)
        flat_button.grid(row=2, column=0, sticky='w', pady=5)

        label = tk.Label(column0_frame, text='Add:', bd='2', font=self.font(), justify='center', fg=self.fg, bg=self.bg, padx=2, pady=2)
        label.grid(row=3, column=0, sticky='w')

        self.add_var = tk.StringVar()
        add_entry = tk.Entry(column0_frame, textvariable=self.add_var, width=width, justify='left', font=self.font(), fg=self.fg, bg=self.bg)
        add_entry.grid(row=4, column=0, sticky='w')
        add_entry.bind('<Return>', self.on_add_alt)

        self.remove_button =  tk.Button(column0_frame,
                    bd='2',
                    text='',
                    state='disabled',
                    font=self.font(),
                    width=0,
                    justify='center',
                    relief='raised',
                    fg=self.fg,
                    bg=self.bg,
                    activebackground=self.bg,
                    activeforeground=self.fg,
                    padx=2,
                    pady=2,
                    command=self.on_remove_alt)
        self.remove_button.grid(row=5, column=0, sticky='w', pady=2)

        self.scale_value_vars = []
        self.scales = []
        self.freqs = (100, 200, 400, 800, 1200, 1600, 2400, 3200)
        scale_font = self.font().copy()
        scale_font['size'] -= 2

        for i in range(len(self.freqs)):
            value = tk.IntVar()
            self.scale_value_vars.append(value)
            value.set(0)
            scale = tk.Scale(self.equalizer_frame,
                             from_=16,
                             to=-16,
                             resolution=1,
                             orient='vertical',
                             repeatdelay=0,
                             width=slider_width,
                             length=length,
                             font=scale_font,
                             bg=self.bg,
                             fg=self.fg,
                             variable=value)
            scale.grid(row=0, column=i+1, pady=0)
            value.trace('w', lambda var, index, mode, i=i: self.on_value_changed(var, index, mode, i))
            self.scales.append(scale)

            label = tk.Label(self.equalizer_frame,
                             text=self.freqs[i],
                             bd=0,
                             font=self.font(),
                             justify='center',
                             fg=self.fg,
                             bg=self.bg)
            label.grid(row=1, column=i+1, pady=0)

        self.vfo_var.trace('w', self.on_vfo_changed)
        self.alt_var.trace('w', self.on_alt_changed)
        self.tr_mode_var.trace('w', self.on_tr_mode_changed)
        self.active_alt_var.trace('w', self.on_active_alt_changed)

        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        self.server.subscribe_responses('TR;MD;MD$;FT;', self.on_k4_mode_changed)
        self.set_k4_equalizer()
        self.configure()

    def on_enabled_changed(self, var, index, mode):
        self.set_k4_equalizer()
        self.configure()
        self.save_settings()

    def enabled(self):
        return int(self.enabled_var.get()) != 0

    def tr_mode(self):
        tr_mode = self.tr_mode_var.get()
        return self.split_tr_mode(tr_mode)

    def join_tr_mode(self, tr, mode):
        return f'{tr} - {mode}'

    def split_tr_mode(self, tr_mode):
        return tr_mode.rsplit(' - ', 1)

    def alt_tr_mode(self):
        alt = self.alt_var.get()
        tr, mode = self.tr_mode()
        return alt, tr, mode

    def join_alt_tr_mode(self, alt, tr, mode):
        return f'{alt} - {tr} - {mode}'

    def k4_tr(self):
        tr_index = 1 if self.k4param('TR') == 'T' else 0
        return self.trs[tr_index]

    def k4_mode(self):
        tr = self.k4_tr()
        base = 'MD'
        if tr == 'Receive':
            if self.vfo_var.get() == 'B':
                base += '$'
        else:
            split = self.k4param('FT') == '1'
            if split:
                base += '$'

        k4_modes = ('', 'SSB', 'SSB', 'CW', 'FM', 'AM', '', 'CW', '', '')
        k4_mode = self.k4param(base)
        if k4_mode ==  None or k4_mode == '':
            return None
        mode = k4_modes[int(k4_mode)]
        return mode

    def values_str(self, values):
        strs = []
        for value in values:
            strs.append('{value:+03d}'.format(value=value))
        return ''.join(strs)

    def str_values(self, s):
        values = []
        for offset in range(0, 24, 3):
            values.append(int(s[offset:offset+3]))
        return values

    def set_k4_equalizer(self):
        if not self.enabled():
            return

        mode = self.k4_mode()
        if mode == None or mode == '':
            return

        alt = self.active_alt_var.get()
        tr = self.k4_tr()
        if tr == 'Receive':
            base = 'RE'
        else:
            base = 'TE'
        values = self.values[alt][tr][mode]
        cmd = base + self.values_str(values) + ';'
        self.server.send_cmds(cmd)

    def on_active_alt_changed(self, var, index, mode):
        self.set_k4_equalizer()
        self.configure()
        self.save_settings()

    def on_value_changed(self, var, index, mode, i):
        value = self.scale_value_vars[i].get()
        alt, tr, mode = self.alt_tr_mode()
        self.values[alt][tr][mode][i] = value
        self.set_k4_equalizer()
        self.save_settings()

    def on_alt_changed(self, var, index, mode):
        self.configure()
        self.set_k4_equalizer()
        self.save_settings()

    def on_tr_mode_changed(self, var, index, mode):
        self.configure()
        self.set_k4_equalizer()
        self.save_settings()

    def on_k4_mode_changed(self, response):
        mode = self.k4_mode()
        if mode == None or mode == '':
            return

        self.active_tr_var.set(self.k4_tr())
        self.active_mode_var.set(mode)
        self.set_k4_equalizer()
        self.configure()

    def on_set_flat(self):
        alt, tr, mode = self.alt_tr_mode()
        self.values[alt][tr][mode] = [0, 0, 0, 0, 0, 0, 0, 0]

        self.set_k4_equalizer()
        self.configure()
        self.save_settings()

    def on_add_alt(self, event):
        alt = self.add_var.get()
        if alt in self.alternates + ['Flat']:
            return
        self.alternates.append(alt)
        self.values[alt] = {}
        for tr in self.trs:
            self.values[alt][tr] = {}
            for mode in self.modes:
                self.values[alt][tr][mode] = [0, 0, 0, 0, 0, 0, 0, 0]
        self.alt_var.set(alt)
        self.add_var.set("")
        self.configure()
        self.save_settings()

    def on_remove_alt(self):
        alt = self.alt_var.get()
        if alt == 'Main':
            return

        self.alternates.remove(alt)
        del self.values[alt]

        alt = self.alternates[0]
        self.alt_var.set(alt)

        self.configure()
        self.set_k4_equalizer()
        self.save_settings()

    def on_vfo_changed(self, var, index, mode):
        self.set_k4_equalizer()
        self.configure()
        self.save_settings()

    def configure(self):
        if self.enabled():
            self.enabled_checkbutton.configure(text='Enabled')
        else:
            self.enabled_checkbutton.configure(text='Disabled')

        alts = self.alternates + ['Flat']
        width = 0
        for alt in alts:
            if len(alt) > width:
                width = len(alt)
        self.active_alt_combobox.configure(values=alts, width=width+1)

        alt, tr, mode = self.alt_tr_mode()
        for i, value in enumerate(self.values[alt][tr][mode]):
            if value != self.scale_value_vars[i].get():
                self.scale_value_vars[i].set(value)

        if alt == 'Main' or alt == self.active_alt_var.get():
            self.remove_button.configure(text='', width=0, state='disabled')
        else:
            text = 'Remove: ' + alt
            self.remove_button.configure(text=text, width=len(text), state='normal')

        alt_tr_mode = self.join_alt_tr_mode(alt, tr, mode)
        self.equalizer_frame.configure(text=alt_tr_mode)

        width = 0
        for alt in self.alternates:
            if len(alt) > width:
                width = len(alt)
        self.alt_combobox.configure(values=self.alternates, height=8, width=width)

        tr_modes = []
        width = 0
        for tr in self.trs:
            for mode in self.modes:
                tr_mode = self.join_tr_mode(tr, mode)
                if len(tr_mode) > width:
                    width = len(tr_mode)
                tr_modes.append(tr_mode)
        self.tr_mode_combobox.configure(values=tr_modes, height=8, width=width)

    def save_settings(self):
        section = 'Equalizers'
        previous_settings = Server.settings.get_section(section)
        Server.settings.clear_section(section)

        Server.settings.put(section, 'enabled', str(self.enabled_var.get()))
        Server.settings.put(section, 'active', self.active_alt_var.get())
        Server.settings.put(section, 'alternates', ', '.join(self.alternates))
        Server.settings.put(section, 'alt.tr.mode', '.'.join(self.alt_tr_mode()))

        for alt in self.alternates:
            for tr in self.trs:
                for mode in self.modes:
                    setting = '.'.join((alt, tr, mode))
                    values = self.values[alt][tr][mode]
                    values_str = self.values_str(values)
                    Server.settings.put(section, setting, values_str)

        settings = Server.settings.get_section(section)
        if settings != previous_settings:
            Server.settings.save()

    def load_settings(self):
        section = 'Equalizers'
        enabled = Server.settings.get(section, "enabled")
        if enabled == None:
            enabled = 0
        self.enabled_var.set(int(enabled))

        active = Server.settings.get(section, 'active')
        if active == None:
            active = self.alternates[0]
        self.active_alt_var.set(active)

        vfo = Server.settings.get(section, 'follows_vfo')
        if vfo == None:
            vfo = 'A'
        self.vfo_var.set(vfo)

        alternates = Server.settings.get(section, 'alternates')
        if alternates == None:
            alternates = 'Main'
        self.alternates = alternates.split(', ')

        alt_tr_mode = Server.settings.get(section, 'alt.tr.mode')
        if alt_tr_mode == None:
            alt = self.alternates[0]
            tr = self.trs[0]
            mode = self.modes[0]
        else:
            alt, tr, mode = alt_tr_mode.rsplit('.', 2)
        self.alt_var.set(alt)
        self.tr_mode_var.set(self.join_tr_mode(tr, mode))

        for alt in self.alternates + ['Flat']:
            self.values[alt] = {}
            for tr in self.trs:
                self.values[alt][tr] = {}
                for mode in self.modes:
                    setting = '.'.join((alt, tr, mode))
                    values_str = Server.settings.get(section, setting)
                    if values_str != None:
                        self.values[alt][tr][mode] = self.str_values(values_str)
                    else:
                        self.values[alt][tr][mode] = [0, 0, 0, 0, 0, 0, 0, 0]

def cmd_base(cmd):
    ucmd = cmd.upper()
    base = ucmd[0:2]
    if base in Server.k4_long_cmd_bases:
        for long_base in Server.k4_long_cmd_bases[base]:
            if ucmd.startswith(long_base):
                base = long_base
                break
    if len(cmd) > len(base):
        if cmd[len(base)] == '$':
            base += '$'
        elif cmd[len(base)] == '!':
            base += '!'
    return base

def cmd_parameter(response):
    i = len(cmd_base(response))
    return response[i:].rstrip(';').upper()

def true_values(v):
    if v == True or v == 1:
        return True

    if not isinstance(v, str):
        return False

    v = v.lower()
    return v == 'true' or v == 'on' or v == '1' or v == 'yes'

class Menu_definition():
    def __init__(self, menu, d):
        self.menu = menu
        self.index = int(d[0])
        self.desc = hex_decode(d[1])
        self.area = d[2]
        self.type = d[3]
        self.locked = 'Unlocked' if d[4] == '0' else 'Locked' if d[4] == '1' else 'Unmodifiable' if d[4] == '2' else ''
        self.low = self.typed_value(d[5])
        self.high = self.typed_value(d[6])
        self.default = self.typed_value(d[7])
        self.current = self.typed_value(d[8])
        self.increment = self.typed_value(d[9])
        self.values = []
        for value in d[10:]:
            self.values.append(hex_decode(value))
        self.container = menu.container
        self.server = menu.server

        self.send_command = self.widget_send_command

        self.updated_desc = self.desc

        self.widget = None
        self.changeable = ''

        self.frame = tk.LabelFrame(self.menu.frame,
                                   text=self.desc,
                                   font=self.menu.label_font(),
                                   labelanchor='nw',
                                   bd=4,
                                   relief='raised')

        if len(self.values) > 0:
            self.listbox()
        elif self.type == 'BIN':
            self.range_listbox()
        elif self.type == 'VFOCRS':
            self.vfocrs()
        elif self.type == 'AOFS':
            self.aofs()
        elif self.type == 'M50Hz':
            self.m50hz()
        elif self.type == 'ZMON':
            self.zmon()
        elif self.type == 'D10mW':
            self.d10mw()
        elif self.type in ('DEC', 'REF', 'ms', 'ZOFF', 'MHz', 'Hz'):
            self.slider()
        elif self.type in ('IP', 'SN'):
            self.fixed_text()
        elif self.type == 'STR':
            self.text()

        self.locked_frame = tk.Frame(self.frame)
        self.locked_frame.grid(row=0, column=1)

        self.locked_button = tk.Button(self.locked_frame,
                    bd='2',
                    text=self.locked,
                    font=self.menu.font(),
                    width=12,
                    justify='center',
                    relief='raised',
                    fg=self.menu.fg,
                    bg=self.menu.bg,
                    activebackground=self.menu.abg,
                    activeforeground=self.menu.afg,
                    padx=2,
                    pady=2,
                    command=self.on_locked_changed)

        self.locked_button.grid(row=0, column=0)

        self.default_button = tk.Button(self.locked_frame,
                    bd='2',
                    text="Set to\nNormal",
                    font=self.menu.font(),
                    width=12,
                    justify='center',
                    relief='raised',
                    fg=self.menu.fg,
                    bg=self.menu.bg,
                    activebackground=self.menu.abg,
                    activeforeground=self.menu.afg,
                    padx=2,
                    pady=2,
                    command=self.on_default_clicked)

        self.default_button.grid(row=1, column=0)

    def null_update(self, current=None):
        pass

    def on_locked_changed(self):
        if self.locked == 'Locked':
            if self.changeable == 'Locked':
                self.changeable = 'Unlocked'
            else:
                self.changeable = 'Locked'

        self.update()

    def update(self, locked=None, current=None):
        self.update_widget(current=current)

        if locked != None:
            self.changeable = locked

        if self.changeable == 'Unmodifiable':
            self.default_button.grid_forget()
        elif self.changeable == 'Unlocked':
            self.default_button.grid(row=1, column=0)
            self.default_button.configure(state='normal')
        else:
            self.default_button.grid(row=1, column=0)
            self.default_button.configure(state='disabled')

        self.locked_button.configure(text=self.changeable)

        self.update_desc()

    def update_desc(self):
        desc = self.updated_desc
        if self.area == 'XV':
            if self.type == 'DEC':
                self.menu.xv_band = int(self.current)
            else:
                self.updated_desc = self.desc.replace('<n>', str(self.menu.xv_band))

            if self.updated_desc != desc:
                self.menu.listbox.delete(self.position)
                self.menu.listbox.insert(self.position, self.updated_desc)

        if self.type == 'ms':
            self.updated_desc = self.desc + "\n(mS)"

        if self.type == 'ZMON':
            self.updated_desc = self.desc + "\n(-1 = OFF, 0 = MON)"

        if self.type == 'ZOFF':
            self.updated_desc = self.desc + "\n(0 = OFF)"

        if self.type == 'MHz':
            self.updated_desc = self.updated_desc + "\n(MHz)"

        if self.type == 'D10mW':
            self.updated_desc = self.updated_desc + "\n(mW)"

        if self.type == 'Hz':
            self.updated_desc = self.updated_desc + "\n(Hz)"

        if self.updated_desc != desc:
            self.frame.configure(text=self.updated_desc)

    def current_desc(self):
        return self.updated_desc

    def on_default_clicked(self):
        if self.changeable == 'Unlocked':
            self.update(current=self.default)
            self.send_command()

    def show(self):
        self.update(locked=self.locked)
        self.frame.grid(row=0, column=2)

    def hide(self):
        self.frame.grid_forget()

    def listbox(self):
        self.update_widget = self.listbox_update
        self.widget = tk.Listbox(
                self.frame,
                font=self.menu.font(),
                justify='left',
                bg=self.menu.bg,
                fg=self.menu.fg,
                selectbackground=self.menu.selectbg,
                selectforeground=self.menu.selectfg,
                exportselection=False,
                )

        if self.low != 0:
            raise Exception('Unexpected listbox low ', self.low)

        high = self.high + 1
        if high < len(self.values):
            self.values = self.values[:high]

        width = 0
        for value in self.values:
            value = str(value)
            if len(value) > width:
                width = len(value)
            self.widget.insert(tk.END, value)

        width = int(round(width*1.1)+1)
        self.widget.configure(height=len(self.values), width=width)
        self.widget.selection_clear(0, tk.END)
        self.widget.selection_set(self.current)
        selections = self.widget.curselection()
        if len(selections) > 0:
            index = selections[0]

        self.widget.grid(row=0, column=0)
        self.widget.bind('<<ListboxSelect>>', self.on_listbox_selected)

    def on_listbox_selected(self, arg):
        if self.changeable != 'Unlocked':
            self.widget.selection_clear(0, tk.END)
            self.widget.selection_set(self.current)
            return

        selections = self.widget.curselection()
        index = selections[0]
        self.current = index
        self.send_command()

    def listbox_update(self, current=None):
        if current != None:
            self.current = current
        self.widget.selection_clear(0, tk.END)
        self.widget.selection_set(self.current)

    def vfocrs(self):
        self.values = ('0.1 kHz', '0.5 kHz', '1.0 kHz', '2.5 kHz')
        self.listbox()

    def m50hz(self):
        self.values = ('150 Hz', '200 Hz', '250 Hz', '300 Hz', '350 Hz', '400 Hz', '450 Hz', '500 Hz', '550 Hz', '600 Hz', '650 Hz', '700 Hz')
        self.high -= self.low
        self.low = 0
        self.listbox()
        self.send_command = self.m50hz_send_command
        self.update_widget = self.m50hz_update

    def m50hz_send_command(self):
        value = int(self.current) + 3
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def m50hz_update(self, current=None):
        if current != None:
            self.current = current - 3
        self.listbox_update()

    def aofs(self):
        self.low -= 8
        self.high -= 8
        self.slider()
        self.send_command = self.aofs_send_command
        self.update_widget = self.aofs_update

    def aofs_send_command(self):
        value = int(self.current) + 8
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def aofs_update(self, current=None):
        if current != None:
            self.current = current - 8
        self.slider_update()

    def zmon(self):
        self.current -= 1
        self.low -= 1
        self.high -= 1
        self.slider()
        self.send_command = self.zmon_send_command
        self.update_widget = self.zmon_update

    def zmon_send_command(self):
        value = int(self.current) + 1
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def zmon_update(self, current=None):
        if current != None:
            self.current = current - 1
        self.slider_update()

    def d10mw(self):
        self.low = float(self.low) / 10
        self.high = float(self.high) / 10
        self.increment = float(self.increment) / 10
        self.slider()
        self.send_command = self.d10mw_send_command
        self.update_widget = self.d10mw_update

    def d10mw_send_command(self):
        value = int(self.current * 10)
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def d10mw_update(self, current=None):
        if current != None:
            self.current = float(current) / 10
        self.slider_update()

    def range_listbox(self):
        for i in range(self.low, self.high+1, self.increment):
            self.values.append(i)
        self.high -= self.low
        self.low = 0
        self.listbox()
        self.send_command = self.range_listbox_send_command
        self.update_widget = self.range_listbox_update

    def range_listbox_update(self, current=None):
        if current != None:
            self.current = self.values.index(current)
        self.widget.selection_clear(0, tk.END)
        self.widget.selection_set(self.current)

    def range_listbox_send_command(self):
        value = int(self.values[self.current])
        self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def slider(self):
        self.update_widget = self.slider_update
        self.value = tk.DoubleVar()
        self.value.set(self.current)

        self.widget = tk.Scale(self.frame,
                         from_=self.high,
                         to=self.low,
                         orient='vertical',
                         resolution=self.increment,
                         width=20,
                         length=font_height(self.menu.font())*9,
                         font=self.menu.font(),
                         bg=self.menu.bg,
                         fg=self.menu.fg,
                         variable=self.value,
                         command=self.slider_value_changed)
        self.widget.grid(row=0, column=0)

    def slider_value_changed(self, event):
        if self.changeable != 'Unlocked':
            self.value.set(self.current)
            return

        self.current = self.value.get()
        self.send_command()

    def slider_update(self, current=None):
        if current != None:
            if isinstance(current, str) and current.find('-') > 0:
                current = current.lstrip('0')
            self.current = current
        self.value.set(self.current)

    def fixed_text(self):
        self.update_widget = self.fixed_text_update
        self.widget = tk.Label(self.frame,
            text=self.current,
            bd=2,
            font=self.menu.font(),
            justify='left',
            fg=self.menu.fg,
            bg=self.menu.bg,
            activebackground=self.menu.abg,
            activeforeground=self.menu.afg,
            padx=2,
            pady=2)
        self.widget.grid(row=0, column=0)

    def fixed_text_update(self, current=None):
        if current != None:
            self.current = current
        self.locked = 'Unmodifiable'
        self.widget.configure(text=self.current)

    def text(self):
        self.update_widget = self.text_update
        self.text_var = tk.StringVar()
        self.text_var.set(self.current)
        self.widget = tk.Entry(self.frame,
            textvariable=self.text_var,
            bd=2,
            font=self.menu.font(),
            justify='left',
            fg=self.menu.fg,
            bg=self.menu.bg)
        self.widget.grid(row=0, column=0)
        self.widget.bind('<Return>', self.set_text)
        self.widget.bind('<FocusOut>', self.set_text)

    def set_text(self, event):
        self.current = self.text_var.get()
        self.send_command()

    def text_update(self, current=None):
        if current != None:
            self.current = current
        self.text_var.set(self.current)

    def widget_send_command(self):
        if isinstance(self.current, str) or self.type == 'REF':
            self.server.send_str('ME{index:04d}.{value};'.format(index=self.index, value=self.current))
        else:
            value = int(round(self.current))
            self.server.send_str('ME{index:04d}.{value:04d};'.format(index=self.index, value=value))

    def typed_value(self, n):
        if self.type == 'REF':
            return n
        try:
            n = float(n)
            if int(n) == n:
                n = int(n)
        except:
            pass
        return n

    def print(self):
        dprint('index', self.index)
        dprint('desc', self.desc)
        dprint('area', self.area)
        dprint('type', self.type)
        dprint('locked', self.locked)
        dprint('low', self.low)
        dprint('high', self.high)
        dprint('default', self.default)
        dprint('current', self.current)
        dprint('increment', self.increment)
        dprint('values', self.values)

class Menu(Widget):
    entries_displayed = 15
    singleton = None

    @classmethod
    def entry(cls, index):
        return cls.singleton.lookup_definitions.get(index, None)

    def __init__(self, config_info, container):
        required = ['item']
        optional = ['entries_displayed', 'label', 'leading', 'bg', 'abg',
            'fg', 'afg', 'selectbg', 'selectfg', 'font', 'label_font',
            'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        Menu.singleton = self

        entries_displayed = config_info.get('entries_displayed', Menu.entries_displayed)

        self.current_md = None

        self.selectbg = config_info.get('selectbg', self.bg)
        self.selectfg = config_info.get('selectfg', self.fg)

        self.definitions = []
        self.lookup_definitions = {}

        self.xv_band = 0

        self.frame = tk.Frame(self.frame)
        self.frame.grid(row=0, column=0)

        self.listbox = tk.Listbox(
                self.frame,
                font=self.font(),
                height=entries_displayed,
                justify='left',
                bg=self.bg,
                fg=self.fg,
                selectbackground=self.selectbg,
                selectforeground=self.selectfg,
                exportselection=False,
                bd=2,
                )

        self.scrollbar = tk.Scrollbar(self.frame)
        self.listbox.config(yscrollcommand=self.scrollbar.set)
        self.scrollbar.config(command=self.listbox.yview)

        self.listbox.bind('<<ListboxSelect>>', self.on_listbox_selected)
        self.server.subscribe_response('MEDF;', self.on_received_definition, send=False)

    def update_definition_list(self):
        self.listbox.delete(0, tk.END)

        width = 0
        for i, md in enumerate(self.definitions):
            md.position = i
            desc = md.current_desc()
            if len(desc) > width:
                width = len(desc)
            self.listbox.insert(tk.END, md.desc)

        self.listbox.configure(width=width)

    def received_all_definitions(self):
        self.server.subscribe_response('ME;', self.on_received_current, send=False)

        self.definitions = sorted(self.definitions, key=lambda d:d.current_desc().casefold())
        self.update_definition_list()

        self.server.send_str('ME0043;')         # request updated IP address. We know this has changed.
        self.server.send_str('ME0086;ME0078;ME0076;ME0079;ME0098;ME0077;')   # request current transverter band menu settings

        self.listbox.grid(row=0, column=0, sticky='w')
        self.scrollbar.grid(row=0, column=1, sticky='ns')

    def on_received_current(self, response):
        index, current_value = response[2:].split('.', 1)
        current_value = current_value.rstrip(';')
        index = int(index)
        md = self.lookup_definitions[index]
        current_value = md.typed_value(current_value)
        md.update(current=current_value)

    def on_listbox_selected(self, arg):
        selections = self.listbox.curselection()
        if len(selections) == 0:
            return

        index = selections[0]

        if self.current_md != None and self.current_md.widget != None:
            self.current_md.hide()

        md = self.definitions[index]
        self.current_md = md

        md.show()

    def on_received_definition(self, response):
        if response[4:8] == '0000':
            self.received_all_definitions()
            return

        definition_values = response[4:].rstrip(';').split(',')
        if len(definition_values) < 3 or definition_values[3] == 'NULL':                      # md.type
            return

        md = Menu_definition(self, definition_values)
        found = self.lookup_definitions.get(md.index, None)
        if found != None:
            return

        self.lookup_definitions[md.index] = md
        self.definitions.append(md)

class Audio():
    singleton = None
    input_channels = 1
    k4_input_channels = 2               # The K4 requires stereo, even though it transmits mono
    input_frame_size = 240
    output_channels = 2
    k4_sample_rate = 12000
    k4_sample_rate_code = 0
    max_input_sample_rate = 48000
    max_output_sample_rate = 48000
    encode_mode_raw32 = 0
    encode_mode_raw16 = 1
    encode_mode_opus = 2
    encode_mode_opus_float = 3
    input_encode_mode = encode_mode_opus_float
    server = None

    @classmethod
    def get_singleton(cls):
        if cls.singleton == None:
            cls.singleton = Audio()

        return cls.singleton

    @classmethod
    def close(cls):
        if cls.singleton == None:
            return

        self = cls.singleton
        self.transmit_audio = False
        if self.input_thread != None:
            self.input_thread.join()
        if self.output_thread != None:
            self.output_thread.join()

    @classmethod
    def set_input_device_name(cls, name):
        self = cls.get_singleton()
        dev_info = self.input_device_info_by_name(name)
        if dev_info != None:
            self.input_device_index = dev_info['index']

    @classmethod
    def set_output_device_name(cls, name):
        self = cls.get_singleton()
        dev_info = self.output_device_info_by_name(name)
        if dev_info != None:
            self.output_device_index = dev_info['index']

    @classmethod
    def input_device_name(cls):
        self = cls.get_singleton()
        if self.input_device_index < 0:
            return "None available"
        dev_info = self.input_device_infos[self.input_device_index]
        return dev_info['name']

    @classmethod
    def output_device_name(cls):
        self = cls.get_singleton()
        if self.output_device_index < 0:
            return "None available"
        dev_info = self.output_device_infos[self.output_device_index]
        return dev_info['name']

    @classmethod
    def input_device_info(cls):
        self = cls.get_singleton()
        if self.input_device_index < 0:
            return None
        return self.input_device_infos[self.input_device_index]


    @classmethod
    def output_device_info(cls):
        self = cls.get_singleton()
        if self.output_device_index < 0:
            return None
        return self.output_device_infos[self.output_device_index]

    @classmethod
    def input_device_index(cls):
        self = cls.get_singleton()
        return self.input_device_index

    @classmethod
    def output_device_index(cls):
        self = cls.get_singleton()
        return self.output_device_index

    @classmethod
    def input_device_names(cls):
        self = cls.get_singleton()
        names = []
        for index in self.input_device_infos:
            device_info = self.input_device_infos[index]
            names.append(device_info['name'])
        return names

    @classmethod
    def output_device_names(cls):
        self = cls.get_singleton()
        names = []
        for index in self.output_device_infos:
            device_info = self.output_device_infos[index]
            names.append(device_info['name'])
        return names

    @classmethod
    def input_device_sample_rate(cls):
        self = cls.get_singleton()
        if self.input_device_index < 0:
            return None
        info = self.input_device_infos[self.input_device_index]
        return info['input_sample_rate']

    @classmethod
    def output_device_sample_rate(cls):
        self = cls.get_singleton()
        if self.output_device_index < 0:
            return None
        info = self.output_device_infos[self.output_device_index]
        return info['output_sample_rate']

    @classmethod
    def control_k4_cmd(cls, base, cmd):
        self = cls.get_singleton()
        cmd = cmd[len(base):]

        if base == 'AG':
            Server.settings.put_save('Audio', 'main_volume', cmd)
            self.a_volume = float(cmd) / 60.0
        elif base == 'AG$':
            Server.settings.put_save('Audio', 'sub_volume', cmd)
            self.b_volume = float(cmd) / 60.0
        elif base == 'MG':
            Server.settings.put_save('Audio', 'mic_gain', cmd)
            self.mic_gain = float(cmd) / 80.0
        elif base == 'SB':
            self.sub_on = cmd != '0'

    @classmethod
    def local_audio_responses(cls):
        a_volume = Server.settings.get('Audio', 'main_volume')
        if a_volume == None:
            a_volume = '000'
        responses = 'AG' + a_volume + ';'

        b_volume = Server.settings.get('Audio', 'sub_volume')
        if b_volume == None:
            b_volume = '000'
        responses += 'AG$' + b_volume + ';'

        mic_gain = Server.settings.get('Audio', 'mic_gain')
        if mic_gain == None:
            mic_gain = '020'
        responses += 'MG' + mic_gain + ';'

        return responses

    @classmethod
    def server_connected(cls, server):
        self = cls.get_singleton()
        cls.server = server
        server.subscribe_responses('TR;', lambda response: self.on_transmit_changed(server, response), send=False)
        server.subscribe_response('MX;', lambda response: self.on_mx_changed(server, response), send=False)
        server.subscribe_received_initial_parameters(cls.on_received_initial_parameters)

    @classmethod
    def on_received_initial_parameters(cls, server):
        self = cls.get_singleton()
        self.start_output_thread(cls.server.output_audio_queue)

    def pyaudio(self):
        fd = os.dup(2)
        os.close(2)              # Close stderr because pyaudio outputs a lot of disquieting messages
        pa = pyaudio.PyAudio()
        os.dup2(fd, 2)           # restore stderr
        os.close(fd)
        return pa

    def pa_get_host_api_info_by_index(self, pa, index):
        fd = os.dup(2)
        os.close(2)              # Close stderr because pyaudio outputs a lot of disquieting messages
        info = pa.get_host_api_info_by_index(index)
        os.dup2(fd, 2)           # restore stderr
        os.close(fd)
        return info

    def pa_is_format_supported(self, pa, sample_rate, **kwargs):
        supported = False
        fd = os.dup(2)
        os.close(2)              # Close stderr because pyaudio outputs a lot of disquieting messages
        try:
            supported = pa.is_format_supported(sample_rate, **kwargs)
        except:
            pass
        os.dup2(fd, 2)           # restore stderr
        os.close(fd)
        return supported

    def __init__(self):
        self.input_thread = None
        self.output_thread = None
        self.input_device_index = -1
        self.output_device_index = -1
        self.input_device_infos = {}
        self.output_device_infos = {}
        self.sub_on = True
        self.transmit_audio = False

        a_volume = Server.settings.get('Audio', 'main_volume')
        if a_volume == None:
            a_volume = '015'
        self.a_volume = float(a_volume) / 60.0

        b_volume = Server.settings.get('Audio', 'sub_volume')
        if b_volume == None:
            b_volume = '010'
        self.b_volume = float(b_volume) / 60.0

        mic_gain = Server.settings.get('Audio', 'mic_gain')
        if mic_gain == None:
            mic_gain = '040'
        self.mic_gain = float(mic_gain) / 80.0

        pa = self.pyaudio()
        info = self.pa_get_host_api_info_by_index(pa, 0)

        numdevices = info.get('deviceCount')

        try:
            default_input_device_index = pa.get_default_input_device_info()['index']
        except:
            default_input_device_index = None
        try:
            default_output_device_index = pa.get_default_output_device_info()['index']
        except:
            default_output_device_index = None

        for i in range(0, numdevices):
            info = pa.get_device_info_by_host_api_device_index(0, i)
            if info['name'] in [ 'dmix', 'lavrate', 'samplerate', 'speexrate', 'pulse', 'speex', 'upmix', 'vdownmix' ]:
                continue
            default_sample_rate = info['defaultSampleRate']

            input_device_info = { 'default_sample_rate': int(default_sample_rate), 'input_channels': 0 }

            begin_rate = Audio.k4_sample_rate
            end_rate = Audio.max_input_sample_rate + begin_rate
            step = begin_rate
            for input_sample_rate in range(begin_rate, end_rate, step):
                if self.pa_is_format_supported(pa, input_sample_rate,
                               input_device=info['index'],
                               input_channels=Audio.input_channels,
                               input_format=pyaudio.paFloat32):
                    input_device_info['index'] = info['index']
                    input_device_info['name'] = info['name']
                    input_device_info['input_channels'] = info['maxInputChannels']
                    input_device_info['input_sample_rate'] = input_sample_rate
                    if info['index'] == default_input_device_index or default_input_device_index == None:
                        self.input_device_index = info['index']
                    break

            if 'index' in input_device_info:
                self.input_device_infos[input_device_info['index']] = input_device_info
            elif Options.debug > 0:
                if self.pa_is_format_supported(pa, default_sample_rate,
                             input_device=info['index'],
                             input_channels=Audio.input_channels,
                             input_format=pyaudio.paFloat32):
                    dprint('Info:', info['name'], 'does not support multiple of K4 sample rate. supported rate:', default_sample_rate)

            output_device_info = { 'default_sample_rate': int(default_sample_rate), 'output_channels': 0 }

            begin_rate = Audio.k4_sample_rate
            end_rate = Audio.max_output_sample_rate + begin_rate
            step = begin_rate
            for output_sample_rate in range(begin_rate, end_rate, step):
                if self.pa_is_format_supported(pa, output_sample_rate,
                                   output_device=info['index'],
                                   output_channels=Audio.output_channels,
                                   output_format=pyaudio.paFloat32):
                    output_device_info['index'] = info['index']
                    output_device_info['name'] = info['name']
                    output_device_info['output_channels'] = info['maxOutputChannels']
                    output_device_info['output_sample_rate'] = output_sample_rate
                    if info['index'] == default_output_device_index or default_output_device_index == None:
                        self.output_device_index = info['index']
                    break

            if 'index' in output_device_info:
                self.output_device_infos[output_device_info['index']] = output_device_info
            elif Options.debug > 0:
                if self.pa_is_format_supported(pa, default_sample_rate,
                             output_device=info['index'],
                             output_channels=Audio.output_channels,
                             output_format=pyaudio.paFloat32):
                    dprint('Info:', info['name'], 'does not support multiple of K4 sample rate. supported rate:', default_sample_rate)

    def input_device_info_by_name(self, name):
        for index in self.input_device_infos:
            dev_info = self.input_device_infos[index]
            if dev_info['name'] == name:
                return dev_info
        return None

    def output_device_info_by_name(self, name):
        for index in self.output_device_infos:
            dev_info = self.output_device_infos[index]
            if dev_info['name'] == name:
                return dev_info
        return None

    def start_output_thread(self, queue):
        if self.output_device_index < 0:
            return
        self.output_queue = queue
        self.output_thread = threading.Thread(target=self.output_loop, name='audio_output_thread')
        self.output_thread.start()

    def output_loop(self):
        output_stream = None
        current_index = None
        warned = False

        while True:
            packet = self.output_queue.get()
            if len(packet) == 0:
                return

            if current_index != self.output_device_index:
                current_index = self.output_device_index
                encode_mode = packet[0]
                if encode_mode != Audio.encode_mode_opus_float:
                    raise Exception('Unsupported audio encode mode:', encode_mode)

                frame_size = packet[2] << 8 | packet[1]

                sample_rate = packet[3]
                if sample_rate != 0:
                    raise Exception('Unsupported audio sample rate:', sample_rate)

                opus = opuslib.Decoder(Audio.k4_sample_rate, Audio.output_channels)

                pa = self.pyaudio()

                if output_stream != None:
                    output_stream.close()
                    output_stream = None

                resample_ratio = int(Audio.output_device_sample_rate() / Audio.k4_sample_rate)

                retries = 2
                for retry in range(retries+1):
                    try:
                        output_stream = pa.open(format=pyaudio.paFloat32,
                                                channels=Audio.output_channels,
                                                rate=Audio.output_device_sample_rate(),
                                                frames_per_buffer=frame_size,
                                                output=True,
                                                output_device_index=self.output_device_index,
                                                )
                        warned = False
                        break
                    except:
                        if retry >= retries:
                            if not warned:
                                Popup.warning('Failed to open: ' + self.output_device_name())
                                warned = True
                        continue

            pcm = opus.decode_float(bytes(packet[4:]), frame_size)

            stereo = numpy.frombuffer(pcm, dtype=numpy.float32)
            a = stereo[0::2]                    # even samples are from the main receiver
            b = stereo[1::2]                    # odd samples are from the sub receiver

            a = a * self.a_volume * 32          # apply some amplification
            b = b * self.b_volume * 32
                                                # Possible self.ab settings
                                                # a.b
                                                # ab.ab
                                                # a.-a
                                                # a.ab
                                                # ab.b
                                                # ab.a
                                                # b.ab
                                                # b.b
                                                # b.a
                                                # a.a

            if not self.sub_on:
                b = a                      # take all audio from main

            leftsel, rightsel = self.ab.split('.')

            if leftsel == 'a':
                left = a
            elif leftsel == 'b':
                left = b
            elif leftsel == 'ab':
                left = (a + b) / 2

            if rightsel == 'b':
                right = b
            elif rightsel == 'a':
                right = a
            elif rightsel == 'ab':
                right = (a + b) / 2
            elif rightsel == '-a':
                right = -a

            if resample_ratio > 1:
                left = left.repeat(resample_ratio)
                right = right.repeat(resample_ratio)

            stereo = numpy.empty((left.size + right.size,), dtype=numpy.float32)
            stereo[0::2] = left
            stereo[1::2] = right
            output_stream.write(stereo.tobytes())

    def on_transmit_changed(self, server, response):
        transmit = server.k4_parameters.get('TR') == 'T'
        tune = server.k4_parameters.get('TU', "0") != '0'
        if transmit and not tune:
            split = server.k4_parameters.get('FT') == '1'
            if split:
                mode = server.k4_parameters.get('MD$')
            else:
                mode = server.k4_parameters.get('MD')

            if mode in ("1", "2", "4", "5"):        # LSB, USB, FM, AM
                if not self.transmit_audio:
                    self.transmit_audio = True
                    self.start_input_thread(server)
                return

        self.transmit_audio = False
        if self.input_thread != None:
            self.input_thread.join()
            self.input_thread = None

    def on_mx_changed(self, server, response):
        self.ab = response[2:].lower().rstrip(';')

    def start_input_thread(self, server):
        if self.input_device_index < 0:
            return
        self.input_thread = threading.Thread(target=lambda: self.input_loop(server), name='audio_input_thread')
        self.input_thread.start()

    def input_loop(self, server):
        input_stream = None
        current_index = None
        warned = False

        while True:
            if current_index != self.input_device_index:
                current_index = self.input_device_index

                opus = opuslib.Encoder(Audio.k4_sample_rate, Audio.k4_input_channels, 'audio')

                pa = self.pyaudio()

                if input_stream != None:
                    input_stream.close()
                    input_stream = None

                retries = 2
                for retry in range(retries+1):
                    try:
                        input_stream = pa.open(format=pyaudio.paFloat32,
                                                channels=Audio.input_channels,
                                                rate=Audio.input_device_sample_rate(),
                                                frames_per_buffer=Audio.input_frame_size,
                                                input=True,
                                                input_device_index=self.input_device_index,
                                                )
                        warned = False
                        break
                    except:
                        if retry >= retries:
                            if not warned:
                                Popup.warning('Failed to open: ' + self.input_device_name())
                                warned = True
                        continue

                tries = 10
                for i in range(tries):
                    sampled = input_stream.read(Audio.input_frame_size, exception_on_overflow=False)
                    sampled = numpy.frombuffer(sampled, dtype=numpy.float32)
                    average = sum(numpy.abs(sampled)) / len(sampled)
                    if average != 0.0:
                        break
                    if i == tries-1:
                        Popup.warning("No input from audio device:\n  {name}".format(name=Audio.input_device_name()))
                        return

                resample_ratio = int(Audio.input_device_sample_rate() / Audio.k4_sample_rate)

            sampled = input_stream.read(Audio.input_frame_size * resample_ratio, exception_on_overflow=False)
            sampled = numpy.frombuffer(sampled, dtype=numpy.float32)

            if resample_ratio == 1:
                resampled = sampled
            elif resample_ratio == 2:
                s0 = sampled[0::2]
                s1 = sampled[1::2]
                resampled = (s0 + s1) / 2

            elif resample_ratio == 3:
                s0 = sampled[0::3]
                s1 = sampled[1::3]
                s2 = sampled[2::3]
                resampled = sum((s0, s1, s2)) / 3

            elif resample_ratio == 4:
                s0 = sampled[0::4]
                s1 = sampled[1::4]
                s2 = sampled[2::4]
                s3 = sampled[3::4]
                resampled = sum((s0, s1, s2, s3)) / 4

            resampled = resampled * self.mic_gain / 8  # apply some attenuation

            resampled = resampled.repeat(2)             # double-up samples. I consider this a K4 bug
            resampled_bytes = resampled.tobytes()

            frame_size = Audio.input_frame_size
            audio_packet = opus.encode_float(resampled_bytes, frame_size)

            if not self.transmit_audio:
                if input_stream != None:
                    input_stream.close()
                    input_stream = None
                return

            server.send_audio_packet(audio_packet, self.input_encode_mode, frame_size)

class Settings():
    max_servers = 25

    cached_server_count = None
    cached_server_index = None
    cached_main_settings = None
    cached_platform_settings_dirname = None

    restart = False

    @classmethod
    def server_count(cls):
        if cls.cached_server_count == None:
            cls.cached_server_count = len(cls.k4_names())
        return cls.cached_server_count

    @classmethod
    def server_index(cls, index=None):
        if index != None:
            cls.cached_server_index = index
            return

        if cls.cached_server_index == None:
            cls.cached_server_index = cls.main().getint('Remote', 'server_index', 0)
        return cls.cached_server_index

    @classmethod
    def main(cls):
        if cls.cached_main_settings == None:
            cls.cached_main_settings = Settings('main')
        return cls.cached_main_settings

    @classmethod
    def k4_names(cls):
        names = []
        active_indexes = []
        for i in range(cls.max_servers):
            settings = Settings(i)
            name = settings.get(Server.k4_section, 'name', '')
            if name != '':
                names.append(name)
                active_indexes.append(i)
        if len(active_indexes) > 0 and len(names) != active_indexes[-1] + 1:
            cls.rename_files(active_indexes)
            return cls.k4_names()
        return names

    @classmethod
    def rename_files(cls, active_indexes):
        for i, index in enumerate(active_indexes):
            if i != index:
                os.rename(cls.settings_pathname(index), cls.settings_pathname(i))
                if cls.server_index() > i:
                    cls.server_index(cls.server_index()-1)
                    cls.main().put_save('Remote', 'server_index', Server.index)

    @classmethod
    def restarting(cls, restart=None):
        if restart != None:
            Settings.restart = restart
            return
        return Settings.restart

    @classmethod
    def platform_settings_dirname(cls):
        if cls.cached_platform_settings_dirname != None:
            return cls.cached_platform_settings_dirname

        if sys.platform == 'darwin':
            from AppKit import NSSearchPathForDirectoriesInDomains
            # http://developer.apple.com/DOCUMENTATION/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSSearchPathForDirectoriesInDomains
            # NSApplicationSupportDirectory = 14
            # NSUserDomainMask = 1
            # True for expanding the tilde into a fully qualified path
            config_dir = os.path.join(NSSearchPathForDirectoriesInDomains(14, 1, True)[0], appname)
        elif sys.platform == 'win32':
            config_dir = os.path.join(os.environ['APPDATA'], appname)
        elif sys.platform == 'linux':
            home_dir = os.path.expanduser('~')
            config_dir = os.path.join(home_dir, '.config')
            if os.path.isdir(config_dir):
                config_dir = os.path.join(config_dir, appname)
            else:
                config_dir = os.path.join(home_dir, '.' + appname)
        else:
            raise exception(f'{sys.platform} not supported.')

        if not os.path.isdir(config_dir):
            os.mkdir(config_dir, 0o755)

        cls.cached_platform_settings_dirname = config_dir
        return config_dir

    @classmethod
    def settings_pathname(cls, index):
        config_dir = cls.platform_settings_dirname()
        if index == 'main':
            suffix = ''
        else:
            suffix = f'-{index+1}'
        return os.path.join(config_dir,f'settings{suffix}.ini')

    def __init__(self, index=None):
        self.settings = configparser.RawConfigParser()
        self.settings.optionxform = str
        self.settings_loaded = False
        self.settings_changed = False

        main_pathname = Settings.settings_pathname('main')
        if index == 'main':
            self.pathname = main_pathname
        else:
            main_settings = Settings.main()
            if index == None:
                index = main_settings.getint('Remote', 'server_index', 0)
                if index > Settings.server_count() or index >= Settings.max_servers:
                    index = 0
                    main_settings.put_save('Remote', 'server_index', index)
                Settings.server_index(index)
            self.pathname = Settings.settings_pathname(index)
            if index == 0:
                # Check for old settings.ini format
                if os.path.isfile(main_pathname) and not os.path.isfile(self.pathname):
                    if main_settings.settings.has_section('Elecraft K4'):
                        os.rename(main_pathname, self.pathname)
                        main_settings.clear()
                        main_settings.put_save('Remote', 'server_index', index)
        self.index = index
        self.load()

    def put(self, section, setting, value):
        if not self.settings_loaded and os.path.isfile(self.pathname):
            self.load()
        value = str(value)
        if not section in self.settings:
            self.settings[section] = {}
        previous_value = self.settings[section].get(setting, None)
        if value != previous_value:
            self.settings[section][setting] = value
            self.settings_changed = True

    def put_save(self, section, setting, value):
        self.put(section, setting, value)
        self.save()

    def get(self, section, setting, default=None):
        self.load()
        if section not in self.settings:
            return default
        if setting not in self.settings[section]:
            return default
        return self.settings[section][setting]

    def getbool(self, section, setting, default=None):
        return true_values(self.get(section, setting, default))

    def getint(self, section, setting, default=None, minimum=None, maximum=None):
        val = self.get(section, setting, default)
        if val != None:
            val = int(val)
            if minimum != None and val < minimum:
                val = minimum
            if maximum != None and val > maximum:
                val = maximum
        return val

    def get_section(self, section):
        self.load()
        settings = {}
        try:
            for k, v in self.settings[section].items():
                settings[k] = v
        except:
            pass
        return settings

    def clear(self):
        for section in self.settings.sections():
            self.settings.remove_section(section)

    def clear_section(self, section):
        self.settings.remove_section(section)

    def save(self):
        if not self.settings_changed:
            return

        with open(self.pathname, 'w') as settingsfile:
            self.settings.write(settingsfile)
        self.settings_changed = False

    def load(self):
        if self.settings_loaded:
            return
        if self.index == 'main' and not os.path.isfile(self.pathname):
            self.put_save('Remote', 'server_index', 0)
        self.settings.read(self.pathname)
        self.settings_loaded = True

        # rename or removed obsolete options
        if self.settings.has_option('Remote', 'restart'):
            self.settings.remove_option('Remote', 'restart')
        if self.settings.has_section('command'):
            for option in self.settings.options('command'):
                value = self.get('command', option)
                if value != None:
                    self.put('Commands', option, value)

        # clean up obsolete categories
        if self.settings.remove_section('command'):
            self.settings_changed = True

        self.save()

    def unique_name(self, orig_name, new=False):
        names = list(Settings.k4_names())
        if not new and self.index < len(names):
            del names[self.index]
        name = orig_name
        for i in range(2, Settings.max_servers+1):
            if name not in names:
                break
            name = f'{orig_name} #{i}'
        return name

    def remove_file(self):
        if os.path.exists(self.pathname):
            os.remove(self.pathname)

class ServerSettings_widget(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        optional = [ 'label', 'leading', 'bg', 'fg', 'abg', 'afg',
            'selectbg', 'selectfg', 'font', 'label_font', 'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        self.selectbg = config_info.get('selectbg', self.bg)
        self.selectfg = config_info.get('selectfg', self.fg)

        self.frame = self.remote_settings()
        self.frame.grid(row=0, column=0, sticky='w')

    def remote_settings(self):
        frame = tk.LabelFrame(self.frame,
                              text='',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=2,
                              padx=2,
                              pady=2,
                              relief='raised')

        server_frame = self.select_server(frame)
        server_frame.grid(row=0, column=0, sticky='w', pady=2)

        name_frame = self.k4_name(frame)
        name_frame.grid(row=1, column=0, sticky='w', pady=2)

        address_frame = self.k4_address_settings(frame)
        address_frame.grid(row=2, column=0, sticky='w', pady=2)

        password_frame = self.k4_password_settings(frame)
        password_frame.grid(row=3, column=0, sticky='w', pady=2)

        proxy_frame = self.k4_proxy_settings(frame)
        proxy_frame.grid(row=4, column=0, sticky='w', pady=2)

        return frame

    def select_server(self, remote_frame):
        frame = tk.LabelFrame(remote_frame,
                              text='Remote K4',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=2,
                              padx=2,
                              pady=2,
                              relief='raised')

        self.dropdown = Dropdown_Widget(frame, bd=2, bg=self.bg,
            fg=self.fg, abg=self.abg, selectbg=self.selectbg, selectfg=self.selectfg,
            font=self.font(), justify='left', height=0)
        self.dropdown.grid(row=0, column=0)

        self.dropdown.select_callback(self.on_select_server)

        names = Settings.k4_names()
        if len(names) == 0:
            name = Server.settings.unique_name('K4', new=True)
            Server.settings.put_save(Server.k4_section, 'name', name)
            names = [name]

        if len(names) < Settings.max_servers:
            names.append('*new*')
        self.dropdown.values(names)
        self.dropdown.index(Settings.server_index())

        return frame

    def on_select_server(self, event):
        index = self.dropdown.index()
        Settings.server_index(index)
        Settings.main().put_save('Remote', 'server_index', index)
        if self.dropdown.value() == '*new*':
            settings = Settings(index)
            name = settings.unique_name('K4', new=True)
            settings.put_save(Server.k4_section, 'name', name)
        restart()

    def k4_name(self, remote_frame):
        frame = tk.LabelFrame(remote_frame,
                              text='Name',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=2,
                              padx=2,
                              pady=2,
                              relief='raised')

        self.k4_name_var = tk.StringVar()
        name = Server.settings.get(Server.k4_section, 'name', '')
        self.k4_name_var.set(name)

        names = list(self.dropdown.values())
        names[self.dropdown.index()] = name
        self.dropdown.values(names)
        self.dropdown.value(name)

        entry = tk.Entry(frame,
            textvariable=self.k4_name_var,
            bd=2,
            font=self.font(),
            justify='left',
            fg=self.fg,
            bg=self.bg)
        entry.grid(row=0, column=0, sticky='w')
        entry.bind('<Return>', self.set_k4_name)
        entry.bind('<FocusOut>', self.set_k4_name)

        label = tk.Label(frame,
                    text='(Erase name to remove.)',
                    bd='2',
                    font=self.font(),
                    fg=self.fg,
                    bg=None,
                    padx=2,
                    pady=2)
        label.grid(row=1, column=0, sticky='w')

        return frame

    def set_k4_name(self, event=None, name = None):
        if name == None:
            name = self.k4_name_var.get()

        previous_name = Server.settings.get(Server.k4_section, 'name', '')
        if name == previous_name:
            return

        if name == '*new*' or name in Settings.k4_names():
            if name == '*new*':
                msg = 'The name "*new*" is reserved.'
            else:
                msg = f'The name "{name} already exists.'
            Popup.warning(msg)

            self.k4_name_var.set(previous_name)
            return

        if name == '':
            Server.settings.remove_file()
            Settings.k4_names() # trigger renaming of files
            Settings.main().put_save('Remote', 'server_index', 0)
            restart()
            return

        name = Server.settings.unique_name(name)
        self.k4_name_var.set(name)

        Server.settings.put_save(Server.k4_section, 'name', name)
        self.server.set_name(name)

        values = list(self.dropdown.values())
        values[self.dropdown.index()] = name
        self.dropdown.values(values)
        self.dropdown.value(name)

    def get_k4_name(self):
        return self.k4_name_var.get()

    def k4_address_settings(self, remote_frame):
        frame = tk.LabelFrame(remote_frame,
                              text='Address[:Port]',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=2,
                              padx=2,
                              pady=2,
                              relief='raised')

        self.k4_address_var = tk.StringVar()
        k4_address = Server.settings.get(Server.k4_section, 'address', '')
        self.k4_address_var.set(k4_address)
        self.set_k4_server_address()

        entry = tk.Entry(frame,
            textvariable=self.k4_address_var,
            bd=2,
            font=self.font(),
            justify='left',
            fg=self.fg,
            bg=self.bg)
        entry.grid(row=0, column=0)
        entry.bind('<Return>', self.set_k4_server_address)
        entry.bind('<FocusOut>', self.set_k4_server_address)

        return frame

    def set_k4_server_address(self, event=None):
        address = self.k4_address_var.get()
        Server.settings.put_save(Server.k4_section, 'address', address)
        self.server.set_address(address)

    def k4_password_settings(self, remote_frame):
        frame = tk.LabelFrame(remote_frame,
                              text='Password',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=2,
                              padx=2,
                              pady=2,
                              relief='raised')

        self.password_var = tk.StringVar()
        pw = self.server.password_from_settings()
        if pw != '':
            self.server.set_password(pw)

        self.password_var.set(pw)
        entry = tk.Entry(frame,
            textvariable=self.password_var,
            bd=2,
            font=self.font(),
            show='*',
            justify='left',
            fg=self.fg,
            bg=self.bg)
        entry.grid(row=0, column=0)
        entry.bind('<Return>', self.set_k4_password)
        entry.bind('<FocusOut>', self.set_k4_password)

        return frame

    def set_k4_password(self, event=None):
        pw = self.password_var.get()
        h = Reversable_hash.hash(pw)
        Server.settings.put_save(Server.k4_section, 'insecure_password_hash', h)
        self.server.set_new_password(pw)

    def k4_proxy_settings(self, remote_frame):
        frame = tk.LabelFrame(remote_frame,
                              text='SOCKS5 Address:Port',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=2,
                              padx=2,
                              pady=2,
                              relief='raised')

        self.k4_proxy_var = tk.StringVar()
        k4_proxy = Server.settings.get(Server.k4_section, 'proxy_address')
        if k4_proxy == None:
            k4_proxy = ''

        self.k4_proxy_var.set(k4_proxy)
        self.set_k4_server_proxy()

        entry = tk.Entry(frame,
            textvariable=self.k4_proxy_var,
            bd=2,
            font=self.font(),
            justify='left',
            fg=self.fg,
            bg=self.bg)
        entry.grid(row=0, column=0)
        entry.bind('<Return>', self.set_k4_server_proxy)
        entry.bind('<FocusOut>', self.set_k4_server_proxy)

        return frame

    def set_k4_server_proxy(self, event=None):
        proxy = self.k4_proxy_var.get()
        if proxy != '':
            Server.settings.put_save(Server.k4_section, 'proxy_address', proxy)
        self.server.set_proxy(proxy)

class AppSettings_widget(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        optional = [ 'label', 'leading', 'bg', 'fg', 'abg', 'afg',
            'selectbg', 'selectfg', 'font', 'label_font', 'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        input_device_name = Server.settings.get('Audio', 'input_device_name')
        if input_device_name != None:
            Audio.set_input_device_name(input_device_name)

        output_device_name = Server.settings.get('Audio', 'output_device_name')
        if output_device_name != None:
            Audio.set_output_device_name(output_device_name)

        self.selectbg = config_info.get('selectbg', self.bg)
        self.selectfg = config_info.get('selectfg', self.fg)

        self._frame = self.audio_settings()
        self._frame.grid(row=0, column=0, sticky='w', pady=8)

    def audio_settings(self):
        frame = tk.LabelFrame(self.frame,
                              text='Audio Settings',
                              font=self.label_font(),
                              labelanchor='nw',
                              bd=2,
                              padx=2,
                              pady=2,
                              relief='raised')

        audio_input_frame = self.audio_input_settings(frame)
        audio_input_frame.grid(row=0, column=0, sticky='w')
        audio_output_frame = self.audio_output_settings(frame)
        audio_output_frame.grid(row=1, column=0, sticky='w', pady=4)
        audio_k4_control_frame = self.audio_k4_control_setting(frame)
        audio_k4_control_frame.grid(row=2, column=0, sticky='w')
        audio_buffered_packets_frame = self.audio_buffered_packets_setting(frame)
        audio_buffered_packets_frame.grid(row=3, column=0, sticky='w')

        return frame

    def audio_input_settings(self, frame):
        input_device_name = Server.settings.get('Audio', 'input_device_name')
        if input_device_name == None or Audio.input_device_index() < 0:
            input_device_name = Audio.input_device_name()

        input_frame = tk.LabelFrame(frame,
                                    text='Current Input Device',
                                    font=self.label_font(),
                                    labelanchor='nw',
                                    bd=2,
                                    padx=2,
                                    pady=2,
                                    relief='raised')

        # Define the style for this combobox widget
        stylename = str(self) + 'input.TCombobox'
        style = ttk.Style()
        style.configure(stylename, background=self.bg, foreground=self.fg, selectbackground=self.selectbg, selectforeground=self.selectfg, bd=(2,2,2,2))

        input_names = Audio.input_device_names()
        width = 0
        for name in input_names + [input_device_name]:
            if len(name) > width:
                width = len(name)

        self.input_val = tk.StringVar()
        self.input_val.set(input_device_name)

        input_combobox = ttk.Combobox(
                input_frame,
                textvar=self.input_val,
                font=self.font(),
                values=input_names,
                height=len(input_names),
                width=width,
                state='readonly',
                justify='left',
                style=stylename,
                )
        input_combobox.grid(row=1, column=0, sticky='w')

        self.input_val.trace('w', self.on_input_combobox_changed)

        return input_frame

    def on_input_combobox_changed(self, var, index, mode):
        input_name = self.input_val.get()
        if input_name == '':
            return

        Server.settings.put_save('Audio', 'input_device_name', input_name)
        Audio.set_input_device_name(input_name)

    def audio_output_settings(self, frame):
        output_device_name = Server.settings.get('Audio', 'output_device_name')
        if output_device_name == None or Audio.output_device_index() < 0:
            output_device_name = Audio.output_device_name()

        output_frame = tk.LabelFrame(frame,
                                     text='Current Output Device',
                                     font=self.label_font(),
                                     labelanchor='nw',
                                     bd=2,
                                     padx=2,
                                     pady=2,
                                     relief='raised')

        # Define the style for this combobox widget
        stylename = str(self) + 'output.TCombobox'
        style = ttk.Style()
        style.configure(stylename, background=self.bg, foreground=self.fg, selectbackground=self.selectbg, selectforeground=self.selectfg, bd=(2,2,2,2))

        output_names = Audio.output_device_names()
        width = 0
        for name in output_names + [output_device_name]:
            if len(name) > width:
                width = len(name)

        self.output_val = tk.StringVar()
        self.output_val.set(output_device_name)

        output_combobox = ttk.Combobox(
                output_frame,
                textvar=self.output_val,
                font=self.font(),
                values=output_names,
                height=len(output_names),
                width=width,
                state='readonly',
                justify='left',
                style=stylename,
                )
        output_combobox.grid(row=0, column=0, sticky='w')

        self.output_val.trace('w', self.on_output_combobox_changed)

        return output_frame

    def on_output_combobox_changed(self, var, index, mode):
        output_name = self.output_val.get()
        if output_name == '':
            return

        Server.settings.put_save('Audio', 'output_device_name', output_name)
        Audio.set_output_device_name(output_name)

    def audio_k4_control_setting(self, frame):
        setting = Server.settings.getbool('Audio', 'control_k4_audio_settings')
        if setting == None:
            setting = self.cat_only
        self.server.set_control_k4_audio(setting)

        control_frame = tk.LabelFrame(frame,
                                     text='Control K4 Audio Settings?',
                                     font=self.label_font(),
                                     labelanchor='nw',
                                     bd=2,
                                     padx=2,
                                     pady=2,
                                     relief='raised')

        # Define the style for this combobox widget
        stylename = str(self) + 'output.TCombobox'
        style = ttk.Style()
        style.configure(stylename, background=self.bg, foreground=self.fg, selectbackground=self.selectbg, selectforeground=self.selectfg, padding=(2,2,2,2))

        values = ('Yes', 'No')
        width = 3
        current_value = 'Yes' if setting else 'No'

        self.k4_control_audio_val = tk.StringVar()
        self.k4_control_audio_val.set(current_value)

        control_combobox = ttk.Combobox(
                control_frame,
                textvar=self.k4_control_audio_val,
                font=self.font(),
                values=values,
                height=len(values),
                width=width,
                state='readonly',
                justify='left',
                style=stylename,
                )
        control_combobox.grid(row=0, column=0, sticky='w')

        self.k4_control_audio_val.trace('w', self.on_k4_control_audio_combobox_changed)

        return control_frame

    def on_k4_control_audio_combobox_changed(self, var, index, mode):
        current_value = self.k4_control_audio_val.get()
        if current_value == '':
            return

        setting = current_value == 'Yes'

        Server.settings.put_save('Audio', 'control_k4_audio_settings', setting)
        self.server.set_control_k4_audio(setting)

    def audio_buffered_packets_setting(self, frame):
        current_value = Server.settings.getint('Audio', 'buffered_packets', 1, minimum=1, maximum=100)
        self.server.set_buffered_audio_packets(int(current_value))

        buffered_packets_frame = tk.LabelFrame(frame,
                                     text='Buffered Output Packets',
                                     font=self.label_font(),
                                     labelanchor='nw',
                                     bd=2,
                                     padx=2,
                                     pady=2,
                                     relief='raised')

        # Define the style for this combobox widget
        stylename = str(self) + 'output.TCombobox'
        style = ttk.Style()
        style.configure(stylename, background=self.bg, foreground=self.fg, selectbackground=self.selectbg, selectforeground=self.selectfg, padding=(2,2,2,2))

        values = ('1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '50', '100')
        width = 3

        self.buffered_packets_val = tk.StringVar()
        self.buffered_packets_val.set(str(current_value))

        buffered_packets_combobox = ttk.Combobox(
                buffered_packets_frame,
                textvar=self.buffered_packets_val,
                font=self.font(),
                values=values,
                height=len(values),
                width=width,
                state='readonly',
                justify='left',
                style=stylename,
                )
        buffered_packets_combobox.grid(row=0, column=0, sticky='w')

        self.buffered_packets_val.trace('w', self.on_buffered_packets_combobox_changed)

        return buffered_packets_frame

    def on_buffered_packets_combobox_changed(self, var, index, mode):
        current_value = self.buffered_packets_val.get()
        if current_value == '':
            return

        Server.settings.put_save('Audio', 'buffered_packets', current_value)
        self.server.set_buffered_audio_packets(int(current_value))
        restart()

class FWversions(Text):
    def __init__(self, config_info, container):

        config_info['justify'] = 'left'
        super().__init__(config_info, container)

        self.width = 0
        self.height = 1
        self.text = ''

        self.server.subscribe_response('RV;', self.on_received_versions)

    def on_received_versions(self, response):
        version = response.rstrip(';').lstrip('RV.')
        if len(version) > self.width:
            self.width = len(version)
        self.height += 1
        self.text += version + "\n"
        self.label.configure(text=self.text, height=self.height, width=self.width)

class Entry_Widget():
    def __init__(self, parent_frame, width=20, bd=2, justify='left', show='', font=Default.label_font, fg=Default.fg, bg=Default.bg):
        self.var = tk.StringVar()
        self.entry = tk.Entry(parent_frame, textvariable=self.var, width=width, bd=bd, justify=justify, show=show, font=font, fg=fg, bg=bg)

    def value(self, value=None):
        if value != None:
            self.var.set(value)
            self.entry.width = len(value)
        return self.var.get()

    def callback(self, callback):
        self.entry.bind('<Return>', callback)
        self.entry.bind('<FocusOut>', callback)

    def grid(self, **opts):
        self.entry.grid(**opts)

    def config(self, **opts):
        self.entry.config(*opts)

class Entry(Widget):
    def __init__(self, config_info, container):
        required = ['item']
        optional = ['width', 'show', 'bd', 'bg', 'fg', 'font',
            'justify', 'label', 'leading', 'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        width = config_info.get('width', 20)
        show = config_info.get('show', '')
        bd = config_info.get('bd', 2)
        font = config_info.get('font', Default.label_font)
        justify = config_info.get('justify', 'left')

        self.entry = Entry_Widget(self.frame, show=show, width=width, bd=bd, bg=self.bg, fg=self.fg, font=self.font(), justify=justify)

class Startup_cmds(Entry):
    def __init__(self, config_info, container):
        required = ['item']
        optional = ['width', 'show', 'bd', 'bg', 'fg', 'font', 'justify', 'label', 'leading']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        self.settings_key = config_info['item']
        self.entry.callback(self.get_cmds)
        self.entry.grid(row=0, column=0, sticky='w')

        self.load_settings()

    def get_cmds(self, response):
        self.cmds = self.entry.value()
        if self.cmds != '' and not self.cmds.endswith(';'):
            self.cmds += ';'

        self.save_settings()
        self.got_cmds()

    def got_cmds(self):
        self.server.startup_cmds = self.cmds

    def load_settings(self):
        self.cmds = Server.settings.get(Server.k4_section, self.settings_key)
        if self.cmds == None:
            self.cmds = 'TS1;'
        self.entry.value(self.cmds)
        self.got_cmds()

    def save_settings(self):
        Server.settings.put_save(Server.k4_section, self.settings_key, self.cmds)

class Exit_cmds(Startup_cmds):
    def __init__(self, config_info, container):
        super().__init__(config_info, container)
        self.entry.grid(row=1, column=0, sticky='w')

    def got_cmds(self):
        self.server.exit_cmds = self.cmds

class Dropdown_Widget():
    def __init__(self, parent_frame, height=10, bd=2, padx=0, justify='left',
        font=Default.label_font, fg=Default.fg, bg=Default.bg, abg=Default.abg,
        afg=Default.afg, selectbg=None, selectfg=None):
        if afg == None:
            afg = fg
        if selectbg == None:
            selectbg = bg
        if selectfg == None:
            selectfg = fg

        self.justify = justify

        # Define the style for this dropdown widget
        self.stylename = str(self) + '.TCombobox'
        self.style = ttk.Style()
        self.style.configure(self.stylename, background=bg, foreground=fg,
            selectbackground=selectbg, selectforeground=selectfg,
            padding=(2,2,2,2), margins=(20, 0, 20, 0))

        self.combobox = ttk.Combobox(
                parent_frame,
                font=font,
                width=0,
                height = height,
                state='readonly',
                justify=justify,
                style=self.stylename,
                )

    def value(self, value=None):
        if value != None:
            self.combobox.set(value)
        return self.combobox.get()

    def index(self, index=None):
        if index != None:
            self.combobox.current(index)
        return self.combobox.current()

    def values(self, values=None):
        if values != None:
            self.config(values=values)
        return self.combobox.cget('values')

    def select_callback(self, callback):
        self.combobox.bind('<<ComboboxSelected>>', callback)

    def grid(self, **opts):
        self.combobox.grid(**opts)

    def config(self, **opts):
        self.combobox.config(**opts)
        if 'values' in opts:
            width = 0
            for value in self.values():
                if len(value) > width:
                    width = len(value)
            self.combobox.config(width=int(width+2))

    def cget(self, **opts):
        return self.combobox.cget(*opts)

class Antenna(Widget):
    def __init__(self, config_info, container):
        self.ar_names = ('None', 'RX2', '=TX ANT', 'x', 'RX1', 'ANT1', 'ANT2', 'ANT3')
        self.rx_names = ('None', 'ANT1', 'ANT2', 'ANT3', 'RX1', 'RX2', '=TX ANT')
        self.tx_names = ('x', 'ANT1', 'ANT2', 'ANT3')
        self.rx_select_bases = {'main':'AR', 'sub':'AR$'}

        required = ['item', 'type']
        optional = ['bd', 'bg', 'fg', 'selectbg', 'selectfg', 'justify', 'height',
            'font', 'label', 'leading', 'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        bd = config_info.get('bd', 2)
        selectbg = config_info.get('selectbg', self.bg)
        selectfg = config_info.get('selectfg', self.fg)
        justify = config_info.get('justify', 'left')
        height = config_info.get('height', 10)
        self.kind = config_info['type']

        if self.kind in ('main', 'sub', 'tx'):
            self.dropdown = Dropdown_Widget(self.frame, bd=bd, bg=self.bg,
                fg=self.fg, abg=self.abg, selectbg=selectbg, selectfg=selectfg,
                font=self.font(), justify=justify, height=height)
            self.dropdown.grid(row=0, column=0)
        else:
            raise Exception(f'unknown type: {self.kind} in item antenna.')

        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        self.server.subscribe_responses('ACN1;ACN2;ACN3;ACN4;ACN5;', self.on_received_name)
        self.dropdown.select_callback(self.on_select)
        self.server.subscribe_response('AN;', self.on_k4_select_tx)

        if self.kind == 'tx':
            self.set_values_tx()
            self.server.subscribe_response('ACT;', self.on_k4_config_tx)
        elif self.kind == 'main':
            self.set_values_rx()
            self.server.subscribe_response('AR;', self.on_k4_select_rx)
            self.server.subscribe_response('ACM;', self.on_k4_config_rx)
        elif self.kind == 'sub':
            self.set_values_rx()
            self.server.subscribe_response('AR$;', self.on_k4_select_rx)
            self.server.subscribe_response('ACS;', self.on_k4_config_rx)

    def on_select(self, event):
        value = self.dropdown.value()
        if self.kind == 'tx':
            index = self.tx_short_names.index(value)
            cmd = f'AN{index};'
        else:
            index = self.rx_short_names.index(value)
            name = self.rx_names[index]
            ar_index = self.ar_names.index(name)
            cmd = f'{self.rx_select_bases[self.kind]}{ar_index};'
        self.server.send_cmds(cmd)

    def on_k4_select_rx(self, response):
        base = self.rx_select_bases[self.kind]
        ar_index = int(self.k4param(base))
        name = self.ar_names[ar_index]
        index = self.rx_names.index(name)
        value = self.rx_short_names[index]
        tx_index = int(self.k4param('AN'))

        if index == tx_index or value == '=TX ANT':
            value = self.tx_short_names[tx_index]

        self.dropdown.value(value)

    def on_k4_select_tx(self, response):
        if self.kind == 'tx':
            tx_index = int(self.k4param('AN'))
            value = self.tx_short_names[tx_index]
            self.dropdown.value(value)
        else:
            self.set_names()

    def on_k4_config_rx(self, response):
        self.set_values_rx()

    def on_k4_config_tx(self, response):
        self.set_values_tx()

    def set_names(self):
        self.tx_short_names = list(self.tx_names)
        for i in range(1, 4):
            name = self.k4param(f'ACN{i}')
            if name != '' and name != self.tx_names[i]:
                self.tx_short_names[i] = f'{i}:{name}'
            else:
                self.tx_short_names[i] = f'{self.rx_names[i]}'

        tx_index = int(self.k4param('AN'))
        self.rx_short_names = list(self.rx_names)

        for i in range(1, 6):
            tx = ' (TX)' if i == tx_index else ''
            name = self.k4param(f'ACN{i}')
            if name != '' and name != self.rx_names[i]:
                self.rx_short_names[i] = f'{i}:{name}{tx}'
            else:
                self.rx_short_names[i] = f'{i}:{self.rx_names[i]}{tx}'

        if self.kind == 'tx':
            self.set_values_tx()
        else:
            self.set_values_rx()

    def on_received_name(self, response):
        self.set_names()

    def set_values_rx(self):
        has_ATU = 'A' in self.k4param('OM')
        tx_ant = int(self.k4param('AN'))

        values = list(self.rx_short_names)
        if self.kind == 'main':
            mask = self.k4param('ACM')
        else:
            mask = self.k4param('ACS')
        if mask[0] == '0':
            for i in range(6, 0, -1):
                if not has_ATU and (i == 2 or i == 3) or mask[i] == '0':
                    values.pop(i)

        self.dropdown.values(values)

    def set_values_tx(self):
        has_ATU = 'A' in self.k4param('OM')
        if has_ATU:
            values = self.tx_short_names[1:]
            mask = self.k4param('ACT')
            if mask[0] == '0':
                for i in range(3, 0, -1):
                    if mask[i] == '0':
                        values.pop(i-1)
        else:
            values = self.tx_short_names[1:2]

        self.dropdown.values(values)

class TextButtons(Widget):
    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        self.bd = config_info.get('bd', 2)
        font = self.font()
        self.monospaced_font = ('DejaVu Sans Mono', font['size'])

        self.buttons = []
        self.config_buttons = []
        self.button_values = []
        self.button_labels = []
        self.button_width = None
        self.rows = None
        self.columns = None
        self.valid_characters = None

    def add_buttons(self, buttons, parent_frame, edit):
        for child in parent_frame.winfo_children():
            # Should be only one child: buttons_frame
            for grandchild in child.winfo_children():
                if not edit:
                    grandchild.unbind('<Button-1>')
                grandchild.unbind('<Return>')
            child.destroy()
        buttons_frame = tk.LabelFrame(parent_frame, text='', font=self.label_font(),
            labelanchor='nw', bd=1, padx=1, pady=1, relief='raised')
        buttons_frame.grid(row=0, column=0, sticky='w')

        for i in range(len(self.button_values), self.rows*self.columns):
            self.button_values.append('')
            self.button_labels.append('')

        buttons.clear()
        row = 0
        column = 0
        for i, value in enumerate(self.button_values):
            if row >= self.rows:
                break
            if i < 12:
                text = f'F{i+1}'
            else:
                text = ''
            font = scale_font(self.label_font(), 0.7)
            label_frame = tk.LabelFrame(buttons_frame, text=text, font=font,
                labelanchor='nw')
            label_frame.grid(row=row, column=column, sticky='w', padx=2, pady=2)
            button = tk.Text(label_frame, bd=0, padx=0, pady=0, bg=self.bg, fg=self.fg,
                             font=self.monospaced_font, height=1, width=self.button_width,
                             cursor='hand2', relief='raised', wrap='none')
            button.grid(row=0, column=0, sticky='w')
            buttons.append(button)
            self.load_button_value(buttons, i, edit=edit)
            column += 1
            if column >= self.columns:
                row += 1
                column = 0

    def add_config_vars(self, parent_frame):
        self.rows_var = tk.IntVar()
        self.rows_var.set(self.rows)
        frame = tk.Frame(parent_frame)
        frame.grid(row=0, column=0, padx=10)
        label = tk.Label(frame, text='Button Rows:', font=self.font(), bg=self.bg)
        label.grid(row=0, column=0, sticky='e')
        rows_entry = tk.Entry(frame, textvariable=self.rows_var, width=2, justify='right', font=self.font(), bg='yellow')
        rows_entry.grid(row=0, column=1, sticky='w')

        self.columns_var = tk.IntVar()
        self.columns_var.set(self.columns)
        frame = tk.Frame(parent_frame)
        frame.grid(row=0, column=1, padx=10, pady=3, sticky='w')
        label = tk.Label(frame, text='Button Columns:', font=self.font(), bg=self.bg)
        label.grid(row=0, column=0, sticky='e')
        entry = tk.Entry(frame, textvariable=self.columns_var, width=2, justify='right', font=self.font(), bg='yellow')
        entry.grid(row=0, column=1, sticky='w')

        self.button_width_var = tk.IntVar()
        self.button_width_var.set(self.button_width)
        frame = tk.Frame(parent_frame)
        frame.grid(row=1, column=0, padx=10, pady=3, sticky='w')
        label = tk.Label(frame, text='Button Width:', font=self.font(), bg=self.bg)
        label.grid(row=0, column=0, sticky='e')
        entry = tk.Entry(frame, textvariable=self.button_width_var, width=2, justify='right', font=self.font(), bg='yellow')
        entry.grid(row=0, column=1, sticky='w')

    def load_button_value(self, buttons, index, edit=False):
        value = self.button_values[index]
        label = self.button_labels[index]
        if label != '':
            value = f'{label} & {value}' if edit else label
        button = buttons[index]
        button.delete('1.0', tk.END)
        button.insert('1.0', value)
        button.see('1.0')
        if edit:
            button.config(bg='Yellow', state='normal', cursor='')
        else:
            button.config(bg=self.bg, state='disabled', cursor='hand2')
        button.bind('<Return>', lambda event: 'break')

    def button_label_value(self, button):
        value = button.get('1.0', tk.END).strip()
        fields = value.split('&', 1)
        if len(fields) == 2:
            label, value = fields
            label = label.strip()
            value = value.strip()
        else:
            label = ''
        return label, value

    def store_button_value(self, buttons, index):
        button = buttons[index]
        label, value = self.button_label_value(button)
        self.button_labels[index] = label
        self.button_values[index] = value
        if label != '':
            value = label
        button.config(state='normal')
        button.delete('1.0', tk.END)
        button.insert('1.0', value)
        button.see('1.0')
        button.config(bg=self.bg, state='disabled', cursor='hand2')
        self.save_settings()

    def valid_button_value(self, buttons, i):
        button = buttons[i]
        label, value = self.button_label_value(button)
        for c in value:
            if c.upper() not in self.valid_characters:
                Popup.warning(f'Character "{c}" not allowed in Button {i+1}')
                self.load_button_value(buttons, i, edit=True)
                return False
        return True

    def valid_button_values(self, buttons):
        for i, button in enumerate(buttons):
            if not self.valid_button_value(buttons, i):
                return False
        return True

    def on_save_button(self):
        if not self.valid_button_values(self.config_buttons):
            return
        for i, button in enumerate(self.config_buttons):
            self.store_button_value(self.config_buttons, i)
        try:
            self.rows = self.rows_var.get()
        except:
            self.rows_var.set(self.rows)
        try:
            self.columns = self.columns_var.get()
        except:
            self.columns_var.set(self.columns)
        try:
            self.button_width = self.button_width_var.get()
        except:
            self.button_width_var.set(self.button_width)

        self.add_buttons(self.buttons, self.buttons_frame, edit=False)
        self.add_buttons(self.config_buttons, self.config_buttons_frame, edit=True)

    def on_cancel_button(self):
        for i, button in enumerate(self.config_buttons):
            self.load_button_value(self.config_buttons, i, edit=True)
        self.rows_var.set(self.rows)
        self.columns_var.set(self.columns)
        self.button_width_var.set(self.button_width)
        self.add_buttons(self.buttons, self.buttons_frame, edit=False)
        self.add_buttons(self.config_buttons, self.config_buttons_frame, edit=True)

class CWText(tk.Text):
    def __init__(self, container, **kwargs):
        super().__init__(container, **kwargs)
        self.tag_config('space', wrap='char')

    def append(self, value):
        space_indexes = []
        for i, c in enumerate(value):
            if c == ' ':
                space_indexes.append(i)
        self.mark_set('old_end', tk.END)
        self.mark_gravity('old_end', tk.LEFT)
        previous_state = self.cget('state')
        self.config(state='normal')
        self.insert(tk.END, value)
        self.see('1.0')
        self.config(state=previous_state)
        for i in space_indexes:
            index = f'old_end+{i}c'
            self.tag_add('space', index)

    def scroll_up(self):
        width = self.cget('width')
        ax, ay, aw, ah, au = self.dlineinfo('1.0')
        high = width + 1
        low = 0
        while low <= high:
            mid = (high + low) // 2
            bx, by, bw, bh = self.bbox(f'1.{mid}')
            if by > ay:    # line-wrapped
                high = mid - 1
            else:
                low = mid + 1
        if by <= ay:
            mid += 1
        self.config(state='normal')
        self.delete('1.0', f'1.{mid}')
        self.config(state='disabled')
        return mid

    def text(self, clear=False):
        text = self.get('1.0', tk.END+'-1c')
        if clear:
            self.clear()
        return text

    def set(self, value):
        self.config(state='normal')
        self.delete('1.0', tk.END)
        self.insert('1.0', value)
        self.config(state='disabled')

    def clear(self):
        previous_state = self.cget('state')
        self.config(state='normal')
        self.delete('1.0', tk.END)
        self.config(state=previous_state)

class CW(TextButtons):
    tx_queue_max = 9
    tx_queue_low = 8
    singleton = None

    @classmethod
    def close_window(cls):
        if cls.singleton != None:
            cls.singleton.close()

    def __init__(self, config_info, container):
        required = ['item']
        optional = ['bd', 'bg', 'fg', 'font', 'label', 'leading', 'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        self.valid_characters = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-_,./?(+=%*!'

        self.load_settings()

        self.tx_poll_interval = None

        self.tx_line_len = self.text_width
        self.tx_send_offset = 0
        self.tx_remaining_count = 0
        self.sending = False

        CW.singleton = self
        self.is_open = False

        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def open(self):
        if self.is_open:
            return
        self.is_open = True
        self.top_level = tk.Toplevel(Page.top)
        self.top_level.protocol("WM_DELETE_WINDOW", self.hide)
        self.top_level.title(Page.top.title() + ' CW')
        self.top_level.resizable(False, False)
        self.frame = tk.Frame(self.top_level)
        self.frame.grid(row=0, column=0)
        self.notebook = self.notebook_frame(self.frame)
        self.notebook.grid(row=0, column=0)

        self.add_cw_tab()
        self.add_more_tab()
        self.add_config_tab()

        self.top_level.bind('<FocusIn>', self.focus_in)
        self.top_level.bind('<FocusOut>', self.focus_out)

        self.set_geometry()

    def focus_in(self, event=None):
        self.top_level.bind('<Key>', self.on_key_pressed)

    def focus_out(self, event=None):
        self.top_level.unbind('<Key>')
        for i in range(12):
            self.top_level.unbind(f'F{i+1}')

    def on_key_pressed(self, event):
        if self.current_tabname != 'CW':
            return
        elif self.top_level.focus_get() == self.entry_text:
            self.on_entry_text_modified(event)
        else:
            self.on_tx_text_modified(event)

    def add_cw_tab(self):
        self.cw_frame = tk.Frame(self.notebook)
        self.cw_frame.grid(row=0, column=0)
        self.add_tab(self.cw_frame, 'CW')

        self.main_enabled = False
        self.sub_enabled = False

        self.cw_controls_frame = tk.Frame(self.cw_frame)
        self.cw_controls_frame.grid(row=0, column=0, sticky='w')
        self.add_cw_controls(self.cw_controls_frame)

        self.buttons_and_text_frame = tk.Frame(self.cw_frame)
        self.buttons_and_text_frame.grid(row=1, column=0, sticky='w')

        self.buttons_frame = tk.Frame(self.buttons_and_text_frame)
        self.buttons_frame.grid(row=0, column=0, sticky='w')
        self.add_buttons(self.buttons, self.buttons_frame, edit=False)

        self.text_fields_frame = tk.Frame(self.buttons_and_text_frame)
        self.text_fields_frame.grid(row=1, column=0, sticky='w')
        self.add_text_fields(self.text_fields_frame)

        self.tx_send_offset = 0
        self.tx_remaining_count = 0
        self.sending = False

        self.server.subscribe_response('TD;', self.on_main_text_decode)
        self.server.subscribe_response('TD$;', self.on_sub_text_decode)
        self.server.subscribe_response('TB;', self.on_main_text_buffer)
        self.server.subscribe_response('TB$;', self.on_sub_text_buffer)
        self.server.subscribe_response('ACN1;', self.on_transmit_ack)
        self.server.subscribe_response('KS;', self.on_keyer_speed_change)

    def add_more_tab(self):
        self.more_frame = tk.Frame(self.notebook)
        self.more_frame.grid(row=0, column=0)
        self.add_tab(self.more_frame, 'More')

        cw_pitch_frame = tk.LabelFrame(self.more_frame, text='CW Pitch',
            font=self.label_font(), labelanchor='nw', bd=2, padx=1, pady=5, relief='raised')
        cw_pitch_frame.grid(row=0, column=0, sticky='w', padx=2, pady=2)

        cw_pitch_options = {
            'orient': 'horizontal', 'from': 300, 'to': 900,
            'length': 150, 'evalincrement': '10', 'showvalue': True,
            'evalcmd': '"CW{:02d};".format(int(int(value)/10))', 'evalresponse': 'int(value[2:4])*10',
            'bg': self.bg, 'fg': self.fg, 'font': self.font(),
        }
        self.cw_pitch = SliderWidget(self, cw_pitch_frame, cw_pitch_options)

        apf_width = self.apf_frame.winfo_width()
        # subtract 8 to account for extra width of LabelFrame
        self.cw_pitch.scale.config(length=apf_width-8)

        qsk_frame = tk.Frame(self.more_frame)
        qsk_frame.grid(row=1, column=0, sticky='nw', padx=2, pady=5)
        qsk_onoff_frame = tk.LabelFrame(qsk_frame, text='QSK',
            font=self.label_font(), labelanchor='nw', bd=2, padx=1, pady=1, relief='raised')
        qsk_onoff_frame.grid(row=0, column=0, sticky='nw', padx=2, pady=2)

        qsk_options = {
            'selections': [
                { 'text': 'On',  'cmd': 'VXC1;' },
                { 'text': 'Off', 'cmd': 'VXC0;' },
            ],
            'width': 3, 'bg': self.bg, 'fg': self.fg, 'font': self.font(),
        }
        ToggleWidget(self, qsk_onoff_frame, qsk_options)

        delay_frame = tk.LabelFrame(qsk_frame, text='Delay',
            font=self.label_font(), labelanchor='nw', bd=2, padx=1, pady=1, relief='raised')
        delay_frame.grid(row=0, column=1, sticky='w', padx=2, pady=2)

        delay_button_frame = tk.Frame(delay_frame)
        delay_button_frame.grid(row=0, column=0, sticky='nw')
        delay_button_options = {
            'selections': [
                {
                    'text': 'On',
                    'cmd': 'SDC1;',
                    'evalcmd': '"SDC1{d:03s};".format(d=self.k4param("SDC")[1:4])',
                    'evalresponse': '"SDC"+self.k4param("SDC")[0]+";"',
                },
                {
                    'text': 'Off',
                    'cmd': 'SDC0;',
                    'evalcmd': '"SDC0{d:03s};".format(d=self.k4param("SDC")[1:4])',
                    'evalresponse': '"SDC"+self.k4param("SDC")[0]+";"',
                },
            ],
            'width': 3, 'bg': self.bg, 'fg': self.fg, 'font': self.font(),
        }
        ToggleWidget(self, delay_button_frame, delay_button_options)

        delay_slider_frame = tk.Frame(delay_frame)
        delay_slider_frame.grid(row=0, column=1, sticky='w')
        delay_slider_options = {
            'orient': 'horizontal', 'from': 0, 'to': 2.55, 'length': 150,
            'evalincrement': '-.01', 'showvalue': True,
            'evalcmd': '"SDC{f}{d:03d};".format(f=self.k4param("SDC")[0], d=int(float(value)*100))',
            'evalresponse': 'float(value[4:7])/100',
            'bg': self.bg, 'fg': self.fg, 'font': self.font(),
        }
        SliderWidget(self, delay_slider_frame, delay_slider_options)

        decode_frame = tk.Frame(self.more_frame)
        decode_frame.grid(row=2, column=0, sticky='nw', padx=2, pady=5)

        main_decode_frame = tk.LabelFrame(decode_frame, text='Main Decode',
            font=self.label_font(), labelanchor='nw', bd=1, padx=1, pady=1, relief='raised')
        main_decode_frame.grid(row=0, column=0, sticky='w')
        main_wpm_frame = tk.LabelFrame(main_decode_frame, text='WPM',
            font=self.label_font(), labelanchor='nw', bd=1, padx=1, pady=1, relief='raised')
        main_wpm_frame.grid(row=0, column=0, sticky='nw')
        main_wpm_options = {
            'selections': [
                { 'text': ' Off', 'cmd': 'TD0;', 'evalcmd': '"TD0{v};".format(v=self.k4param("TD")[1:3])', 'evalresponse': 'value[0:3]+";"' },
                { 'text': '8-45', 'cmd': 'TD2;', 'evalcmd': '"TD2{v};".format(v=self.k4param("TD")[1:3])', 'evalresponse': 'value[0:3]+";"' },
                { 'text': '8-60', 'cmd': 'TD3;', 'evalcmd': '"TD3{v};".format(v=self.k4param("TD")[1:3])', 'evalresponse': 'value[0:3]+";"' },
                { 'text': '8-90', 'cmd': 'TD4;', 'evalcmd': '"TD4{v};".format(v=self.k4param("TD")[1:3])', 'evalresponse': 'value[0:3]+";"' },
            ],
            'width': 4, 'bg': self.bg, 'fg': self.fg, 'selectbg': self.bg, 'selectfg': self.fg, 'font': self.font(),
        }

        DropdownWidget(self, main_wpm_frame, main_wpm_options)

        main_threshold_frame = tk.LabelFrame(main_decode_frame, text='THR',
            font=self.label_font(), labelanchor='nw', bd=1, padx=1, pady=1, relief='raised')
        main_threshold_frame.grid(row=0, column=1, sticky='nw')
        main_threshold_options = {
            'selections': [
                { 'text': 'Auto', 'cmd': 'TD0;', 'evalcmd': '"TD{m}0{v};".format(m=self.k4param("TD")[0], v=self.k4param("TD")[2])',
                    'evalresponse': 'value[0:2]+value[3]+";"' },
                { 'text': '   1', 'cmd': 'TD1;', 'evalcmd': '"TD{m}1{v};".format(m=self.k4param("TD")[0], v=self.k4param("TD")[2])',
                    'evalresponse': 'value[0:2]+value[3]+";"' },
                { 'text': '   2', 'cmd': 'TD2;', 'evalcmd': '"TD{m}2{v};".format(m=self.k4param("TD")[0], v=self.k4param("TD")[2])',
                    'evalresponse': 'value[0:2]+value[3]+";"' },
                { 'text': '   3', 'cmd': 'TD3;', 'evalcmd': '"TD{m}3{v};".format(m=self.k4param("TD")[0], v=self.k4param("TD")[2])',
                    'evalresponse': 'value[0:2]+value[3]+";"' },
                { 'text': '   4', 'cmd': 'TD4;', 'evalcmd': '"TD{m}4{v};".format(m=self.k4param("TD")[0], v=self.k4param("TD")[2])',
                    'evalresponse': 'value[0:2]+value[3]+";"' },
                { 'text': '   5', 'cmd': 'TD5;', 'evalcmd': '"TD{m}5{v};".format(m=self.k4param("TD")[0], v=self.k4param("TD")[2])',
                    'evalresponse': 'value[0:2]+value[3]+";"' },
                { 'text': '   6', 'cmd': 'TD6;', 'evalcmd': '"TD{m}6{v};".format(m=self.k4param("TD")[0], v=self.k4param("TD")[2])',
                    'evalresponse': 'value[0:2]+value[3]+";"' },
                { 'text': '   7', 'cmd': 'TD7;', 'evalcmd': '"TD{m}7{v};".format(m=self.k4param("TD")[0], v=self.k4param("TD")[2])',
                    'evalresponse': 'value[0:2]+value[3]+";"' },
                { 'text': '   8', 'cmd': 'TD8;', 'evalcmd': '"TD{m}8{v};".format(m=self.k4param("TD")[0], v=self.k4param("TD")[2])',
                    'evalresponse': 'value[0:2]+value[3]+";"' },
                { 'text': '   9', 'cmd': 'TD9;', 'evalcmd': '"TD{m}9{v};".format(m=self.k4param("TD")[0], v=self.k4param("TD")[2])',
                    'evalresponse': 'value[0:2]+value[3]+";"' },
            ],
            'width': 4, 'bg': self.bg, 'fg': self.fg, 'selectbg': self.bg, 'selectfg': self.fg, 'font': self.font(),
        }
        DropdownWidget(self, main_threshold_frame, main_threshold_options)

        sub_decode_frame = tk.LabelFrame(decode_frame, text='Sub Decode',
            font=self.label_font(), labelanchor='nw', bd=1, padx=1, pady=1, relief='raised')
        sub_decode_frame.grid(row=0, column=1, sticky='nw')
        sub_wpm_frame = tk.LabelFrame(sub_decode_frame, text='WPM',
            font=self.label_font(), labelanchor='nw', bd=1, padx=1, pady=1, relief='raised')
        sub_wpm_frame.grid(row=0, column=0, sticky='nw')
        sub_wpm_options = {
            'selections': [
                { 'text': ' Off', 'cmd': 'TD$0;', 'evalcmd': '"TD$0{v};".format(v=self.k4param("TD$")[1:3])', 'evalresponse': 'value[0:4]+";"' },
                { 'text': '8-45', 'cmd': 'TD$2;', 'evalcmd': '"TD$2{v};".format(v=self.k4param("TD$")[1:3])', 'evalresponse': 'value[0:4]+";"' },
                { 'text': '8-60', 'cmd': 'TD$3;', 'evalcmd': '"TD$3{v};".format(v=self.k4param("TD$")[1:3])', 'evalresponse': 'value[0:4]+";"' },
                { 'text': '8-90', 'cmd': 'TD$4;', 'evalcmd': '"TD$4{v};".format(v=self.k4param("TD$")[1:3])', 'evalresponse': 'value[0:4]+";"' },
            ],
            'width': 4, 'bg': self.bg, 'fg': self.fg, 'selectbg': self.bg, 'selectfg': self.fg, 'font': self.font(),
        }

        DropdownWidget(self, sub_wpm_frame, sub_wpm_options)

        sub_threshold_frame = tk.LabelFrame(sub_decode_frame, text='THR',
            font=self.label_font(), labelanchor='nw', bd=1, padx=1, pady=1, relief='raised')
        sub_threshold_frame.grid(row=0, column=1, sticky='nw')
        sub_threshold_options = {
            'selections': [
                { 'text': 'Auto', 'cmd': 'TD$0;', 'evalcmd': '"TD${m}0{v};".format(m=self.k4param("TD$")[0], v=self.k4param("TD$")[2])',
                    'evalresponse': 'value[0:3]+value[4]+";"' },
                { 'text': '   1', 'cmd': 'TD$1;', 'evalcmd': '"TD${m}1{v};".format(m=self.k4param("TD$")[0], v=self.k4param("TD$")[2])',
                    'evalresponse': 'value[0:3]+value[4]+";"' },
                { 'text': '   2', 'cmd': 'TD$2;', 'evalcmd': '"TD${m}2{v};".format(m=self.k4param("TD$")[0], v=self.k4param("TD$")[2])',
                    'evalresponse': 'value[0:3]+value[4]+";"' },
                { 'text': '   3', 'cmd': 'TD$3;', 'evalcmd': '"TD${m}3{v};".format(m=self.k4param("TD$")[0], v=self.k4param("TD$")[2])',
                    'evalresponse': 'value[0:3]+value[4]+";"' },
                { 'text': '   4', 'cmd': 'TD$4;', 'evalcmd': '"TD${m}4{v};".format(m=self.k4param("TD$")[0], v=self.k4param("TD$")[2])',
                    'evalresponse': 'value[0:3]+value[4]+";"' },
                { 'text': '   5', 'cmd': 'TD$5;', 'evalcmd': '"TD${m}5{v};".format(m=self.k4param("TD$")[0], v=self.k4param("TD$")[2])',
                    'evalresponse': 'value[0:3]+value[4]+";"' },
                { 'text': '   6', 'cmd': 'TD$6;', 'evalcmd': '"TD${m}6{v};".format(m=self.k4param("TD$")[0], v=self.k4param("TD$")[2])',
                    'evalresponse': 'value[0:3]+value[4]+";"' },
                { 'text': '   7', 'cmd': 'TD$7;', 'evalcmd': '"TD${m}7{v};".format(m=self.k4param("TD$")[0], v=self.k4param("TD$")[2])',
                    'evalresponse': 'value[0:3]+value[4]+";"' },
                { 'text': '   8', 'cmd': 'TD$8;', 'evalcmd': '"TD${m}8{v};".format(m=self.k4param("TD$")[0], v=self.k4param("TD$")[2])',
                    'evalresponse': 'value[0:3]+value[4]+";"' },
                { 'text': '   9', 'cmd': 'TD$9;', 'evalcmd': '"TD${m}9{v};".format(m=self.k4param("TD$")[0], v=self.k4param("TD$")[2])',
                    'evalresponse': 'value[0:3]+value[4]+";"' },
            ],
            'width': 4, 'bg': self.bg, 'fg': self.fg, 'selectbg': self.bg, 'selectfg': self.fg, 'font': self.font(),
        }
        DropdownWidget(self, sub_threshold_frame, sub_threshold_options)

    def add_config_tab(self):
        self.config_frame = tk.Frame(self.notebook)
        self.config_frame.grid(row=0, column=0)
        self.add_tab(self.config_frame, 'Configure')

        top_frame = tk.Frame(self.config_frame)
        top_frame.grid(row=0, column=0, sticky='e')
        self.cancel_button = tk.Button(top_frame, bd='2', text='Cancel', font=self.font(),
            justify='center', relief='raised', fg=self.fg, bg=self.bg,
            padx=2, pady=2, command=self.on_cancel_button)
        self.cancel_button.grid(row=0, column=0, pady=1, sticky='e')

        self.save_button = tk.Button(top_frame, bd='2', text='Save', font=self.font(),
            justify='center', relief='raised', fg=self.fg, bg=self.bg,
            padx=2, pady=2, command=self.on_save_button)
        self.save_button.grid(row=0, column=1, pady=1, sticky='e')

        info_frame = tk.Frame(self.config_frame)
        info_frame.grid(row=1, column=0, pady=1, sticky='w')
        text = '''The first 12 values are bound to function keys.

If a value contains &, everything before the & is displayed
and everything after the & is sent.'''
        info = tk.Label(info_frame, text=text, justify='left',
            font=self.font(), bg=self.bg)
        info.grid(row=0, column=0, sticky='e')

        self.config_buttons_frame = tk.Frame(self.config_frame)
        self.config_buttons_frame.grid(row=2, column=0, pady=1, sticky='w')
        self.add_buttons(self.config_buttons, self.config_buttons_frame, edit=True)

        config_vars_frame = tk.Frame(self.config_frame)
        config_vars_frame.grid(row=3, column=0, pady=1, sticky='w')
        self.add_config_vars(config_vars_frame)

    def set_geometry(self):
        self.top_level.update_idletasks()
        w, h, x, y = split_geometry(self.top_level.geometry())
        Server.settings.load()
        geometry = Server.settings.get('Window', 'CW.geometry')
        if geometry == None:
            return
        _w, _h, x, y = split_geometry(geometry)
        screen_width = Page.top.winfo_screenwidth()
        screen_height = Page.top.winfo_screenheight()
        x_offset = screen_width - (x + w)
        y_offset = screen_height - (y + h)
        if x_offset < 0:
            x += x_offset
        if y_offset < 0:
            y += y_offset
        if x < 0:
            x = 0
        if y < 0:
            y = 0
        w, h = self.frame.winfo_width(), self.frame.winfo_height()
        geometry = f'{w}x{h}{x:+}{y:+}'
        self.top_level.geometry(geometry)

    def add_cw_controls(self, parent_frame):
        sidetone_frame = tk.LabelFrame(parent_frame, text='Sidetone Volume',
            font=self.label_font(), labelanchor='nw', bd=2, padx=1, pady=1, relief='raised')
        sidetone_frame.grid(row=0, column=0, sticky='nw', padx=2, pady=2)

        sidetone_options = {
            'orient': 'horizontal', 'from': 0, 'to': 60, 'length': 150,
            'showvalue': False, 'evalincrement': '1',
            'evalcmd': '"ML0{:03d};".format(int(float(value)))', 'evalresponse': 'float(value[3:6])',
            'bg': self.bg, 'fg': self.fg, 'font': self.font(),
        }
        self.sidetone = SliderWidget(self, sidetone_frame, sidetone_options)

        self.keyer_speed_frame = tk.LabelFrame(parent_frame, text='Keyer Speed',
            font=self.label_font(), labelanchor='nw', bd=2, padx=1, pady=1, relief='raised')
        self.keyer_speed_frame.grid(row=0, column=1, sticky='nw', padx=2, pady=2)

        keyer_speed_options = {
            'orient': 'horizontal', 'from': 8, 'to': 100, 'length': 150,
            'showvalue': False, 'evalincrement': '1',
            'evalcmd': '"KS{:03d};".format(int(float(value)))', 'evalresponse': 'float(value[2:5])',
            'bg': self.bg, 'fg': self.fg, 'font': self.font(),
        }
        self.keyer_speed = SliderWidget(self, self.keyer_speed_frame, keyer_speed_options)

        self.apf_frame = tk.Frame(parent_frame)
        self.apf_frame.grid(row=0, column=2, sticky='nw', padx=2, pady=2)

        main_apf_frame = tk.LabelFrame(self.apf_frame, text='Main APF',
            font=self.label_font(), labelanchor='nw', bd=1, padx=1, pady=1, relief='raised')
        main_apf_frame.grid(row=0, column=0, sticky='nw')
        main_apf_options = {
            'selections': [
                { 'text':    'Off', 'cmd': 'AP00;' },
                { 'text':  '30 Hz', 'cmd': 'AP10;', 'bg': 'yellow' },
                { 'text':  '50 Hz', 'cmd': 'AP11;', 'bg': 'yellow' },
                { 'text': '150 Hz', 'cmd': 'AP12;', 'bg': 'yellow' },
            ],
            'width': 6, 'bg': self.bg, 'fg': self.fg, 'font': self.font(),
        }
        ToggleWidget(self, main_apf_frame, main_apf_options)

        sub_apf_frame = tk.LabelFrame(self.apf_frame, text='Sub APF',
            font=self.label_font(), labelanchor='nw', bd=1, padx=1, pady=1, relief='raised')
        sub_apf_frame.grid(row=0, column=1, sticky='nw')
        sub_apf_options = {
            'selections': [
                { 'text':    'Off', 'cmd': 'AP$00;' },
                { 'text':  '30 Hz', 'cmd': 'AP$10;', 'bg': 'yellow' },
                { 'text':  '50 Hz', 'cmd': 'AP$11;', 'bg': 'yellow' },
                { 'text': '150 Hz', 'cmd': 'AP$12;', 'bg': 'yellow' },
            ],
            'width': 6, 'bg': self.bg, 'fg': self.fg, 'font': self.font(),
        }
        ToggleWidget(self, sub_apf_frame, sub_apf_options)

        self.autospot_frame = tk.Frame(parent_frame)
        self.autospot_frame.grid(row=0, column=3, sticky='w', padx=2, pady=2)
        spot_options = {
            'selections': [
                { 'text': 'Autospot', 'cmd': 'SP0;' },
                { 'text': 'Autospot', 'cmd': 'SP3;', 'bg': 'yellow' },
                { 'text': 'Autospot', 'cmd': 'SP1;' },
                { 'text': 'Autospot', 'cmd': 'SP3;', 'bg': 'yellow' },
                { 'text': 'Autospot', 'cmd': 'SP2;' },
                { 'text': 'Autospot', 'cmd': 'SP3;', 'bg': 'yellow' },
            ],
            'width': 8, 'bg': self.bg, 'fg': self.fg, 'abg': self.abg,
            'afg': self.afg, 'font': self.font(),

        }
        ToggleWidget(self, self.autospot_frame, spot_options)

    def add_text_fields(self, parent_frame):
        self.entry_frame = tk.LabelFrame(parent_frame, text='Delayed Tx (Press Enter key to send, Delete key to clear)',
            font=self.label_font(), labelanchor='nw', bd=2, padx=1, pady=1, relief='raised')
        self.entry_frame.grid(row=0, column=0, sticky='w', pady=5)
        self.entry_text = CWText(self.entry_frame, bd=self.bd, bg=self.bg, fg=self.fg,
            font=self.monospaced_font, height=self.entry_height, width=self.text_width, wrap='word')
        self.entry_text.grid(row=0, column=0, sticky='w')
        self.entry_text.bind('<Key>', self.on_entry_text_modified)

        self.tx_frame = tk.LabelFrame(parent_frame, text='Immediate Tx (Press Escape key to stop sending.)', font=self.label_font(),
             labelanchor='nw', bd=2, padx=1, pady=1, relief='raised')
        self.tx_frame.grid(row=1, column=0, sticky='w', pady=4)
        self.tx_text = CWText(self.tx_frame, bd=self.bd, bg=self.bg, fg=self.fg, font=self.monospaced_font,
            height=self.tx_height, width=self.text_width, wrap='word', state='disabled')
        self.tx_text.grid(row=0, column=0, sticky='w')
        self.tx_text.tag_config('underline', underline=1)

        self.main_frame = tk.LabelFrame(parent_frame, text='Main Rx', font=self.label_font(),
            labelanchor='nw', bd=2, padx=1, pady=1, relief='raised')
        self.main_text = CWText(self.main_frame, bd=self.bd, bg=self.bg, fg=self.fg, font=self.monospaced_font,
            height=self.rx_height, width=self.text_width, wrap=None, state='disabled')
        self.main_text.grid(row=0, column=0, sticky='w', pady=1)

        self.sub_frame = tk.LabelFrame(parent_frame, text='Sub Rx', font=self.label_font(),
            labelanchor='nw', bd=2, padx=1, pady=2, relief='raised')
        self.sub_text = CWText(self.sub_frame, bd=self.bd, bg=self.bg, fg=self.fg, font=self.monospaced_font,
            height=self.rx_height, width=self.text_width, wrap=None, state='disabled')
        self.sub_text.grid(row=0, column=0, sticky='w')

        self.config_cw_fields()

    def add_config_vars(self, parent_frame):
        super().add_config_vars(parent_frame)

        self.text_width_var = tk.IntVar()
        self.text_width_var.set(self.text_width)
        frame = tk.Frame(parent_frame)
        frame.grid(row=1, column=1, padx=10, pady=3, sticky='w')
        label = tk.Label(frame, text='Text Width:', font=self.font(), bg=self.bg)
        label.grid(row=0, column=0, sticky='e')
        entry = tk.Entry(frame, textvariable=self.text_width_var, width=2, justify='right', font=self.font(), bg='yellow')
        entry.grid(row=0, column=1, sticky='w')

        self.tx_height_var = tk.IntVar()
        self.tx_height_var.set(self.tx_height)
        frame = tk.Frame(parent_frame)
        frame.grid(row=2, column=0, padx=10, pady=3, sticky='w')
        label = tk.Label(frame, text='Tx lines:', font=self.font(), bg=self.bg)
        label.grid(row=0, column=0, sticky='e')
        entry = tk.Entry(frame, textvariable=self.tx_height_var, width=2, justify='right', font=self.font(), bg='yellow')
        entry.grid(row=0, column=1, sticky='w')

        self.rx_height_var = tk.IntVar()
        self.rx_height_var.set(self.rx_height)
        frame = tk.Frame(parent_frame)
        frame.grid(row=2, column=1, padx=10, pady=3, sticky='w')
        label = tk.Label(frame, text='Rx lines:', font=self.font(), bg=self.bg)
        label.grid(row=0, column=0, sticky='e')
        entry = tk.Entry(frame, textvariable=self.rx_height_var, width=2, justify='right', font=self.font(), bg='yellow')
        entry.grid(row=0, column=1, sticky='w')

        self.entry_height_var = tk.IntVar()
        self.entry_height_var.set(self.entry_height)
        frame = tk.Frame(parent_frame)
        frame.grid(row=3, column=0, padx=10, pady=3, sticky='w')
        label = tk.Label(frame, text='Entry lines:', font=self.font(), bg=self.bg)
        label.grid(row=0, column=0, sticky='e')
        entry = tk.Entry(frame, textvariable=self.entry_height_var, width=2, justify='right', font=self.font(), bg='yellow')
        entry.grid(row=0, column=1, sticky='w')

    def on_received_initial_parameters(self, response):
        self.server.subscribe_responses('MD;MD$;', self.on_mode_response)

    def hide(self):
        if self.is_open:
            self.top_level.withdraw()

    def show(self):
        if not self.is_open:
            self.open()
        else:
            self.top_level.deiconify()
            self.top_level.lift()
            Page.top.focus_set()

    def close(self):
        if not self.is_open:
            return

        self.save_geometry()

        self.focus_out()

        if self.tx_remaining_count > 0:
            self.stop_sending()
        Poll.remove(self.send_cw)
        self.server.unsubscribe_response('TD;', self.on_main_text_decode)
        self.server.unsubscribe_response('TD$;', self.on_sub_text_decode)
        self.server.unsubscribe_response('TB;', self.on_main_text_buffer)
        self.server.unsubscribe_response('TB$;', self.on_sub_text_buffer)
        self.server.unsubscribe_response('ACN1;', self.on_transmit_ack)
        self.server.unsubscribe_response('KS;', self.on_keyer_speed_change)

        self.is_open = False
        self.top_level.destroy()

    def save_geometry(self):
        self.top_level.update_idletasks()
        geometry = self.top_level.geometry()
        Server.settings.put_save('Window', 'CW.geometry', geometry)

    def load_button_value(self, buttons, index, edit=False):
        super().load_button_value(buttons, index, edit=edit)
        if not edit:
            send_button = lambda event, index=index: self.send_button(index)
            button = buttons[index]
            button.bind('<Button-1>', send_button)
            if index < 12:
                self.top_level.bind(f'<F{index+1}>', send_button)

    def store_button_value(self, buttons, index):
        super().store_button_value(buttons, index)
        self.save_settings()

    def on_mode_response(self, response=None):
        if self.tx_mode() in ('CW', 'CW-R'):
            self.show()
        else:
            self.hide()

    def tx_mode(self):
        base = 'MD'
        split = self.k4param('FT') == '1'
        if split:
            base += '$'
        mode_index = int(self.k4param(base))
        modes = ('', 'LSB', 'USB', 'CW', 'FM', 'AM', 'DATA', 'CW-R', '', 'DATA-R')
        mode = modes[mode_index]
# The following lines are commented out because we don't support sending CW in SSB yet.
#        if mode == 'LSB' or mode == 'USB':
#            if self.k4param('TR') == 'R':
#                cw_in_ssb = Menu.entry(104).current == 1
#                if cw_in_ssb:
#                    mode = 'CW'
#            else:
#                mode = f'{mode} Transmit'
        return mode

    def append_tx_text(self, s):
        tx_mode = self.tx_mode()
        if tx_mode in ('CW', 'CW-R'):
            self.tx_text.append(s)
        else:
            Popup.warning(f'Cannot transmit CW in {tx_mode} mode.')

    def send_button(self, index):
        value = self.button_values[index]
        if value == '':
            return
        value += ' '
        if self.tx_text.text() == '':
            self.tx_offset = 0
            self.tx_remaining_count = 0
        self.append_tx_text(value)
        self.send_cw()

    def send_cw(self):
        if not self.is_open:
            return

        if self.tx_remaining_count > CW.tx_queue_low:
            Poll.call(self.tx_poll_interval, self.send_cw)
            return

        max_tx_chars = CW.tx_queue_max - self.tx_remaining_count

        index = f'1.{self.tx_send_offset}'
        end_index = f'1.{self.tx_send_offset+max_tx_chars}'
        chunk = self.tx_text.get(index, end_index)
        chunk_len = len(chunk)
        if chunk_len > 0:
            self.tx_send_offset += chunk_len

            if self.tx_remaining_count == 0:
                chunk_len -= 1
            self.tx_remaining_count += chunk_len
            self.server.send_cmds(f'KY {chunk};ACN1;')
            self.sending = True
            Poll.call(self.tx_poll_interval, self.send_cw)
        else:
            self.update_sending_offset()

    def on_main_text_decode(self, response):
        previous = self.main_enabled
        if self.k4param('TD')[0] == '0':
            self.main_enabled = False
        else:
            self.main_enabled = True
        if self.main_enabled != previous:
            self.config_cw_fields()

    def on_sub_text_decode(self, response):
        previous = self.sub_enabled
        if self.k4param('TD$')[0] == '0':
            self.sub_enabled = False
        else:
            self.sub_enabled = True
        if self.sub_enabled != previous:
            self.config_cw_fields()

    def config_cw_fields(self):
        self.entry_text.config(width=self.text_width)
        self.tx_text.config(width=self.text_width)
        if self.main_enabled:
            self.main_frame.grid(row=2, column=0, sticky='w', pady=5)
            if self.sub_enabled:
                self.sub_frame.grid(row=3, column=0, sticky='w', pady=5)
            else:
                self.sub_frame.grid_forget()
        else:
            self.main_frame.grid_forget()
            if self.sub_enabled:
                self.sub_frame.grid(row=2, column=0, sticky='w', pady=5)
            else:
                self.sub_frame.grid_forget()

        self.apf_frame.grid(row=0, column=2, sticky='nw', padx=2, pady=2)
        self.autospot_frame.grid(row=0, column=3, sticky='w', padx=2, pady=2)

        Page.top.update_idletasks()
        apf_width = self.apf_frame.winfo_width()
        # subtract 8 to account for extra width of LabelFrame
        self.sidetone.scale.config(length=apf_width-8)
        self.keyer_speed.scale.config(length=apf_width-8)

        Page.top.update_idletasks()
        w, h, x, y = split_geometry(self.buttons_and_text_frame.winfo_geometry())
        window_width = x + w

        w, h, x, y = split_geometry(self.keyer_speed_frame.winfo_geometry())
        keyer_speed_right = x + w

        w, h, x, y = split_geometry(self.apf_frame.winfo_geometry())
        apf_width = w

        w, h, x, y = split_geometry(self.autospot_frame.winfo_geometry())
        autospot_width = w
        autospot_right = keyer_speed_right + apf_width + autospot_width

        if autospot_right > window_width:
            self.apf_frame.grid(row=1, column=0, sticky='w', padx=2, pady=2)
            self.autospot_frame.grid(row=1, column=1, sticky='w', padx=2, pady=2)

    def update_sending_offset(self):
        text = self.tx_text
        sending_offset = self.tx_send_offset - self.tx_remaining_count-1
        index = f'1.{sending_offset}'
        text.update_idletasks()
        if text.bbox(index) == None:            # is character not visible?
            deleted_count = text.scroll_up()
            self.tx_send_offset -= deleted_count
            sending_offset -= deleted_count
            index = f'1.{sending_offset}'

        self.tx_text.tag_remove('underline', '1.0', tk.END)
        self.tx_text.tag_add('underline', index)

    def on_transmit_ack(self, response):
        self.sending = False

    def on_text_buffer(self, response, widget):
        param = cmd_parameter(response).rstrip(';')
        if not self.sending:
            r = int(param[0])
            self.tx_remaining_count = r
            self.update_sending_offset()
        new_text = param[3:]
        if new_text == '':
            return

        widget.append(new_text)
        widget.update_idletasks()
        if widget.bbox('end-1c') == None:            # is last line invisible?
            widget.scroll_up()

    def on_main_text_buffer(self, response):
        self.on_text_buffer(response, self.main_text)

    def on_sub_text_buffer(self, response):
        self.on_text_buffer(response, self.sub_text)

    def on_entry_text_modified(self, event):
        if event.keysym in ('Return', 'Escape', 'Delete'):
            if event.keysym == 'Return':
                text = self.entry_text.text(clear=True)
                if not text.endswith(' '):
                    text += ' '
                if self.tx_text.text() == '':
                    self.tx_offset = 0
                    self.tx_remaining_count = 0
                self.append_tx_text(text)
                self.send_cw()
            elif event.keysym == 'Escape':
                self.stop_sending()
            elif event.keysym == 'Delete':
                self.entry_text.clear()
            return 'break'

        c = event.char
        if c < '\x20':     # ignore C-c, C-v, C-x, Home, End, etc.
            return
        if c.upper() not in self.valid_characters:
            Popup.warning(f'Character "{c}" not supported for CW')
            return 'break'

    def on_tx_text_modified(self, event):
        if event.keysym == 'Escape':
            self.stop_sending()
            return 'break'
        c = event.char
        if c == '\x08':
            pending_text = self.tx_text.text()
            offset = self.tx_send_offset - self.tx_remaining_count
            if (len(pending_text) - offset) > CW.tx_queue_max + 1:
                self.tx_text.set(pending_text[0:-1])
            return 'break'

        if c < '\x20':     # ignore C-c, C-v, C-x, Home, End, etc.
            return 'break'
        if c.upper() not in self.valid_characters + '\x7f':
            Popup.warning(f'Character "{c}" not supported for CW')
            return 'break'

        self.append_tx_text(c)
        self.send_cw()
        return 'break'

    def stop_sending(self, event=None):
        if self.tx_remaining_count == 0:
            return

        self.server.send_cmds('KY @;')
        pending_text = self.tx_text.text()
        offset = self.tx_send_offset - self.tx_remaining_count
        if offset == len(pending_text):
            return
        self.tx_text.clear()
        if offset > 1:
            offset -= 1
        word_begin = pending_text.rfind(' ', 0, offset)
        if word_begin < 0:
            word_begin = 0
        else:
            word_begin += 1
        text = pending_text[word_begin:] + self.entry_text.text(clear=True)
        self.entry_text.append(text)
        self.tx_send_offset = 0
        self.tx_remaining_count = 0

    def on_keyer_speed_change(self, response=None):
        # The length of a dit in seconds is 1.2 / wpm,
        # therefore the length of an E n mS is 1000 * 2.4 / wpm.
        # We want to poll at least as often as every charater.
        wpm = int(self.k4param('KS'))
        self.tx_poll_interval = int(1000 * 2.4 / float(wpm))
        self.keyer_speed_frame.config(text=f'Keyer: {wpm} WPM')

    def on_save_button(self):
        super().on_save_button()

        try:
            self.text_width = self.text_width_var.get()
        except:
            self.text_width_var.set(self.text_width)
        try:
            self.entry_height = self.entry_height_var.get()
        except:
            self.entry_height_var.set(self.entry_height)
        try:
            self.tx_height = self.tx_height_var.get()
        except:
            self.tx_height_var.set(self.tx_height)
        try:
            self.rx_height = self.rx_height_var.get()
        except:
            self.rx_height_var.set(self.rx_height)
        self.save_settings()
        self.config_cw_fields()
        self.set_geometry()
        self.select_tab('CW')

    def on_cancel_button(self):
        super().on_cancel_button()

        self.entry_height_var.set(self.entry_height)
        self.tx_height_var.set(self.tx_height)
        self.rx_height_var.set(self.rx_height)
        self.config_cw_fields()
        self.select_tab('CW')

    def load_settings(self):
        section = 'CW'

        self.rows = Server.settings.getint(section, 'button_rows', 5, minimum=1, maximum=20)
        self.columns = Server.settings.getint(section, 'button_columns', 4, minimum=1, maximum=20)
        self.button_width = Server.settings.getint(section, 'button_width', 15, minimum=5, maximum=60)
        self.text_width = Server.settings.getint(section, 'text_width', 65, minimum=10, maximum=150)
        self.entry_height = Server.settings.getint(section, 'entry_height', 3, minimum=1, maximum=20)
        self.tx_height = Server.settings.getint(section, 'tx_height', 3, minimum=1, maximum=20)
        self.rx_height = Server.settings.getint(section, 'rx_height', 3, minimum=1, maximum=20)

        self.button_values = []
        self.button_labels = []
        buttons = Server.settings.get(section, 'buttons')
        if buttons != None:
            values = buttons.split('\n')
        else:
            values = ('<KN>&(', '<AR>&+', '<BT>&=', '<AS>&%', '<SK>&*', '<VE>&!')
        for value in values:
            value = value.strip()
            if '|' in value:
                value = value.replace('|', '&')
            fields = value.split('&', 1)
            if len(fields) == 2:
                label, value = fields
                label = label.strip()
                value = value.strip()
            else:
                label = ''
            self.button_values.append(value)
            self.button_labels.append(label)
        total_buttons = self.rows * self.columns
        while len(self.button_values) < total_buttons:
            self.button_values.append('')
            self.button_labels.append('')

    def save_settings(self):
        section = 'CW'
        previous_settings = Server.settings.get_section(section)
        Server.settings.clear_section(section)

        Server.settings.put(section, 'button_rows', self.rows)
        Server.settings.put(section, 'button_columns', self.columns)
        Server.settings.put(section, 'button_width', self.button_width)
        Server.settings.put(section, 'text_width', self.text_width)
        Server.settings.put(section, 'entry_height', self.entry_height)
        Server.settings.put(section, 'tx_height', self.tx_height)
        Server.settings.put(section, 'rx_height', self.rx_height)

        values = []
        for i, value in enumerate(self.button_values):
            label = self.button_labels[i]
            if label != '':
                value = f'{label}&{value}'
            values.append(value)
        while True:
            ln = len(values)
            if ln <= 0:
                break
            if values[ln-1] != '':
                break
            values.pop()
        buttons = '\n '.join(values)
        Server.settings.put(section, 'buttons', buttons)

        settings = Server.settings.get_section(section)
        if settings != previous_settings:
            Server.settings.save()

class Macros(TextButtons):
    singleton = None

    @classmethod
    def close_window(cls):
        if cls.singleton != None:
            cls.singleton.close()

    def __init__(self, config_info, container):
        required = ['item']
        optional = ['bd', 'bg', 'fg', 'font', 'label', 'leading', 'padx', 'pady']
        validate_options(config_info, required, optional)

        super().__init__(config_info, container)

        self.valid_characters = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890$;-_,./?(+=%*!'

        self.section = 'Macros'
        self.load_settings()

        Macros.singleton = self
        self.is_open = False
        self.previous_tabname = None
        self.server.subscribe_received_initial_parameters(self.on_received_initial_parameters)

    def on_received_initial_parameters(self, response):
        self.server.subscribe_responses('!MACROS;', self.on_macros_cmd)
        self.open()
        self.show_or_hide()

    def show_or_hide(self):
        if self.enabled:
            self.show()
        else:
            self.hide()

    def on_macros_cmd(self, response):
        self.enabled = cmd_parameter(response) == 'ENABLE'
        Server.settings.put_save(self.section, 'enabled', self.enabled)
        self.show_or_hide()

    def open(self):
        if self.k4param('!MACROS') != 'ENABLE':
            self.server.update_k4_parameter('!MACROS', 'ENABLE')
        if self.is_open:
            return
        self.is_open = True
        self.top_level = tk.Toplevel(Page.top)
        self.top_level.protocol("WM_DELETE_WINDOW", self.hide)
        self.top_level.title(Page.top.title() + ' Macros')
        self.top_level.resizable(False, False)
        self.frame = tk.Frame(self.top_level)
        self.frame.grid(row=0, column=0)
        self.notebook = self.notebook_frame(self.frame)
        self.notebook.grid(row=0, column=0)

        self.add_macros_tab()
        self.add_config_tab()

        self.set_geometry()

    def add_macros_tab(self):
        self.macros_frame = tk.Frame(self.notebook)
        self.macros_frame.grid(row=0, column=0)
        self.add_tab(self.macros_frame, 'Macros')

        self.buttons_and_text_frame = tk.Frame(self.macros_frame)
        self.buttons_and_text_frame.grid(row=1, column=0, sticky='w')

        self.buttons_frame = tk.Frame(self.buttons_and_text_frame)
        self.buttons_frame.grid(row=0, column=0, sticky='w')
        self.add_buttons(self.buttons, self.buttons_frame, edit=False)

    def add_config_tab(self):
        config_frame = tk.Frame(self.notebook)
        config_frame.grid(row=0, column=0)
        self.add_tab(config_frame, 'Configure')

        self.config_frame = tk.Frame(config_frame)

        self.top_frame = tk.Frame(self.config_frame)
        self.top_frame.grid(row=0, column=0, sticky='e')
        self.cancel_button = tk.Button(self.top_frame, bd='2', text='Cancel', font=self.font(),
            justify='center', relief='raised', fg=self.fg, bg=self.bg,
            padx=2, pady=2, command=self.on_cancel_button)
        self.cancel_button.grid(row=0, column=0, pady=1, sticky='e')

        self.save_button = tk.Button(self.top_frame, bd='2', text='Save', font=self.font(),
            justify='center', relief='raised', fg=self.fg, bg=self.bg,
            padx=2, pady=2, command=self.on_save_button)
        self.save_button.grid(row=0, column=1, pady=1, sticky='e')

        info_frame = tk.Frame(self.config_frame)
        info_frame.grid(row=1, column=0, pady=1, sticky='w')
        text = '''The first 12 values are bound to function keys.

If a value contains &, everything before the & is displayed
and everything after the & is sent.'''
        info = tk.Label(info_frame, text=text, justify='left',
            font=self.font(), bg=self.bg)
        info.grid(row=0, column=0, sticky='e')

        self.config_buttons_frame = tk.Frame(self.config_frame)
        self.config_buttons_frame.grid(row=2, column=0, pady=1, sticky='w')
        self.add_buttons(self.config_buttons, self.config_buttons_frame, edit=True)

        config_vars_frame = tk.Frame(self.config_frame)
        config_vars_frame.grid(row=3, column=0, pady=1, sticky='w')
        self.add_config_vars(config_vars_frame)

    def on_tab_changed(self, event):
        super().on_tab_changed(event)
        if self.current_tabname == 'Configure':
            self.config_frame.grid(row=0, column=0)
            self.set_geometry()
        else:
            self.config_frame.grid_forget()
            self.set_geometry()
            if self.previous_tabname == 'Configure':
                self.close()
                self.open()
        self.previous_tabname = self.current_tabname

    def set_geometry(self):
        self.top_level.update_idletasks()
        w, h, x, y = split_geometry(self.top_level.geometry())
        Server.settings.load()
        geometry = Server.settings.get('Window', 'Macros.geometry')
        if geometry == None:
            return
        _w, _h, x, y = split_geometry(geometry)
        screen_width = Page.top.winfo_screenwidth()
        screen_height = Page.top.winfo_screenheight()
        x_offset = screen_width - (x + w)
        y_offset = screen_height - (y + h)
        if x_offset < 0:
            x += x_offset
        if y_offset < 0:
            y += y_offset
        if x < 0:
            x = 0
        if y < 0:
            y = 0
        w, h = self.frame.winfo_width(), self.frame.winfo_height()
        geometry = f'{w}x{h}{x:+}{y:+}'
        self.top_level.geometry(geometry)

    def hide(self):
        if self.is_open:
            if self.k4param('!MACROS') != 'DISABLE':
                self.server.update_k4_parameter('!MACROS', 'DISABLE')
            self.top_level.withdraw()

    def show(self):
        if not self.is_open:
            self.open()
        else:
            if self.k4param('!MACROS') != 'ENABLE':
                self.server.update_k4_parameter('!MACROS', 'ENABLE')
            self.top_level.deiconify()
            self.top_level.lift()
            self.top_level.focus_set()

    def close(self):
        if self.k4param('!MACROS') != 'DISABLE':
            self.server.update_k4_parameter('!MACROS', 'DISABLE')
        if not self.is_open:
            return
        self.is_open = False
        self.save_geometry()
        self.top_level.destroy()

    def save_geometry(self):
        self.top_level.update_idletasks()
        geometry = self.top_level.geometry()
        Server.settings.put_save('Window', 'Macros.geometry', geometry)

    def load_button_value(self, buttons, index, edit=False):
        super().load_button_value(buttons, index, edit=edit)
        if not edit:
            send_button = lambda event, index=index: self.send_button(index)
            button = buttons[index]
            button.bind('<Button-1>', send_button)
            if index < 12:
                self.top_level.bind(f'<F{index+1}>', send_button)
                Page.top.bind(f'<F{index+1}>', send_button)

    def store_button_value(self, buttons, index):
        super().store_button_value(buttons, index)
        self.save_settings()

    def send_button(self, index):
        value = self.button_values[index]
        label = self.button_labels[index]
        if label == '':
            label = value
        if label != '':
            Popup.popup(label, timeout=1000, color='white')

        if value == '':
            return
        if not value.endswith(';'):
            value += ';'
        self.server.send_cmds(value)

    def on_save_button(self):
        super().on_save_button()
        self.save_settings()
        self.select_tab('Macros')

    def on_cancel_button(self):
        super().on_cancel_button()
        self.select_tab('Macros')

    def load_settings(self):
        self.enabled = Server.settings.getbool(self.section, 'enabled', True)

        self.rows = Server.settings.getint(self.section, 'button_rows', 3, minimum=1, maximum=20)
        self.columns = Server.settings.getint(self.section, 'button_columns', 4, minimum=1, maximum=20)
        self.button_width = Server.settings.getint(self.section, 'button_width', 15, minimum=5, maximum=60)

        self.button_values = []
        self.button_labels = []
        buttons = Server.settings.get(self.section, 'buttons')
        if buttons != None:
            values = buttons.split('\n')
        else:
            values = ('Clear RIT/XIT & RC;RT0;XT0;', 'XIT +5 kHz & XT1;RO+5000;')
        for value in values:
            value = value.strip()
            fields = value.split('&', 1)
            if len(fields) == 2:
                label, value = fields
                label = label.strip()
                value = value.strip()
            else:
                label = ''
            self.button_values.append(value)
            self.button_labels.append(label)
        total_buttons = self.rows * self.columns
        while len(self.button_values) < total_buttons:
            self.button_values.append('')
            self.button_labels.append('')

    def save_settings(self):
        previous_settings = Server.settings.get_section(self.section)
        Server.settings.clear_section(self.section)

        Server.settings.put(self.section, 'button_rows', self.rows)
        Server.settings.put(self.section, 'button_columns', self.columns)
        Server.settings.put(self.section, 'button_width', self.button_width)

        values = []
        for i, value in enumerate(self.button_values):
            label = self.button_labels[i]
            if label != '':
                value = f'{label} & {value}'
            values.append(value)
        while True:
            ln = len(values)
            if ln <= 0:
                break
            if values[ln-1] != '':
                break
            values.pop()
        buttons = '\n '.join(values)
        Server.settings.put(self.section, 'buttons', buttons)

        settings = Server.settings.get_section(self.section)
        if settings != previous_settings:
            Server.settings.save()

# A simple reversable string hash function
# Not in any way cryptographically secure
class Reversable_hash():
    @classmethod
    def rhash(cls, n):
        return "%08x" % (n * 387420489 % 4000000000)

    @classmethod
    def un_rhash(cls, h):
        return int(h, 16) * 3513180409 % 4000000000

    @classmethod
    def hash(cls, s):
        hashes = []
        for c in s:
            hashes.append(cls.rhash(ord(c)))
        return ''.join(hashes)

    @classmethod
    def unhash(cls, s):
        i = 0
        chars = []
        for i in range(0, len(s), 8):
            h = s[i:i+8]
            chars.append(chr(cls.un_rhash(h)))
        return ''.join(chars)

class Config():
    main_block_name = ' main'

    @staticmethod
    def preprocess(filename):
        self = Config()
        return self.process(filename)

    def process(self, filename):
        self.filename = filename
        self.blocks = {}
        self.errors = 0

        block_stack = []
        current_block = { 'name':Config.main_block_name, 'lines':[] }
        self.blocks[Config.main_block_name] = current_block
        in_block = False
        line_count = 0
        with open(filename) as stream:
            while True:
                line = stream.readline()
                if line == '':
                    break
                line_count += 1
                match = re.search("^([ \t]*)#(define|end|include)([ \t]+([_A-Za-z][-_A-Za-z0-9]*)([ \t]*)(.*)$)?", line)
                if not match:
                    current_block['lines'].append(line)
                else:
                    indent = match.group(1)
                    directive = match.group(2)
                    after_directive = match.group(3)
                    block_name = match.group(4)
                    trailing = match.group(6)
                    if directive == 'define':
                        if indent != '':
                            dprint('Error ({filename}:{line_count}): #define must be in column 1'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif block_name == None:
                            dprint('Error ({filename}:{line_count}): Invalid block name after #define'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif trailing != '':
                            dprint('Error ({filename}:{line_count}): unexpected characters after #define {name}'.format(filename=filename, line_count=line_count, name=block_name))
                            self.errors += 1
                            continue
                        elif in_block:
                            pname = current_block['name']
                            dprint('Error ({filename}:{line_count}): #define {name}, encountered while defining {pname}'.format(filename=filename, line_count=line_count, name=block_name, pname=pname))
                            self.errors += 1
                            continue
                        elif block_name in self.blocks:
                            dprint('Error ({filename}:{line_count}): #define {name}, redefined. Previously defined at line {pline_count}'.format(filename=filename, line_count=line_count, name=block_name, pline_count=self.blocks[block_name]['line_count']))
                            self.errors += 1
                            continue

                        block_stack.append(current_block)
                        current_block = { 'name':block_name, 'lines':[], 'line_count':line_count }
                        self.blocks[block_name] = current_block
                        in_block = True
                    elif directive == 'end':
                        if not in_block:
                            dprint('Error ({filename}:{line_count}): #end encountered while not defining a block'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif after_directive != None:
                            dprint('Error ({filename}:{line_count}): extra characters found after #end'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        current_block = block_stack.pop()
                        if current_block['name']:
                            in_block = False
                    elif directive == 'include':
                        if block_name == None:
                            dprint('Error ({filename}:{line_count}): Invalid block name after #include'.format(filename=filename, line_count=line_count))
                            self.errors += 1
                            continue
                        elif trailing != '':
                            dprint('Error ({filename}:{line_count}): unexpected characters after #include {name}'.format(filename=filename, line_count=line_count, name=block_name))
                            self.errors += 1
                            continue
                        line = { 'indent':indent, 'block_name':block_name, 'line_count':line_count }
                        current_block['lines'].append(line)

        if in_block:
            block_name = current_block['name']
            dprint('Error ({filename}:{line_count}): End of file while defining block {block_name}'.format(filename=filename, line_count=line_count, block_name=block_name))
            self.errors += 1

        self.writing_blocks = {}
        indents = []

        if Options.yaml_file != None:
            with open(Options.yaml_file, 'w') as stream:
                self.write_block(stream, Config.main_block_name, '', 1)
        else:
            tmpfile = tempfile.TemporaryFile(mode='w+')
            self.write_block(tmpfile, Config.main_block_name, '', 1)

        if self.errors > 0:
            sys.exit()

        if Options.yaml_file != None:
            sys.exit()

        tmpfile.seek(0)
        return tmpfile

    def write_block(self, file, block_name, indent, line_count):
        if block_name in self.writing_blocks:
            previous_line_count = self.writing_blocks[block_name]
            dprint('Error ({filename}:{line_count}): #include {block_name}, recursively included, previously at {previous_line_count}'.format(filename=self.filename, line_count=line_count, block_name=block_name, previous_line_count=previous_line_count))
            self.errors += 1
            sys.exit()

        self.writing_blocks[block_name] = line_count

        block = self.blocks[block_name]
        for line in block['lines']:
            if isinstance(line, str):
                if line != "\n":
                    line = indent + line
                file.write(line)
            else:
                block_name = line['block_name']
                if block_name not in self.blocks:
                    line_count = line['line_count']
                    dprint('Error ({filename}:{line_count}): #include of undefined block {block_name}.'.format(filename=self.filename, line_count=line_count, block_name=block_name))
                    self.errors += 1
                    continue

                self.write_block(file, block_name, indent + line['indent'], line_count)

        del self.writing_blocks[block['name']]

def read_config(config_file_name):
    with Config.preprocess(config_file_name) as stream:
        try:
            config = yaml.safe_load(stream)
        except yaml.YAMLError as exc:
            dprint(exc)

        for config_info in config:
            item = config_info['item']
            if item == 'page':
                Page(config_info)
            elif item == 'server':
                Server(config_info)
            elif item == 'defaults':
                Default(config_info)
            else:
                raise Exception("Unexpected top level item '{item}' in '{filename}'.".format(item=item, filename=config_file_name))

def font_height(font):
    return font.metrics("linespace")

class poll_info():
    def __init__(self, interval, id=None):
        self.interval = interval
        self.id = id

class Poll():
    infos = {}

    def set_top(top):
        Poll.top = top

    def add(interval, callback, repeat=True):
        if callback in Poll.infos:
            Poll.remove(callback)

        callback_interval = interval
        if not repeat:
            callback_interval = None
        info = poll_info(callback_interval)
        Poll.infos[callback] = info

        info.id = Poll.top.after(interval, lambda: Poll.callback(callback))

    def remove(callback):
        info = Poll.infos.get(callback, None)
        if info == None:
            return
        Poll.top.after_cancel(info.id)
        del Poll.infos[callback]

    def remove_all():
        for callback in list(Poll.infos):
            try:
                Poll.remove(callback)
            except:
                pass

    def callback(callback):
        callback()
        info = Poll.infos.get(callback, None)
        if info == None or info.interval == None:
            try:
                del Poll.infos[callback]
            except:
                pass
        else:
            info.id = Poll.top.after(info.interval, lambda : Poll.callback(callback))

    def call(interval, callback):
        Poll.add(interval, callback, repeat=False)

class MyOptionParser(optparse.OptionParser):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        super().set_usage(optparse.SUPPRESS_USAGE)

    def error(self, str):
        print('Usage: k4companion [options]\n')
        self.print_help()
        print()
        super().error(str)

class Options():
    config_file = None
    verbose = 0
    debug = 0
    yaml_file = None

    @staticmethod
    def Parse():
        parser = MyOptionParser(version=version)
        parser.add_option('-c', '--config', dest='config_file', default='k4companion.yaml',
                          help="use config file FILE", metavar="FILE")
        parser.add_option('-v', '--verbose', action='count', dest='verbose', default = 0,
                          help="output additional status messages")
        parser.add_option('-d', '--debug', action='count', dest='debug', default=0,
                          help="output debugging messages")
        parser.add_option('--yaml', dest='yaml_file', default=None,
                          help="output preprocessed YAML to FILE", metavar="FILE")
        (options, args) = parser.parse_args()

        Options.config_file = options.config_file
        Options.verbose = options.verbose
        Options.debug = options.debug
        Options.yaml_file = options.yaml_file

        if Options.debug > 0 and Options.verbose == 0:
            Options.verbose = Options.debug

        if len(args) != 0:
            parser.error("Unexpected argument '{arg}'".format(arg=args[0]))

def clean_up(exit=False):
    save_geometry()
    server = Server.k4_server
    server.cancel_k4_subscriptions()
    if exit:
        server.exit()
    else:
        server.close()

    CW.close_window()
    Macros.close_window()
    Audio.close()
    Poll.remove_all()

def exit():
    clean_up(exit=True)
    Page.top.quit()

def save_geometry():
    Page.top.update_idletasks()
    geometry = Page.top.geometry()
    Server.settings.put_save('Window', 'root.geometry', geometry)

class Popup():
    queue = queue.Queue()
    poll_interval = 200          # 200 mS
    previous_popup = None

    @classmethod
    def show_popup(cls, msg, title, timeout, font, color, modal=False):
        if isinstance(msg, str):
            msg = [ msg ]
        msg = "\n\n".join(msg)
        popup = cls(title=title, timeout=timeout, font=font, color=color)
        label = tk.Label(popup.frame, text=msg, anchor='center', justify='left', font=font, bg=color)
        label.grid(row=0, column=0)
        if modal:
            popup.show_and_wait()
        else:
            popup.show()

    @classmethod
    def show_popups(cls):
        cls.remove_previous()
        cls.dequeue_popups()

    @classmethod
    def dequeue_popups(cls):
        while True:
            try:
                msg, title, timeout, font, color, modal = cls.queue.get_nowait()
                cls.show_popup(msg, title, timeout, font, color, modal)
            except queue.Empty:
                break

        Poll.call(cls.poll_interval, cls.dequeue_popups)

    @classmethod
    def popup(cls, msg='', title='', timeout=None, font=None, color='yellow', modal=False):
        if threading.current_thread() == threading.main_thread():
            cls.show_popup(msg, title, timeout, font, color, modal)
        else:
            cls.queue.put((msg, title, timeout, font, color, modal))

    @classmethod
    def warning(cls, msg, timeout=2000, modal=False):
        if isinstance(msg, str):
            msg = 'Warning: ' +  msg
        else:
            msg[0] = 'Warning: ' + msg[0]
        dprint(' '.join(msg))
        cls.popup(msg=msg, title='Warning', timeout=timeout, font=None, color='yellow', modal=modal)

    @classmethod
    def error(cls, msg, timeout=5000, modal=False, font=None):
        if isinstance(msg, str):
            msg = 'Error: ' +  msg
        else:
            msg[0] = 'Error: ' + msg[0]
        dprint(' '.join(msg))
        cls.popup(msg=msg, title='Error', timeout=timeout, font=font, color='yellow', modal=modal)

    @classmethod
    def modal(cls, msg, timeout=None):
        dprint(' '.join(msg))
        cls.popup(msg=msg, title='K4-Companion', timeout=timeout, font=None, color='yellow', modal=True)

    @classmethod
    def remove_previous(cls):
        if cls.previous_popup != None:
            try:
                cls.previous_popup.destroy()
            except:
                pass
            cls.previous_popup = None

    def __init__(self, title='', timeout=None, font=None, color='yellow', modal=False):
        self.__class__.remove_previous()
        if timeout == 0:
            timeout = None
        self.timeout = timeout
        self.popup = tk.Toplevel(Page.top)
        self.popup.title(title)
        if font == None:
            font = Page.main().font()
        size = font.cget('size')
        self.frame = tk.Frame(self.popup, padx=size*2, pady=size*2, bg=color)
        self.popup.attributes('-topmost', True)
        self.__class__.previous_popup = self.popup

    def show(self):
        self.frame.grid()
        if self.timeout != None:
            Poll.call(self.timeout, self.popup.destroy)

    def show_and_wait(self):
        self.frame.grid()
        if self.timeout != None:
            Poll.call(self.timeout, self.popup.destroy)
        self.frame.wait_window()

    def close(self, event=None):
        self.popup.destroy()

    def password_button_clicked(self):
       if self.password_show_button.cget('text') == 'Show':
           self.password_show_button.configure(text='Hide')
           self.password_entry.configure(show='')
       else:
           self.password_show_button.configure(text='Show')
           self.password_entry.configure(show='*')

    def password_entered(self, event=None):
        if self.password_var.get() != '':
            self.close()

    def password(msg='', title='', font=None, color='yellow'):
        if isinstance(msg, str):
            msg = [ msg ]
        msg = "\n\n".join(msg)
        popup = Popup(title=title, font=font, color=color, modal=True)
        label = tk.Label(popup.frame, text=msg, anchor='w', justify='left', font=font, bg=color)
        label.grid(row=0, column=0, sticky='w')
        var = tk.StringVar()
        frame = tk.Frame(popup.frame, bg=color)
        frame.grid(row=1, column=0, sticky='w')
        entry = tk.Entry(frame, textvariable=var, show='*', justify='left', font=font, bg=color)
        entry.grid(row=0, column=0)
        entry.focus()
        entry.bind('<Return>', popup.password_entered)
        show_button = tk.Button(frame, text='Show', font=font, bg=color,
                                command=popup.password_button_clicked)
        show_button.grid(row=0, column=1)
        submit_button = tk.Button(popup.frame, text='Submit', font=font, bg=color,
                                command=popup.close)
        submit_button.grid(row=2, column=0, sticky='w')
        popup.password_var = var
        popup.password_entry = entry
        popup.password_show_button = show_button
        popup.frame.grid()
        popup.popup.transient(Page.top)
        popup.popup.grab_set()
        popup.popup.protocol('WM_DELETE_WINDOW', popup.close)
        popup.popup.resizable(False, False)
        Page.top.wait_window(popup.popup)
        return var.get()

class Timer():
    timers = {}

    @classmethod
    def timer(cls, name):
        return cls.timers.get(name, None)

    def __init__(self, name, entries):
        self.entries = entries
        self.times = []
        self.index = 0
        for i in range(0, entries):
            self.times.append(0)
        self.timers[name] = self

    def add(self):
        self.times[self.index] = time.time_ns()

        self.index += 1
        if self.index >= self.entries:
            self.index = 0

    def values(self):
        return self.times

    def deltas(self):
        deltas = []
        for i in range(self.entries):
            if i == 0:
                previous = self.entries - 1
            else:
                previous = i - 1
            deltas.append(self.times[i] - self.times[previous])

        return deltas

def validate_options(dictionary, requireds, optional, name=None):
    if name == None:
        name = dictionary['item']

    id = ''
    for key in ['label', 'text', 'tabname']:
        if key in dictionary:
            id = dictionary[key]
            break

    optional.extend(requireds)
    for option in dictionary.keys():
        if option not in optional:
            raise Exception("Unrecognized option '{option}' in item '{name}'{id}.".format(option=option, name=name, id=id))

    for option in requireds:
        if option not in dictionary or dictionary[option] == None:
            if id != '':
                id = ' ({id})'.format(id=id)
            raise Exception("Required option '{option}' missing in item '{name}'{id}.".format(option=option, name=name, id=id))

def hex_decode(string):
    return re.sub('%(..)', lambda m: chr(int(m[1], 16)), string)

def mouse_wheel_mult(event):
    if sys.platform == 'linux':
        mult = 1 if event.num == 4 else -1
    elif sys.platform == 'win32':
        mult = -event.delta // 120
    elif sys.platform == 'darwin':
        mult = 1 if event.delta > 0 else -1
    return mult

def scale_font(font, scale):
    family = font.cget('family')
    size = int(round(font.cget('size') * scale))
    weight = font.cget('weight')
    return tkFont.Font(family=family, size=size, weight=weight)

def dprint(*args, **kwargs):
    try:
        # fails in a pyinstaller bundle while stderr is closed
        print(*args, file=stderr, **kwargs)
    except:
        # ignore that failure
        pass

def dprint1(*args, **kwargs):
    if Options.debug >= 1:
        dprint(*args, **kwargs)

def dprint2(*args, **kwargs):
    if Options.debug >= 2:
        dprint(*args, **kwargs)

def dprint3(*args, **kwargs):
    if Options.debug >= 3:
        dprint(*args, **kwargs)

def dprint4(*args, **kwargs):
    if Options.debug >= 4:
        dprint(*args, **kwargs)

def vprint1(*args, **kwargs):
    if Options.verbose >= 1:
        dprint(*args, **kwargs)

def vprint2(*args, **kwargs):
    if Options.verbose >= 2:
        dprint(*args, **kwargs)

def tprint(*args, **kwargs):
    dprint(*args, **kwargs)

def trace_stack():
    traceback.print_stack()
    
def start():
    Poll.set_top(Page.top)
    Popup.show_popups()

    Server()

    script_directory = pathlib.Path(__file__).parent.resolve()
    config_file = Options.config_file
    alt_config_file = os.path.join(script_directory, config_file)
    if not os.path.isfile(config_file) and os.path.isfile(alt_config_file):
        config_file = alt_config_file

    if not os.path.isfile(config_file):
        font = Default.button_font
        font = tkFont.Font(family=font['family'], size=font['size'], weight=font['weight'])
        Popup.error(f'Configuration file "{config_file}" not found.',
                    modal=True, font=font)
        sys.exit()

    read_config(config_file)

    page = Page.main()
    server = page.server
    Server.settings = Settings()
    if server.connect_on_start() and server.connect():
        server.subscribe_received_initial_parameters(lambda x: page.show_page(page.name))
    else:
        page.select_tab('Server')
        Page.show_page(page.name)

def restart():
    clean_up()
    Settings.restarting(True)
    Page.main().frame.destroy()
    start()

def close_splash_screen():
    try:
        import pyi_splash
        pyi_splash.close()
    except ImportError:
        pass

def split_geometry(geometry):
    m = re.search('([^x]+)x([^+]+)[+]([-]?[^+-]+)[+]?(.*)', geometry)
    w, h, x, y = m.groups()
    return int(w), int(h), int(x), int(y)

def set_page_title(server_name):
    Page.top.title(f'K4-Companion {version} [{server_name}]')

def main():
    close_splash_screen()

    Options.Parse()

    top = tk.Tk()
    Page.top = top
    Page.top.unbind_class('Button', '<space>')
    Page.top.unbind_class('Combobox', '<space>')

    Server.settings = Settings()
    geometry = Server.settings.get('Window', 'root.geometry')
    if geometry != None:
        Page.top.geometry(geometry)

    Page.top.protocol("WM_DELETE_WINDOW", exit)
    Page.top.resizable(False, False)

    start()

    top.mainloop()

if __name__ == '__main__':
    main()

# vim: set expandtab ts=4 sw=4:
