#!/usr/bin/env python3

# k4macro provides a set of buttons, each of which when clicked will
# send a macro string to the Elecraft K4 via TCP/IP.  It is capable of
# sending string commands to multiple servers, one or more which may
# be transceivers. These macros can be simple or complex. This program
# was inspired by K4 Macromaster, but in no way duplicates all of its
# functions. K4 Macro was initially created by Charles W. Powell, NK8O,
# but has been heavily modified. Charles has graciously allowed me
# to continue development and to release it under the GPL.
#
# Configuration information is maintained in a separate YAML file named,
# by default, k4macro.yaml.  Dale, W7DA
#
# Copyright (C) 2025  Dale Farnsworth  dale@farnsworth.org
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

import ctypes
import math
import queue
import select
import socket
import sys
import textwrap
import threading
import time
import tkinter as tk
import tkinter.font as tkFont
import yaml

from optparse import OptionParser

version = '1.0.17'

class Default():
# may be overriden by values in the config file
    bg = 'maroon1'
    abg = 'red'
    fg = 'black'
    afg = None        # None means same as fg
    selectcolor = 'red'
    label_font =  { 'family': 'Helvetica', 'size': 8, 'weight': 'normal' }
    button_font = { 'family': 'Helvetica', 'size': 10, 'weight': 'normal' }

    def __init__(self, config_info):
        Default.bg = config_info.get('bg', Default.bg)
        Default.abg = config_info.get('abg', Default.abg)
        Default.fg = config_info.get('fg', Default.fg)
        Default.afg = config_info.get('afg', Default.afg)
        Default.selectcolor = config_info.get('selectcolor', Default.selectcolor)
        Default.label_font = config_info.get('label_font', Default.label_font)
        Default.button_font = config_info.get('button_font', Default.button_font)

class Server():
    server_dict = {}
    default_server_name = None
    k4_long_base_params = {
            '#A': ['#AR', '#AVG'],
            'AC': ['ACM', 'ACS', 'ACT', 'ACN'],
            '#C': ['#CAL', '#CUR'],
            '#D': ['#DPM', '#DSM'],
            'DN': ['DNB'],
            '#F': ['#FPS', '#FRZ', '#FXA', '#FXT'],
            '#H': ['#HDPM', '#HDSM', '#HREF', '#HWBS', '#HWFC', '#HWFH'],
            'KZ': ['KZL', 'KZF'],
            'LO': ['LOG'],
            'ME': ['MEDF'],
            '#M': ['#MP'],
            '#N': ['#NBL', '#NB'],
            'PC': ['PCX'],
            '#P': ['#PKM'],
            '#R': ['#REF'],
            'RR': ['RRT', 'RRC', 'RRP'],
            'SM': ['SMH'],
            '#S': ['#SCL', '#SFL', '#SPM', '#SPN'],
            'SW': ['SWT', 'SWH'],
            'UP': ['UPB'],
            '#V': ['#VFA', '#VFB'],
            '#W': ['#WBS', '#WFC', '#WFH'],
            'XV': ['XVN', 'XVM', 'XVR', 'XVI', 'XVO', 'XVP '],
        }

    @staticmethod
    def server(server_name):
        return Server.server_dict[server_name]

    @staticmethod
    def server_names():
        return Server.server_dict.keys()

    @staticmethod
    def servers():
        return Server.server_dict.values()

    @staticmethod
    def default():
        return Server.server(Server.default_server_name)

    @staticmethod
    def send_cmds_with_server(cmd_list):
        for server_name, cmds in cmd_list:
            if server_name in Server.server_names():
                server = Server.server(server_name)
                server.send_cmds(cmds)
            elif server_name == 'delay':
                delay = float(cmd_dict[server_name]) / 1000
                time.sleep(delay)
            else:
                raise Exception("Unknown server name '{name}'".format(name=server_name))

    @staticmethod
    def split_cmd(cmd):
        if cmd[-1] == ';':
            cmd = cmd[0:-1]
        return cmd.split(';')

    def __init__(self, config_info):
        self.name = config_info['name']
        self.type = config_info.get('type', '').lower()
        self.address = config_info['address']
        self.port = config_info['port']
        self.startup = config_info.get('startup', None)
        self.socket = None
        self.recv_buffer = ''
        self.send_queue = queue.Queue()
        self.recv_queue = queue.Queue()
        self.send_thread = None
        self.recv_thread = None
        self.connected = False
        self.param_subscriptions = {}

        if self.type == 'k4':
            self.k4_params = {}

        if Server.default_server_name == None:
            Server.default_server_name = config_info['name']
        Server.server_dict[self.name] = self

    def update_k4_param(self, param):
        base = param_base(param)
        old = self.k4_params.get(base, None)
        self.k4_params[base] = param

        if old != param:
            callbacks = self.param_subscriptions.get(base, [])
            for callback in callbacks:
                callback(param + ';')
            return True
        else:
            return False

    def connect(self):
        vprint1('Connecting to {name}, address {addr}, port {port}'.format(
              name=self.name, addr=self.address, port=self.port))

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            sock.settimeout(5)
            sock.connect((self.address, self.port))
            self.connected = True
            self.socket = sock
            self.send_thread = threading.Thread(target=self.send_loop, name=self.name+'.send_thread')
            self.send_thread.start()
            self.recv_thread = threading.Thread(target=self.recv_loop, name=self.name+'.recv_thread')
            self.recv_thread.start()
            if self.type == 'k4':
                self.send_str('K41;')               # request K4 to respond in advanced mode
                self.send_str('AI2;AID060;')        # request K4 to send updates every 60 mS
                if self.startup != None:
                    self.send_cmds(self.startup)     # send user-specified startup commands
                Poll.add_poll_callback(1, self.receive)
        except socket.gaierror:
            print('Address not found: {addr}'.format(addr=self.address))
            if not Options.debug > 0:
                cleanup_and_exit()
        except OSError:
            print('Failed to connect to {name}, address {addr}, port {port}'.format(
                  name=self.name, addr=self.address, port=self.port))
            if not Options.debug > 0:
                cleanup_and_exit()

    def close(self):
        self.connected = False
        self.send_queue.put('shutdown')
        if self.send_thread != None:
            self.send_thread.join()
        if self.recv_thread != None:
            self.recv_thread.join()

    def send_str(self, cmd):
        self.send_queue.put(cmd)

    def send_cmds(self, cmds):
        if not self.connected:
            print("Server '{name}' not connected.".format(cmd=cmd, name=self.name))
        if isinstance(cmds, str):
            cmds = [cmds]
        for cmd in cmds:
            if cmd == '':
                continue
            if self.update_k4_param(cmd):
                cmd += ';'
                self.send_str(cmd)

    def send_loop(self):
        while True:
            cmd = self.send_queue.get()
            if not self.connected:
                return
            try:
                self.socket.sendall(cmd.encode())
                dprint1('{name}: sent: {cmd}'.format(name=self.name, cmd=cmd))
            except OSError:
                print("Failed to send command, '{cmd}' to '{name}'".format(cmd=cmd, name=self.name))

    def expand_cmds(self, cmds):
        if isinstance(cmds, str):
            return [[self.name, Server.split_cmd(cmds)]]
        elif isinstance(cmds, dict):
            cmd_dict = cmds
            ret = []
            for name in cmd_dict:
                cmd = cmd_dict[name]
                ret.append(name, Server.split_cmd(cmd_dict[name]))
            return ret
        elif isinstance(cmds, list):
            ret = []
            for cmd_dict in cmds:
                if not isinstance(cmd_dict, dict):
                    raise Exception("Unknown server sub-command '{cmd}'".format(cmd=cmd_dict))
                for name in cmd_dict:
                    cmd = cmd_dict[name]
                    ret.append(name, Server.split_cmd(cmd_dict[name]))
            return ret
        else:
            raise Exception("Error: bad cmd format: '{cmd}'".format(cmd=cmd))

    def expand_server_cmds(self, cmds):
        if isinstance(cmds, str):
            return Server.split_cmd(cmds)
        ret = []
        for name, cmds in self.expand_cmds(cmds):
            if name == self.name:
                ret.extend(cmds)
        return ret

    def expand_and_send_cmds(self, cmds):
        expanded_cmds = self.expand_cmds(cmds)
        Server.send_cmds_with_server(expanded_cmds)

    def cmd_bases(self, cmds):
        bases = []
        expanded_cmds = self.expand_cmds(cmds)
        for server_name, cmds in expanded_cmds:
            if server_name != self.name:
                continue
            for cmd in cmds:
                bases.append(param_base(cmd))
        return bases

    def subscribe_cmds(self, cmds, callback):
        bases = self.cmd_bases(cmds)
        for base in bases:
            self.subscribe_response(base, callback)

    def receive(self):
        while True:
            try:
                responses = self.recv_queue.get_nowait()
                for response in responses:
                    if self.type == 'k4':
                        if self.update_k4_param(response):
                            continue
                    # For now, ignore responses from non-K4 servers
            except queue.Empty:
                break

    def recv_loop(self):
        while True:
            responses = []
            readable, writable, in_error = select.select([self.socket.fileno()], [], [self.socket], 1)
            if not self.connected:
                return
            if len(in_error) > 0:
                raise Exception("Socket error reading from server '{name}'".format(name=self.name))
            if len(readable) == 0:
                continue

            recv_bytes = self.socket.recv(4096)
            if len(recv_bytes) == 0:
                self.connected = False
                return

            if self.type != 'k4':
                dprint1('{name}: received: {bytes}'.format(name=self.name, bytes=recv_bytes))
                try:
                    self.recv_queue.put([recv_bytes])
                except queue.ShutDown:
                    continue
            else:
                recv_str = recv_bytes.decode()
                dprint1('{name}: received: {str}'.format(name=self.name, str=recv_str))
                recv_strs = recv_str.split(';')
                if len(recv_strs) == 0:
                    continue

                if recv_strs[-1] == '':
                    partial_response = recv_strs[-1]
                    responses = recv_strs[0:-1]
                else:
                    responses = recv_strs
                if partial_response != '':
                    response[0] += partial_response
                    partial_response = ''

                self.recv_queue.put(responses)

    def subscribe_response(self, base, callback):
        if not base in self.param_subscriptions:
            self.param_subscriptions[base] = []
        param = self.k4_params.get(base, None)
        if param != None:
            callback(param)
        self.send_str(base + ';')
        if callback in self.param_subscriptions[base]:
            raise Exception('duplicate subscription for {base}: {callback}'.format(base=base, callback=callback))
        self.param_subscriptions[base].append(callback)

    def unsubscribe_response(self, base, callback):
        self.param_subscriptions[base].remove(callback)

class Container():
    depth = -1

    def __init__(self, config_info, container):
        self.config_info = config_info
        self.container = container
        self.columns = config_info.get('columns', len(self.config_info['contains']))
        self.row = 0
        self.column = 0

        self.label_font = None
        self.button_font = None

    def next_column(self):
        self.column += 1
        if self.column >= self.columns:
            self.column = 0
            self.next_row()

    def next_row(self):
        self.row += 1

    def show_widgets(self):
        Container.depth += 1
        for config_info in self.config_info['contains']:
            widget_type = config_info['item'].lower()
            if widget_type == 'group':
                if Options.debug > 0:
                    label = config_info.get('label', '')
                    indent = '    ' * Container.depth
                    dprint('{indent}group {label}: row  {row}, column: {column}'.format(indent=indent, label=label, row=self.row, column=self.column))
                Group(config_info, self)
            elif widget_type == 'button':
                Button(config_info, self)
            elif widget_type == 'radiobutton':
                Radiobutton(config_info, self)
            elif widget_type == 'vfo':
                VFO(config_info, self)
            elif widget_type == 'slider':
                Slider(config_info, self)

            self.next_column()
        Container.depth -= 1

    def items_width(self):
        width = 0
        for config_info in self.config_info['contains']:
            text = str(config_info.get('text', ''))
            if len(text) > width:
                width = len(text)
        return width

class Page(Container):
    pages = {}
    name_stack = []
    current_frame = None
    top = None

    @staticmethod
    def show(page_name):
        if page_name in Page.pages:
            Page.name_stack.append(page_name)
            Page.pages[page_name].instance_show()
        else:
            print("Page:'{name}' not found.".format(name=page_name))

    @staticmethod
    def show_previous():
        if len(Page.name_stack) < 2:
            return
        Page.name_stack.pop()             # pop current page
        page_name = Page.name_stack.pop()
        Page.show(page_name)

    def __init__(self, config_info):
        super().__init__(config_info, None)

        self.frame = None

        Page.pages[config_info['name']] = self

        self.label_font = config_info.get('label_font', Default.label_font)
        self.button_font = config_info.get('button_font', Default.button_font)

    def instance_show(self):
        if Page.current_frame != None:
            Page.current_frame.destroy()
        self.frame = tk.Frame(Page.top)
        self.frame.grid()
        self.show_widgets()
        Page.current_frame = self.frame

class Group(Container):
    def __init__(self, config_info, container):
        super().__init__(config_info, container)
        container = self.container
        frame = container.frame

        if 'column' in config_info:
            column = config_info['column']
            if column < container.column:
                container.next_row()
            container.column = column
        else:
            column = container.column

        row = config_info.get('row', container.row)
        columnspan = config_info.get('columnspan', 1)
        rowspan = config_info.get('rowspan', 1)
        self.label_font = config_info.get('label_font', container.label_font)
        self.button_font = config_info.get('button_font', container.button_font)

        font = tkFont.Font(family=self.label_font['family'], size=self.label_font['size'], weight=self.label_font['weight'])

        if 'label' in config_info:
            label = config_info['label']
            self.frame = tk.LabelFrame(frame,
                                       text=label,
                                       font=font,
                                       labelanchor='nw',
                                       bd=2,
                                       relief='raised')
        else:
            self.frame  = tk.Frame(frame)

        self.frame.grid(row=row,
                        column=column,
                        rowspan=rowspan,
                        columnspan=columnspan,
                        sticky='w')
        self.show_widgets()

class Widget():
    def __init__(self, config_info, container):
        self.config_info = config_info
        self.container = container
        self.bg = None
        self.abg = None
        self.fg = None
        self.afg = None

class Button(Widget):
    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        text = str(config_info.get('text', ''))
        cmd = config_info.get('cmd', None)
        directive = config_info.get('directive', None)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg
        button_font = config_info.get('font', config_info.get('button_font', container.button_font))

        server_name = config_info.get('server', Server.default_server_name)
        self.server = Server.server(server_name)

        width = container.items_width()
        if len(text) > width:
            text = textwrap.fill(text, width)

        special_strings = {
            'quit': cleanup_and_exit,
            'show_previous_page': Page.show_previous,
        }

        if directive != None:
            if directive in special_strings:
                command = special_strings[directive]
            elif directive.startswith('show_page '):
                page_name = directive[len('show_page '):]
                command = lambda: Page.show(page_name)
            else:
                print('Unknown directive: ', directive)

        if cmd != None:
            command = lambda: self.server.expand_and_send_cmds(cmd)

        font = tkFont.Font(family=button_font['family'], size=button_font['size'], weight=button_font['weight'])

        button = tk.Button(container.frame,
                    bd='4',
                    text=text,
                    font=font,
                    width=width,
                    relief='raised',
                    fg=fg,
                    bg=bg,
                    activebackground=abg,
                    activeforeground=afg,
                    padx=2,
                    pady=2,
                    command=command)

        button.grid(row=container.row, column=container.column, sticky='w')

class Radiobutton(Widget):
    radiobutton_responses = {}
    variables = {}
    response_callbacks = []
    button_counter = 0

    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        Radiobutton.button_counter += 1

        self.text = str(config_info.get('text', ''))
        self.cmd = config_info.get('cmd', None)
        self.response = config_info.get('response', self.cmd)
        indicator = config_info.get('indicator', 1)
        selectcolor = config_info.get('selectcolor', Default.selectcolor)
        self.group_id = config_info.get('groupid', None)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg

        button_font = config_info.get('font', config_info.get('button_font', container.button_font))

        server_name = config_info.get('server', Server.default_server_name)
        self.server = Server.server(server_name)

        self.params = {}

        if not self.group_id in Radiobutton.variables:
            Radiobutton.variables[self.group_id] = tk.StringVar
        variable = Radiobutton.variables[self.group_id]

        width = container.items_width()
        if len(self.text) > width:
            wrapped_text = textwrap.fill(self.text, width)
        else:
            wrapped_text = self.text

        font = tkFont.Font(family=button_font['family'], size=button_font['size'], weight=button_font['weight'])

        self.button = tk.Radiobutton(container.frame,
                    bd='4',
                    text=wrapped_text,
                    font=font,
                    width=width,
                    relief='raised',
                    fg=fg,
                    bg=bg,
                    activebackground=abg,
                    activeforeground=afg,
                    padx=2,
                    pady=2,
                    command=self.on_clicked,
                    indicator=indicator,
                    selectcolor=selectcolor,
                    variable=variable,
                    value=Radiobutton.button_counter)

        self.button.grid(row=container.row, column=container.column, sticky='w')

        for response in self.server.expand_server_cmds(self.response):
            base = param_base(response)
            self.params[base] = response
            if base.startswith('SW'):
                raise Exception("'SW' not permitted in Radiobutton command: '{cmd}'".format(cmd=self.response))

        self.server.subscribe_cmds(self.response, self.on_response_received)

    def on_clicked(self):
        if self.cmd != None:
            self.server.expand_and_send_cmds(self.cmd)

    def compare_params(self, group, text):
        params = self.params
        for base in params.keys():
            dprint2('commpare {group}:{text} s: {s}, b: {b}'.format(group=group, text=text, s=self.server.k4_params.get(base, None), b=params[base]))
            if params[base] != self.server.k4_params.get(base, None):
                dprint2('No match')
                return False
        dprint2('Match')
        return True

    def on_response_received(self, response):
        if self.compare_params(self.group_id, self.text):
            self.button.select()
        else:
            self.button.deselect()

class VFO(Widget):
    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        self.AorB = config_info.get('AorB', 'A').upper()
        server_name = config_info.get('server', Server.default_server_name)
        self.server = Server.server(server_name)

        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        vfo_font = config_info.get('font', container.button_font)

        self.increment = .1

        frame = tk.Frame(container.frame)

        font = tkFont.Font(family=vfo_font['family'], size=vfo_font['size'], weight=vfo_font['weight'])

        self.vfo_sb = tk.Spinbox(
                frame,
                from_=100,
                to=54000,
                wrap=False,
                command=self.on_vfo_change,
                increment=self.increment,
                font=font,
                width=9,
                repeatdelay=300,
                repeatinterval=1,
                format='%5.3f',
                justify='right',
                state='normal',
                cursor='hand2',
                fg=fg,
                bg=bg,
                )

        self.vfo_sb.grid(row=0, column=0, sticky='w')

        set_font = tkFont.Font(family=vfo_font['family'], size=int(vfo_font['size']/3), weight='bold')

        set_button = tk.Button(frame,
                    bd='1',
                    text="S\nE\nT",
                    font=set_font,
                    relief='flat',
                    justify='left',
                    fg=fg,
                    bg=bg,
                    padx=1,
                    pady=1,
                    command=self.on_vfo_change)

        set_button.grid(row=0, column=1, sticky='w')

        self.delta_map = { '1 Hz': .001, '10 Hz': .01, '100 Hz': .1, '1 kHz': 1, '10 kHz': 10, '100 kHz': 100 }

        self.delta_sb = tk.Spinbox(
                frame,
                command=self.on_delta_change,
                values= tuple(self.delta_map.keys()),
                font=font,
                width=7,
                format='%5.3f',
                justify='right',
                state='normal',
                cursor='hand2',
                fg=fg,
                bg=bg,
                activebackground=abg,
                )
        self.delta_sb.delete(0, 'end')
        self.delta_sb.insert(0, '100 Hz')

        self.delta_sb.grid(row=0, column=2, sticky='w')

        frame.grid(row=container.row, column=container.column, sticky='w')

        self.server.subscribe_cmds('F{vfo}'.format(vfo=self.AorB), self.on_response_received)

    def on_vfo_change(self):
        freq = int(float(self.vfo_sb.get()) * 1000)
        mod = freq % int(self.increment * 1000)
        freq -= mod
        if mod != 0:
            self.vfo_sb.delete(0, 'end')
            self.vfo_sb.insert(0, "{:.3f}".format(float(freq)/1000))
        Poll.add_poll_callback(50, self.send_vfo_change)

    def send_vfo_change(self):
        Poll.remove_poll_callback(50, self.send_vfo_change)
        freq = int(float(self.vfo_sb.get()) * 1000)
        freq11 = "{:011d}".format(freq)
        cmd = "F{vfo}{freq};".format(vfo=self.AorB, freq=freq11)
        self.server.expand_and_send_cmds(cmd)

    def on_delta_change(self):
        self.increment = self.delta_map[self.delta_sb.get()]
        self.vfo_sb.config(increment=self.increment)

    def on_response_received(self, response):
        value  = "{:.3f}".format(float(response[2:13]) / 1000)
        self.vfo_sb.delete(0, 'end')
        self.vfo_sb.insert(0, value)

class Slider(Widget):
    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        server_name = config_info.get('server', Server.default_server_name)
        self.server = Server.server(server_name)

        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        self.from_ = config_info['from']
        self.to = config_info['to']
        orient = config_info.get('orient', 'horizontal')
        width = config_info.get('width', 15)
        length = config_info.get('length', 15)
        self.increment = config_info.get('increment', 1.0)
        self.cmd = config_info['cmd']
        self.response = config_info['response']
        slider_font = config_info.get('font', container.button_font)

        font = tkFont.Font(family=slider_font['family'], size=slider_font['size'], weight=slider_font['weight'])

        self.value = tk.DoubleVar()
        self.value.set(0.0)
        self.previous_value = 0.0

        resolution=self.eval_value((self.increment), self.value.get())

        self.scale = tk.Scale(container.frame,
                         from_=self.from_,
                         to=self.to,
                         orient=orient,
                         resolution=resolution,
                         width=width,
                         length=length,
                         font=font,
                         bg=bg,
                         fg=fg,
                         variable=self.value,
                         command=self.value_changed)
        self.scale.grid(row=container.row, column=container.column, sticky='nw')

        cmd = self.eval_value(self.cmd, self.value.get())
        self.server.subscribe_cmds(cmd, self.on_response_received)

    def eval_value(self, s, value):
        return eval(s)

    def value_changed(self, event):
        value = self.value.get()
        next_value = value
        if self.previous_value < value:
            next_value = value + self.eval_value(self.increment, value)
        self.scale.configure(resolution=self.eval_value(self.increment, next_value))
        cmd = self.eval_value(self.cmd, value)
        self.server.send_cmds(cmd)
        self.previous_value = value

    def on_response_received(self, response):
        value = float(self.eval_value(self.response, response))
        self.value.set(value)
        self.scale.configure(resolution=self.eval_value(self.increment, value))
        self.previous_value = value

def param_base(param):
    base = param[0:2]
    if base in Server.k4_long_base_params:
        for long_base in Server.k4_long_base_params[base]:
            if param.startswith(long_base):
                base = long_base
                break
    if len(param) > len(base) and param[len(base)] == '$':
        base += '$'
    return base

def read_config(config_file_name):
    with open(config_file_name) as stream:
        try:
            config = yaml.safe_load(stream)
        except yaml.YAMLError as exc:
            print(exc)

        for config_info in config:
            item = config_info['item']
            if item == 'page':
                Page(config_info)
            elif item == 'server':
                Server(config_info)
            elif item == 'defaults':
                Default(config_info)
            else:
                print("Unexpected top level item '{item}' in '{filename}'.".format(item=item, filename=config_file_name))


class Poll:
    poll_callbacks = {}
    polls = {}
    top = None

    def __init__(self, top):
        Poll.top = top

    def add_poll_callback(interval, callback):
        if interval not in Poll.poll_callbacks:
            Poll.poll_callbacks[interval] = []
            Poll.polls[interval] = lambda: Poll.poll(interval)
            Poll.top.after(interval, Poll.polls[interval])
        Poll.poll_callbacks[interval].append(callback)

    def poll(interval):
        for callback in tuple(Poll.poll_callbacks[interval]):
            callback()
        if len(Poll.poll_callbacks[interval]) == 0:
            del Poll.poll_callbacks[interval]
        else:
            Poll.top.after(interval, Poll.polls[interval])

    def remove_poll_callback(interval, callback):
        Poll.poll_callbacks[interval].remove(callback)

class Options():
    config_file = None
    verbose = 0
    debug = 0

    @staticmethod
    def Parse():
        parser = OptionParser(version=version)
        parser.add_option('--config', dest='config_file', default='k4macro.yaml',
                          help="use config file FILE", metavar="FILE")
        parser.add_option('-v', '--verbose', action='count', dest='verbose', default = 0,
                          help="output additional status messages")
        parser.add_option('-d', '--debug', action='count', dest='debug', default=0,
                          help="output debugging messages")
        (options, args) = parser.parse_args()

        Options.config_file = options.config_file
        Options.verbose = options.verbose
        Options.debug = options.debug
        if Options.debug > 0 and Options.verbose == 0:
            Options.verbose = Options.debug

        if len(args) != 0:
            parser.error("Unexpected argument '{arg}'".format(arg=args[0]))

def cleanup_and_exit():
    for server in Server.servers():
        server.close()

    quit()

def dprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def dprint1(*args, **kwargs):
    if Options.debug >= 1:
        print(*args, file=sys.stderr, **kwargs)

def dprint2(*args, **kwargs):
    if Options.debug >= 2:
        print(*args, file=sys.stderr, **kwargs)

def vprint1(*args, **kwargs):
    if Options.verbose >= 1:
        print(*args, **kwargs)

def vprint2(*args, **kwargs):
    if Options.verbose >= 2:
        print(*args, **kwargs)

def main():
    Options.Parse()

    top = tk.Tk()
    top.title('K4 Macro-Python')
    top.protocol("WM_DELETE_WINDOW", cleanup_and_exit)
    Page.top = top
    Poll(top)

    read_config(Options.config_file)

    for server in Server.servers():
        server.connect()

    Page.show('main')

    top.mainloop()

main()

# vim: set expandtab ts=4 sw=4:
