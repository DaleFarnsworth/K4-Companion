#!/usr/bin/env python3

# k4macro provides a set of buttons, each of which when clicked will
# send a macro string to the Elecraft K4 via TCP/IP.  It is capable of
# sending string commands to multiple servers, one or more which may
# be transceivers. These macros can be simple or complex. This program
# was inspired by K4 Macromaster, but in no way duplicates all of its
# functions. K4 Macro was initially created by Charles W. Powell, NK8O,
# but has been heavily modified. Charles has graciously allowed me
# to continue development and to release it under the GPL.
#
# Configuration information is maintained in a separate YAML file named,
# by default, k4macro.yaml.  Dale, W7DA
#
# Copyright (C) 2025  Dale Farnsworth  dale@farnsworth.org
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

import ctypes
import queue
import select
import socket
import sys
import textwrap
import threading
import time
import tkinter as tk
import tkinter.font as tkFont
import yaml

from optparse import OptionParser

version = '1.0.14'

class Default():
# may be overriden by values in the config file
    bg = 'maroon1'
    abg = 'red'
    fg = 'black'
    afg = None        # None means same as fg
    selectcolor = 'red'
    label_font =  { 'family': 'Helvetica', 'size': 8, 'weight': 'normal' }
    button_font = { 'family': 'Helvetica', 'size': 10, 'weight': 'normal' }

    def __init__(self, config_info):
        Default.bg = config_info.get('bg', Default.bg)
        Default.abg = config_info.get('abg', Default.abg)
        Default.fg = config_info.get('fg', Default.fg)
        Default.afg = config_info.get('afg', Default.afg)
        Default.selectcolor = config_info.get('selectcolor', Default.selectcolor)
        Default.label_font = config_info.get('label_font', Default.label_font)
        Default.button_font = config_info.get('button_font', Default.button_font)

class Server():
    server_dict = {}
    default_server_name = None

    def server(server_name):
        return Server.server_dict[server_name]

    @staticmethod
    def server_names():
        return Server.server_dict.keys()

    @staticmethod
    def servers():
        return Server.server_dict.values()

    @staticmethod
    def default():
        return Server.server(Server.default_server_name)

    @staticmethod
    def send_dict(cmd_dict):
        for server_name in cmd_dict:
            if server_name in Server.server_names():
                server = Server.server_name(server_name)
                server.send(cmd_dict[server_name])
            elif server_name == 'delay':
                delay = float(cmd_dict[server_name]) / 1000
                time.sleep(delay)
            else:
                print("Unknown server name '{name}'".format(name=server_name))

    def __init__(self, config_info):
        self.name = config_info['name']
        self.type = config_info.get('type', '')
        self.address = config_info['address']
        self.port = config_info['port']
        self.startup = config_info.get('startup', None)
        self.socket = None
        self.recv_buffer = ''
        self.send_queue = queue.Queue()
        self.recv_queue = queue.Queue()
        self.send_thread = None
        self.recv_thread = None
        self.connected = False
        self.response_subscriptions = {}
        self.max_response_key_length = 0
        self.poll_callbacks = {}

        if Server.default_server_name == None:
            Server.default_server_name = config_info['name']
        Server.server_dict[self.name] = self

    def add_poll_callback(self, key, callback):
        self.poll_callbacks[key] = callback

    def remove_poll_callback(self, key):
        self.poll_callbacks.pop(key, '')

    def poll(self):
        for key in tuple(self.poll_callbacks):
            callback = self.poll_callbacks.get(key, None)
            if callback != None:
                callback()
        Page.top.after(50, self.poll)

    def connect(self):
        vprint1('Connecting to {name}, address {addr}, port {port}'.format(
              name=self.name, addr=self.address, port=self.port))

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            sock.settimeout(5)
            sock.connect((self.address, self.port))
            self.connected = True
            self.socket = sock
            self.send_thread = threading.Thread(target=self.send_loop, name=self.name+'.send_thread')
            self.send_thread.start()
            self.recv_thread = threading.Thread(target=self.recv_loop, name=self.name+'.recv_thread')
            self.recv_thread.start()
            if self.type == 'k4':
                Page.top.after(50, self.poll)
                self.send('K41;')               # request K4 to respond in advanced mode
                self.send('AI2;AID060;')        # request K4 to send updates every 60 mS
                if self.startup != None:
                    self.send(self.startup)     # send user-specified startup commands
                self.add_poll_callback(self.recv_thread, self.receive)
        except socket.gaierror:
            print('Address not found: {addr}'.format(addr=self.address))
            if not Options.debug > 0:
                cleanup_and_exit()
        except OSError:
            print('Failed to connect to {name}, address {addr}, port {port}'.format(
                  name=self.name, addr=self.address, port=self.port))
            if not Options.debug > 0:
                cleanup_and_exit()

    def close(self):
        self.connected = False
        self.send_queue.put('shutdown')
        if self.send_thread != None:
            self.send_thread.join()
        if self.recv_thread != None:
            self.recv_thread.join()

    def send(self, cmd):
        if not self.connected:
            print("Server '{name}' not connected.".format(cmd=cmd, name=self.name))
        self.send_queue.put(cmd)

    def send_loop(self):
        while True:
            cmd = self.send_queue.get()
            if not self.connected:
                return
            try:
                self.socket.sendall(cmd.encode())
                dprint1('{name}: sent: {cmd}'.format(name=self.name, cmd=cmd))
            except OSError:
                print("Failed to send command, '{cmd}' to '{name}'".format(cmd=cmd, name=self.name))

    def sendall(self, cmd):
        if isinstance(cmd, str):
            self.send(cmd)
        elif isinstance(cmd, dict):
            Server.send_dict(cmd)
        elif isinstance(cmd, list):
            for cmd_dict in cmd:
                if isinstance(cmd_dict, dict):
                    Server.send_dict(cmd_dict)
                else:
                    print("Unknown server sub-command 'cmd'".format(cmd=cmd_dict))
        else:
            print("Unknown cmd '{cmd}'".format(cmd=cmd))

    def k4_receive(self, response):
        if len(response) > self.max_response_key_length:
            beyond_last = self.max_response_key_length + 2
        else:
            beyond_last = len(response) + 2

        start = len(cmd_base(response))

        found = False
        for end in range(start, beyond_last):
            for func in self.response_subscriptions.get(response[0:end], []):
                func(response)
                found = True
        return found

    def receive(self):
        try:
            responses = self.recv_queue.get_nowait()
            for response in responses:
                dprint2('{name}: dequeued response: {response}'.format(name=self.name, response=response))
                if self.type == 'k4':
                    response += ';'
                    if self.k4_receive(response):
                        continue
                dprint2('{name}: unhandled response: {response}'.format(name=self.name, response=response))
        except queue.Empty:
            pass

    def recv_loop(self):
        while True:
            responses = []
            readable, writable, in_error = select.select([self.socket.fileno()], [], [self.socket], 1)
            if not self.connected:
                return
            if len(in_error) > 0:
                print("socket error")
            if len(readable) == 0:
                continue

            recv_bytes = self.socket.recv(4096)
            if len(recv_bytes) == 0:
                self.connected = False
                return

            if self.type != 'k4':
                dprint1('{name}: received: {bytes}'.format(name=self.name, bytes=recv_bytes))
                try:
                    self.recv_queue.put([recv_bytes])
                except queue.ShutDown:
                    continue
            else:
                recv_str = recv_bytes.decode()
                dprint1('{name}: received: {str}'.format(name=self.name, str=recv_str))
                recv_strs = recv_str.split(';')
                if len(recv_strs) == 0:
                    continue

                if recv_strs[-1] == '':
                    partial_response = recv_strs[-1]
                    responses = recv_strs[0:-1]
                else:
                    responses = recv_strs
                if partial_response != '':
                    response[0] += partial_response
                    partial_response = ''

                self.recv_queue.put(responses)
                dprint2('{name}: queued: {responses}'.format(name=self.name, responses=responses))

    def subscribe_response(self, key, callback):
        if len(key) > self.max_response_key_length:
            self.max_response_key_length = len(key)
        if not key in self.response_subscriptions:
            self.response_subscriptions[key] = []
        if callback in self.response_subscriptions[key]:
            raise Exception('duplicate subscription for {key}: {callback}'.format(key, callback))
        self.response_subscriptions[key].append(callback)

    def unsubscribe_response(self, key, callback):
        self.response_subscriptions[key].remove(callback)
 
class Container():
    depth = -1

    def __init__(self, config_info, container):
        self.config_info = config_info
        self.container = container
        self.columns = config_info.get('columns', len(self.config_info['contains']))
        self.row = 0
        self.column = 0

        self.label_font = None
        self.button_font = None

    def next_column(self):
        self.column += 1
        if self.column >= self.columns:
            self.column = 0
            self.next_row()

    def next_row(self):
        self.row += 1

    def show_widgets(self):
        Container.depth += 1
        for config_info in self.config_info['contains']:
            widget_type = config_info['item'].lower()
            if widget_type == 'group':
                if Options.debug > 0:
                    label = config_info.get('label', '')
                    indent = '    ' * Container.depth
                    dprint('{indent}group {label}: row  {row}, column: {column}'.format(indent=indent, label=label, row=self.row, column=self.column))
                Group(config_info, self)
            elif widget_type == 'button':
                Button(config_info, self)
            elif widget_type == 'radiobutton':
                Radiobutton(config_info, self)
            elif widget_type == 'vfo':
                VFO(config_info, self)
            self.next_column()
        Container.depth -= 1

    def items_width(self):
        width = 0
        for config_info in self.config_info['contains']:
            text = str(config_info.get('text', ''))
            if len(text) > width:
                width = len(text)
        return width

class Page(Container):
    pages = {}
    name_stack = []
    current_frame = None
    top = None

    @staticmethod
    def show(page_name):
        if page_name in Page.pages:
            Page.name_stack.append(page_name)
            Page.pages[page_name].instance_show()
        else:
            print("Page:'{name}' not found.".format(name=page_name))

    @staticmethod
    def show_previous():
        if len(Page.name_stack) < 2:
            return
        Page.name_stack.pop()             # pop current page
        page_name = Page.name_stack.pop()
        Page.show(page_name)

    def __init__(self, config_info):
        super().__init__(config_info, None)

        self.frame = None

        Page.pages[config_info['name']] = self

        self.label_font = config_info.get('label_font', Default.label_font)
        self.button_font = config_info.get('button_font', Default.button_font)

    def instance_show(self):
        if Page.current_frame != None:
            Page.current_frame.destroy()
        self.frame = tk.Frame(Page.top)
        self.frame.grid()
        self.show_widgets()
        Page.current_frame = self.frame

class Group(Container):
    def __init__(self, config_info, container):
        super().__init__(config_info, container)
        container = self.container
        frame = container.frame

        if 'column' in config_info:
            column = config_info['column']
            if column < container.column:
                container.next_row()
            container.column = column
        else:
            column = container.column

        row = config_info.get('row', container.row)
        columnspan = config_info.get('columnspan', 1)
        rowspan = config_info.get('rowspan', 1)
        self.label_font = config_info.get('label_font', container.label_font)
        self.button_font = config_info.get('button_font', container.button_font)

        font = tkFont.Font(family=self.label_font['family'], size=self.label_font['size'], weight=self.label_font['weight'])

        if 'label' in config_info:
            label = config_info['label']
            self.frame = tk.LabelFrame(frame,
                                       text=label,
                                       font=font,
                                       labelanchor='nw',
                                       bd=2,
                                       relief='raised')
        else:
            self.frame  = tk.Frame(frame)

        self.frame.grid(row=row,
                        column=column,
                        rowspan=rowspan,
                        columnspan=columnspan,
                        sticky='w')
        self.show_widgets()

class Widget():
    def __init__(self, config_info, container):
        self.config_info = config_info
        self.container = container
        self.bg = None
        self.abg = None
        self.fg = None
        self.afg = None

class Button(Widget):
    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        text = str(config_info.get('text', ''))
        cmd = config_info.get('cmd', None)
        directive = config_info.get('directive', None)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg
        button_font = config_info.get('font', config_info.get('button_font', container.button_font))

        server_name = config_info.get('server', Server.default_server_name)
        self.server = Server.server(server_name)

        width = container.items_width()
        if len(text) > width:
            text = textwrap.fill(text, width)

        special_strings = {
            'quit': cleanup_and_exit,
            'show_previous_page': Page.show_previous,
        }

        if directive != None:
            if directive in special_strings:
                command = special_strings[directive]
            elif directive.startswith('show_page '):
                page_name = directive[len('show_page '):]
                command = lambda: Page.show(page_name)
            else:
                print('Unknown directive: ', directive)

        if cmd != None:
            command = lambda: self.server.sendall(cmd)

        font = tkFont.Font(family=button_font['family'], size=button_font['size'], weight=button_font['weight'])

        button = tk.Button(container.frame,
                    bd='4',
                    text=text,
                    font=font,
                    width=width,
                    relief='raised',
                    fg=fg,
                    bg=bg,
                    activebackground=abg,
                    activeforeground=afg,
                    padx=2,
                    pady=2,
                    command=command)

        button.grid(row=container.row, column=container.column, sticky='w')

class Radiobutton(Widget):
    radiobutton_responses = {}
    variables = {}
    response_callbacks = {}

    @staticmethod
    def select(group_id, response):
        for r, b in Radiobutton.radiobutton_responses[group_id].items():
            if r == response:
                b.button.select()
            else:
                b.button.deselect()

    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        self.text = str(config_info.get('text', ''))
        self.cmd = config_info.get('cmd', None)
        self.response = config_info.get('response', self.cmd)
        indicator = config_info.get('indicator', 1)
        selectcolor = config_info.get('selectcolor', Default.selectcolor)
        self.group_id = config_info.get('groupid', None)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg
        button_font = config_info.get('font', config_info.get('button_font', container.button_font))

        server_name = config_info.get('server', Server.default_server_name)
        self.server = Server.server(server_name)

        if not self.group_id in Radiobutton.radiobutton_responses:
            Radiobutton.radiobutton_responses[self.group_id] = {}
        Radiobutton.radiobutton_responses[self.group_id][self.response] = self

        if not self.group_id in Radiobutton.variables:
            Radiobutton.variables[self.group_id] = tk.StringVar
        variable = Radiobutton.variables[self.group_id]

        width = container.items_width()
        if len(self.text) > width:
            wrapped_text = textwrap.fill(self.text, width)
        else:
            wrapped_text = self.text

        font = tkFont.Font(family=button_font['family'], size=button_font['size'], weight=button_font['weight'])

        self.button = tk.Radiobutton(container.frame,
                    bd='4',
                    text=wrapped_text,
                    font=font,
                    width=width,
                    relief='raised',
                    fg=fg,
                    bg=bg,
                    activebackground=abg,
                    activeforeground=afg,
                    padx=2,
                    pady=2,
                    command=self.on_clicked,
                    indicator=indicator,
                    selectcolor=selectcolor,
                    variable=variable,
                    value=self.cmd)

        self.button.grid(row=container.row, column=container.column, sticky='w')

        if self.server.type == 'k4':
            group_id = self.group_id
            if group_id not in Radiobutton.response_callbacks:
                Radiobutton.response_callbacks[group_id] = lambda response: Radiobutton.select(group_id, response)
                key = cmd_base(self.response)
                self.server.subscribe_response(key, Radiobutton.response_callbacks[group_id])
                self.server.send('{key};'.format(key=key))

    def on_clicked(self):
        self.select(self.group_id, self.response)
        if self.cmd != None:
            self.server.sendall(self.cmd)

class VFO(Widget):
    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        self.AorB = config_info.get('AorB', 'A').upper()
        server_name = config_info.get('server', Server.default_server_name)
        self.server = Server.server(server_name)

        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        vfo_font = config_info.get('font', container.button_font)

        self.increment = .1

        frame = tk.Frame(container.frame)

        font = tkFont.Font(family=vfo_font['family'], size=vfo_font['size'], weight=vfo_font['weight'])

        self.vfo_sb = tk.Spinbox(
                frame,
                from_=100,
                to=54000,
                wrap=False,
                command=self.on_vfo_change,
                increment=self.increment,
                font=font,
                width=9,
                repeatdelay=300,
                repeatinterval=1,
                format='%5.3f',
                justify='right',
                state='normal',
                cursor='hand2',
                fg=fg,
                bg=bg,
                )

        self.vfo_sb.grid(row=0, column=0, sticky='w')

        set_font = tkFont.Font(family=vfo_font['family'], size=int(vfo_font['size']/3), weight='bold')

        set_button = tk.Button(frame,
                    bd='1',
                    text="S\nE\nT",
                    font=set_font,
                    relief='flat',
                    justify='left',
                    fg=fg,
                    bg=bg,
                    padx=1,
                    pady=1,
                    command=self.on_vfo_change)

        set_button.grid(row=0, column=1, sticky='w')

        self.delta_map = { '1 Hz': .001, '10 Hz': .01, '100 Hz': .1, '1 kHz': 1, '10 kHz': 10, '100 kHz': 100 }

        self.delta_sb = tk.Spinbox(
                frame,
                command=self.on_delta_change,
                values= tuple(self.delta_map.keys()),
                font=font,
                width=7,
                format='%5.3f',
                justify='right',
                state='normal',
                cursor='hand2',
                fg=fg,
                bg=bg,
                activebackground=abg,
                )
        self.delta_sb.delete(0, 'end')
        self.delta_sb.insert(0, '100 Hz')

        self.delta_sb.grid(row=0, column=2, sticky='w')

        frame.grid(row=container.row, column=container.column, sticky='w')

        self.server.subscribe_response('F{vfo}'.format(vfo=self.AorB), self.on_response_received)
        self.server.send('F{vfo};'.format(vfo=self.AorB))

    def on_vfo_change(self):
        freq = int(float(self.vfo_sb.get()) * 1000)
        mod = freq % int(self.increment * 1000)
        freq -= mod
        if mod != 0:
            self.vfo_sb.delete(0, 'end')
            self.vfo_sb.insert(0, "{:.3f}".format(float(freq)/1000))
        self.server.add_poll_callback(self, self.send_vfo_change)

    def send_vfo_change(self):
        self.server.remove_poll_callback(self)
        freq = int(float(self.vfo_sb.get()) * 1000)
        freq11 = "{:011d}".format(freq)
        cmd = "F{vfo}{freq};".format(vfo=self.AorB, freq=freq11)
        self.server.send(cmd)

    def on_delta_change(self):
        self.increment = self.delta_map[self.delta_sb.get()]
        self.vfo_sb.config(increment=self.increment)

    def on_response_received(self, response):
        value  = "{:.3f}".format(float(response[2:13]) / 1000)
        self.vfo_sb.delete(0, 'end')
        self.vfo_sb.insert(0, value)

def cmd_base(cmd):
    if cmd[2] == '$':
        base = cmd[0:3]
    else:
        base = cmd[0:2]
    return base

def read_config(config_file_name):
    with open(config_file_name) as stream:
        try:
            config = yaml.safe_load(stream)
        except yaml.YAMLError as exc:
            print(exc)

        for config_info in config:
            item = config_info['item']
            if item == 'page':
                Page(config_info)
            elif item == 'server':
                Server(config_info)
            elif item == 'defaults':
                Default(config_info)
            else:
                print("Unexpected top level item '{item}' in '{filename}'.".format(item=item, filename=config_file_name))

class Options():
    config_file = None
    verbose = 0
    debug = 0

    @staticmethod
    def Parse():
        parser = OptionParser(version=version)
        parser.add_option('--config', dest='config_file', default='k4macro.yaml',
                          help="use config file FILE", metavar="FILE")
        parser.add_option('-v', '--verbose', action='count', dest='verbose', default = 0,
                          help="output additional status messages")
        parser.add_option('-d', '--debug', action='count', dest='debug', default=0,
                          help="output debugging messages")
        (options, args) = parser.parse_args()

        Options.config_file = options.config_file
        Options.verbose = options.verbose
        Options.debug = options.debug
        if Options.debug > 0 and Options.verbose == 0:
            Options.verbose = Options.debug

        if len(args) != 0:
            parser.error("Unexpected argument '{arg}'".format(arg=args[0]))

def cleanup_and_exit():
    for server in Server.servers():
        server.close()

    quit()

def dprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def dprint1(*args, **kwargs):
    if Options.debug >= 1:
        print(*args, file=sys.stderr, **kwargs)

def dprint2(*args, **kwargs):
    if Options.debug >= 2:
        print(*args, file=sys.stderr, **kwargs)

def vprint1(*args, **kwargs):
    if Options.verbose >= 1:
        print(*args, **kwargs)

def vprint2(*args, **kwargs):
    if Options.verbose >= 2:
        print(*args, **kwargs)

def main():
    Options.Parse()

    top = tk.Tk()
    top.title('K4 Macro-Python')
    top.protocol("WM_DELETE_WINDOW", cleanup_and_exit)
    Page.top = top

    read_config(Options.config_file)

    for server in Server.servers():
        server.connect()

    Page.show('main')

    top.mainloop()

main()

# vim: set expandtab ts=4 sw=4:
