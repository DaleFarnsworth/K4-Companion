#!/usr/bin/env python3

# k4macro provides a set of buttons, each of which when clicked will
# send a macro string to the Elecraft K4 via TCP/IP.  It is capable of
# sending string commands to multiple servers, one or more which may
# be transceivers. These macros can be simple or complex. This program
# was inspired by K4 Macromaster, but in no way duplicates all of its
# functions. K4 Macro was initially created by Charles W. Powell, NK8O,
# but has been heavily modified. Charles has graciously allowed me
# to continue development and to release it under the GPL.
#
# Configuration information is maintained in a separate YAML file named,
# by default, k4macro.yaml.  Dale, W7DA
#
# Copyright (C) 2025  Dale Farnsworth  dale@farnsworth.org
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

import ctypes
import math
import queue
import select
import socket
import sys
import textwrap
import threading
import time
import tkinter as tk
import tkinter.ttk as ttk
import tkinter.font as tkFont
import yaml

from optparse import OptionParser

version = '1.0.24'

class Default():
# may be overriden by values in the config file
    bg = 'maroon1'
    abg = 'red'
    fg = 'black'
    afg = None        # None means same as fg
    selectcolor = 'red'
    label_font =  { 'family': 'Helvetica', 'size': 8, 'weight': 'normal' }
    button_font = { 'family': 'Helvetica', 'size': 10, 'weight': 'normal' }

    def __init__(self, config_info):
        Default.bg = config_info.get('bg', Default.bg)
        Default.abg = config_info.get('abg', Default.abg)
        Default.fg = config_info.get('fg', Default.fg)
        Default.afg = config_info.get('afg', Default.afg)
        Default.selectcolor = config_info.get('selectcolor', Default.selectcolor)
        Default.label_font = config_info.get('label_font', Default.label_font)
        Default.button_font = config_info.get('button_font', Default.button_font)

class Server():
    server_dict = {}
    default_server_name = None
    k4_get_cmd_basess = [         # For future use
        '#A',
        'AC',
        'ACM',
        'ACN',
        'ACs',
        'ACT',
        'AF',
        'AG$',
        'AI',
        'AL',
        'AN',
        'AP$',
        '#AR',
        'AR$',
        'AT',
        '#AVG',
        'BG',
        'BI',
        'BL',
        'BN$',
        'BR',
        'BS',
        'BW$',
        '#C',
        'CC',
        '#CUR$',
        'CW',
        '#D',
        'DA',
        'DB$',
        'DN',
        'DO',
        '#DPM',
        'DR$',
        '#DSM',
        'DT$',
        'DV',
        'DW',
        'ER',
        'ES',
        '#F',
        'FA',
        'FB',
        'FC$',
        'FI$',
        'FP$',
        '#FPS',
        'FR',
        '#FRZ',
        'FT',
        'FX',
        '#FXA',
        '#FXT',
        'GT$',
        '#H',
        'HD',
        '#HDPM',
        '#HDSM',
        '#HREF$',
        '#HWBS',
        '#HWFC',
        'ID',
        'IF',
        'IP',
        'IS$',
        'K4',
        'KCL',
        'KP',
        'KS',
        'KZ',
        'KZF',
        'LB',
        'LI',
        'LK$',
        'LN',
        'LO',
        '#M',
        'MA$',
        'MD$',
        'ME',
        'MEDF',
        'MG',
        'MI',
        'ML',
        '#MP$',
        'MS',
        'MX',
        '#N',
        'NA$',
        '#NB$',
        'NB$',
        '#NBL$',
        'NM$',
        'NR$',
        'OM',
        'OV$',
        '#P',
        'PA$',
        'PC',
        'PK',
        '#PKM',
        'PL$',
        'PO',
        'PP',
        '#R',
        'RA$',
        'RE',
        '#REF$',
        'RG$',
        'RL',
        'RO$',
        'RP',
        'RR',
        'RRC',
        'RRP',
        'RS',
        'RT$',
        'RV',
        '#S',
        'SB',
        'SC',
        '#SCL',
        'SD',
        '#SFL',
        'SL',
        'SM$',
        'SMH',
        'SMH$',
        'SN',
        '#SPM',
        '#SPN$',
        'SQ$',
        'SW',
        'TA',
        'TB$',
        'TD$',
        'TE',
        'TG',
        'TQ',
        'TS',
        'TX',
        'UP',
        'UT',
        '#V',
        'VC',
        '#VFA',
        '#VFB',
        'VG',
        'VI',
        'VO$',
        'VT$',
        'VX',
        '#W',
        '#WBS',
        '#WFC',
        'WM',
        'XT',
        'XV',
        'XV$',
    ]
    k4_long_cmd_bases = {
        '#A': ['#AR', '#AVG'],
        'AC': ['ACM', 'ACS', 'ACT', 'ACN'],
        '#C': ['#CAL', '#CUR'],
        '#D': ['#DPM', '#DSM'],
        'DN': ['DNB'],
        '#F': ['#FPS', '#FRZ', '#FXA', '#FXT'],
        '#H': ['#HDPM', '#HDSM', '#HREF', '#HWBS', '#HWFC', '#HWFH'],
        'KZ': ['KZL', 'KZF'],
        'LO': ['LOG'],
        'ME': ['MEDF'],
        '#M': ['#MP'],
        '#N': ['#NBL', '#NB'],
        'PC': ['PCX'],
        '#P': ['#PKM'],
        '#R': ['#REF'],
        'RR': ['RRT', 'RRC', 'RRP'],
        'SM': ['SMH'],
        '#S': ['#SCL', '#SFL', '#SPM', '#SPN'],
        'SW': ['SWT', 'SWH'],
        'UP': ['UPB'],
        '#V': ['#VFA', '#VFB'],
        '#W': ['#WBS', '#WFC', '#WFH'],
        'XV': ['XVN', 'XVM', 'XVR', 'XVI', 'XVO', 'XVP '],
    }

    # commands that end in +, -, /, \, ^, > are also pseudo set-only commands
    k4_set_only_cmd_bases = {
        'AB': True,
        'DE': True,
        'DM': True,
        'DNB': True,
        'DN': True,
        'EC': True,
        'LI': True,     # where total length of cmd is <= 6 characters
        'MS': True,     # where total length of cmd is <= 4 characters
        'RC$': True,
        'RC': True,
        'RD$': True,
        'RD': True,
        'RU$': True,
        'RU': True,
        'RX': True,
        'SI': True,
        'SP$': True,
        'SP': True,
        'SWH': True,
        'SW': True,
        'SWT': True,
        'TX': True,
        'UPB': True,
        'UP': True,
    }

    set_only_suffixes = {
        '+': True,
        '-': True,
        '/': True,
        '\\': True,
        '+': True,
        '-': True,
    }

    k4_get_only_cmd_bases = {
        'BG': True,
        'IF': True,
        'MA$': True,
        'MA': True,
        'OM': True,
        'PP': True,
        'RV': True,
        'SM$': True,
        'SMH$': True,
        'SMH': True,
        'SM': True,
        'SN': True,
        'TA': True,
        'TG': True,
        'TQ': True,
        'UT': True,
    }

    @staticmethod
    def server(server_name):
        return Server.server_dict[server_name]

    @staticmethod
    def server_names():
        return Server.server_dict.keys()

    @staticmethod
    def servers():
        return Server.server_dict.values()

    @staticmethod
    def default():
        return Server.server(Server.default_server_name)

    @staticmethod
    def k4_set_only_cmd(base, cmd):
        if base in Server.k4_set_only_cmd_bases:
            if base == 'LI' and len(cmd) > 6:
                return False
            elif base == 'MS' and len(cmd) > 4:
                return False
            else:
                return True
        elif base[-1] in Server.set_only_suffixes:
            return True
        else:
            return False

    @staticmethod
    def k4_get_only_cmd(base):
        return base in Server.k4_get_only_cmd_bases

    @staticmethod
    def send_cmds_with_server(cmd_list):
        for server_name, cmds in cmd_list:
            if server_name in Server.server_names():
                server = Server.server(server_name)
                server.send_cmds(cmds)
            elif server_name == 'delay':
                delay = float(cmd_dict[server_name]) / 1000
                time.sleep(delay)
            else:
                raise Exception("Unknown server name '{name}'".format(name=server_name))

    @staticmethod
    def split_cmd(cmd):
        if cmd[-1] == ';':
            cmd = cmd[0:-1]
        return cmd.split(';')

    def __init__(self, config_info):
        self.name = config_info['name']
        self.type = config_info.get('type', '').lower()
        self.address = config_info['address']
        self.port = config_info['port']
        self.startup = config_info.get('startup', None)
        self.socket = None
        self.recv_buffer = ''
        self.send_queue = queue.Queue()
        self.recv_queue = queue.Queue()
        self.send_thread = None
        self.recv_thread = None
        self.connected = False
        self.k4_subscriptions = {}
        self.k4_parameters = {}

        if Server.default_server_name == None:
            Server.default_server_name = config_info['name']
        Server.server_dict[self.name] = self

        self.connect()

    def update_k4_parameter(self, base, parameter):
        old = self.k4_parameters.get(base, None)
        self.k4_parameters[base] = parameter

        if old != parameter:
            callbacks = self.k4_subscriptions.get(base, [])
            for callback in callbacks:
                callback(base + parameter + ';')
            return True
        else:
            return False

    def k4_parameter(self, base):
        return self.k4_parameters.get(base, None)

    def connect(self):
        vprint1('Connecting to {name}, address {addr}, port {port}'.format(
              name=self.name, addr=self.address, port=self.port))

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            sock.settimeout(5)
            sock.connect((self.address, self.port))
            self.connected = True
            self.socket = sock
            self.send_thread = threading.Thread(target=self.send_loop, name=self.name+'.send_thread')
            self.send_thread.start()
            self.recv_thread = threading.Thread(target=self.recv_loop, name=self.name+'.recv_thread')
            self.recv_thread.start()
            if self.type == 'k4':
                self.send_str('K41;')                # request K4 to respond in advanced mode
                self.send_str('AI4;')                # request K4 to send updates immediately
                self.send_cmds('MD;MD$;')            # cache the mode response for later use in setting the vfo step
                if self.startup != None:
                    self.send_cmds(self.startup)     # send user-specified startup commands
                Poll.add_poll(1, self.receive)
        except socket.gaierror:
            print('Address not found: {addr}'.format(addr=self.address))
            if not Options.debug > 0:
                cleanup_and_exit()
        except OSError:
            print('Failed to connect to {name}, address {addr}, port {port}'.format(
                  name=self.name, addr=self.address, port=self.port))
            if not Options.debug > 0:
                cleanup_and_exit()

    def close(self):
        self.connected = False
        self.send_queue.put('shutdown')
        if self.send_thread != None:
            self.send_thread.join()
        if self.recv_thread != None:
            self.recv_thread.join()

    def send_str(self, cmd):
        self.send_queue.put(cmd)

    def send_cmds(self, cmds):
        if not self.connected:
            print("Server '{name}' not connected.".format(cmd=cmd, name=self.name))
        if isinstance(cmds, str):
            cmds = Server.split_cmd(cmds)
        for cmd in cmds:
            if cmd == '':
                continue
            base = cmd_base(cmd)
            if Server.k4_set_only_cmd(base, cmd) or self.update_k4_parameter(base, cmd[len(base):]):
                cmd += ';'
                self.send_str(cmd)

    def send_loop(self):
        while True:
            cmd = self.send_queue.get()
            if not self.connected:
                return
            try:
                self.socket.sendall(cmd.encode())
                dprint1('{name}: sent: {cmd}'.format(name=self.name, cmd=cmd))
            except OSError:
                print("Failed to send command, '{cmd}' to '{name}'".format(cmd=cmd, name=self.name))

    def expand_cmds(self, cmds):
        if isinstance(cmds, str):
            return [[self.name, Server.split_cmd(cmds)]]
        elif isinstance(cmds, dict):
            cmd_dict = cmds
            ret = []
            for name in cmd_dict:
                cmd = cmd_dict[name]
                ret.append(name, Server.split_cmd(cmd_dict[name]))
            return ret
        elif isinstance(cmds, list):
            ret = []
            for cmd_dict in cmds:
                if not isinstance(cmd_dict, dict):
                    raise Exception("Unknown server sub-command '{cmd}'".format(cmd=cmd_dict))
                for name in cmd_dict:
                    cmd = cmd_dict[name]
                    ret.append(name, Server.split_cmd(cmd_dict[name]))
            return ret
        else:
            raise Exception("Error: bad cmd format: '{cmd}'".format(cmd=cmd))

    def expand_server_cmds(self, cmds):
        if isinstance(cmds, str):
            return Server.split_cmd(cmds)
        ret = []
        for name, cmds in self.expand_cmds(cmds):
            if name == self.name:
                ret.extend(cmds)
        return ret

    def expand_and_send_cmds(self, cmds):
        expanded_cmds = self.expand_cmds(cmds)
        Server.send_cmds_with_server(expanded_cmds)

    def server_cmds(self, cmds):
        ret = []
        expanded_cmds = self.expand_cmds(cmds)
        for server_name, cmds in expanded_cmds:
            if server_name != self.name:
                continue
            for cmd in cmds:
                ret.append(cmd)
        return ret

    def subscribe_cmds(self, cmds, callback):
        for cmd in self.server_cmds(cmds):
            self.subscribe_response(cmd, callback)

    def receive(self):
        while True:
            try:
                responses = self.recv_queue.get_nowait()
                for response in responses:
                    if self.type == 'k4':
                        base = cmd_base(response)
                        response = response[len(base):]
                        if response == '?':
                            raise Exception('Received error response from K4: ', base + response)
                        self.update_k4_parameter(base, response)

                    # For now, ignore responses from non-K4 servers
            except queue.Empty:
                break

    def recv_loop(self):
        while True:
            responses = []
            readable, writable, in_error = select.select([self.socket.fileno()], [], [self.socket], 1)
            if not self.connected:
                return
            if len(in_error) > 0:
                raise Exception("Socket error reading from server '{name}'".format(name=self.name))
            if len(readable) == 0:
                continue

            recv_bytes = self.socket.recv(4096)
            if len(recv_bytes) == 0:
                self.connected = False
                return

            if self.type != 'k4':
                dprint1('{name}: received: {bytes}'.format(name=self.name, bytes=recv_bytes))
                try:
                    self.recv_queue.put([recv_bytes])
                except queue.ShutDown:
                    continue
            else:
                recv_str = recv_bytes.decode()
                dprint1('{name}: received: {str}'.format(name=self.name, str=recv_str))
                recv_strs = recv_str.split(';')
                if len(recv_strs) == 0:
                    continue

                if recv_strs[-1] == '':
                    partial_response = recv_strs[-1]
                    responses = recv_strs[0:-1]
                else:
                    responses = recv_strs
                if partial_response != '':
                    response[0] += partial_response
                    partial_response = ''

                self.recv_queue.put(responses)

    def subscribe_response(self, cmd, callback):
        base = cmd_base(cmd)
        if not base in self.k4_subscriptions:
            self.k4_subscriptions[base] = []
        parameter = self.k4_parameters.get(base, None)
        if parameter != None:
            callback(parameter + ';')
        self.send_str(cmd_get_format(cmd))              # TODO Try sending only if not found is cached parameters
        if callback in self.k4_subscriptions[base]:
            raise Exception('duplicate subscription for {base}: {callback}'.format(base=base, callback=callback))
        self.k4_subscriptions[base].append(callback)

    def unsubscribe_response(self, base, callback):
        self.k4_subscriptions[base].remove(callback)

    def clear_k4_subscriptions(self):
        self.k4_subscriptions.clear()

class Container():
    depth = -1

    def __init__(self, config_info, container):
        self.config_info = config_info
        self.container = container
        if isinstance(self, Page):
            inherited_server_name = Server.default_server_name
        else:
            inherited_server_name = container.server_name
        self.server_name = config_info.get('server', inherited_server_name)
        self.server = Server.server(self.server_name)
        self.columns = config_info.get('columns', len(self.config_info['contains']))
        self.row = 0
        self.column = 0

        self.label_font = None
        self.button_font = None

    def next_column(self):
        self.column += 1
        if self.column >= self.columns:
            self.column = 0
            self.next_row()

    def next_row(self):
        self.row += 1

    def show_widgets(self):
        Container.depth += 1
        for config_info in self.config_info['contains']:
            widget_type = config_info['item'].lower()
            if widget_type == 'group':
                if Options.debug > 0:
                    label = config_info.get('label', '')
                    indent = '    ' * Container.depth
                    dprint('{indent}group {label}: row  {row}, column: {column}'.format(indent=indent, label=label, row=self.row, column=self.column))
                Group(config_info, self)
            elif widget_type == 'button':
                Button(config_info, self)
            elif widget_type == 'radiobutton':
                Radiobutton(config_info, self)
            elif widget_type == 'vfo':
                VFO(config_info, self)
            elif widget_type == 'slider':
                Slider(config_info, self)

            self.next_column()
        Container.depth -= 1

    def items_width(self):
        width = 0
        for config_info in self.config_info['contains']:
            text = str(config_info.get('text', ''))
            if len(text) > width:
                width = len(text)
        return width

class Page(Container):
    pages = {}
    name_stack = []
    top = None

    @staticmethod
    def show_page(page_name):
        if len(Page.name_stack) > 0:
            current_page_name = Page.name_stack[-1]
            current_page = Page.pages[current_page_name]
            current_page.hide()
        if page_name in Page.pages:
            Page.name_stack.append(page_name)
            Page.pages[page_name].show()
        else:
           raise Exception("Page:'{name}' not found.".format(name=page_name))

    @staticmethod
    def show_previous():
        if len(Page.name_stack) < 2:
            return
        current_page_name = Page.name_stack.pop()
        page_name = Page.name_stack.pop()
        Page.name_stack.append(current_page_name)
        Page.show_page(page_name)

    def __init__(self, config_info):
        super().__init__(config_info, None)

        Page.pages[config_info['name']] = self

        self.label_font = config_info.get('label_font', Default.label_font)
        self.button_font = config_info.get('button_font', Default.button_font)
        self.frame = tk.Frame(Page.top)
        self.show_widgets()

    def show(self):
        self.frame.grid()

    def hide(self):
        self.frame.grid_forget()

class Group(Container):
    def __init__(self, config_info, container):
        super().__init__(config_info, container)
        container = self.container
        frame = container.frame

        if 'column' in config_info:
            column = config_info['column']
            if column < container.column:
                container.next_row()
            container.column = column
        else:
            column = container.column

        row = config_info.get('row', container.row)
        columnspan = config_info.get('columnspan', 1)
        rowspan = config_info.get('rowspan', 1)
        self.label_font = config_info.get('label_font', container.label_font)
        self.button_font = config_info.get('button_font', container.button_font)

        font = tkFont.Font(family=self.label_font['family'], size=self.label_font['size'], weight=self.label_font['weight'])

        if 'label' in config_info:
            label = config_info['label']
            self.frame = tk.LabelFrame(frame,
                                       text=label,
                                       font=font,
                                       labelanchor='nw',
                                       bd=2,
                                       relief='raised')
        else:
            self.frame  = tk.Frame(frame)

        self.frame.grid(row=row,
                        column=column,
                        rowspan=rowspan,
                        columnspan=columnspan,
                        sticky='w')
        self.show_widgets()

class Widget():
    def __init__(self, config_info, container):
        self.config_info = config_info
        self.container = container
        self.bg = None
        self.abg = None
        self.fg = None
        self.afg = None

        server_name = config_info.get('server', container.server_name)
        self.server = Server.server(server_name)

class Button(Widget):
    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        text = str(config_info.get('text', ''))
        cmd = config_info.get('cmd', None)
        directive = config_info.get('directive', None)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg
        button_font = config_info.get('font', config_info.get('button_font', container.button_font))

        width = container.items_width()
        if len(text) > width:
            text = textwrap.fill(text, width)

        special_strings = {
            'quit': cleanup_and_exit,
            'show_previous_page': Page.show_previous,
        }

        if directive != None:
            if directive in special_strings:
                command = special_strings[directive]
            elif directive.startswith('show_page '):
                page_name = directive[len('show_page '):]
                command = lambda: Page.show_page(page_name)
            else:
               raise Exception('Unknown directive: ', directive)

        if cmd != None:
            command = lambda: self.server.expand_and_send_cmds(cmd)

        font = tkFont.Font(family=button_font['family'], size=button_font['size'], weight=button_font['weight'])

        button = tk.Button(container.frame,
                    bd='4',
                    text=text,
                    font=font,
                    width=width,
                    relief='raised',
                    fg=fg,
                    bg=bg,
                    activebackground=abg,
                    activeforeground=afg,
                    padx=2,
                    pady=2,
                    command=command)

        button.grid(row=container.row, column=container.column, sticky='w')

class Radiobutton(Widget):
    variables = {}
    button_counter = 0

    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        Radiobutton.button_counter += 1

        self.text = str(config_info.get('text', ''))
        self.cmd = config_info.get('cmd', None)
        self.response = config_info.get('response', self.cmd)
        indicator = config_info.get('indicator', 1)
        selectcolor = config_info.get('selectcolor', Default.selectcolor)
        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        afg = config_info.get('afg', Default.afg)
        if afg == None:
            afg = fg
        self.flashmS = int(config_info.get('flashrate', 0) * 100 / 2)
        self.flashstate = False
        self.group_id = config_info.get('groupid', None)

        button_font = config_info.get('font', config_info.get('button_font', container.button_font))

        self.parameters = {}

        if not self.group_id in Radiobutton.variables:
            Radiobutton.variables[self.group_id] = tk.StringVar
        variable = Radiobutton.variables[self.group_id]

        width = container.items_width()
        if len(self.text) > width:
            wrapped_text = textwrap.fill(self.text, width)
        else:
            wrapped_text = self.text

        font = tkFont.Font(family=button_font['family'], size=button_font['size'], weight=button_font['weight'])

        self.button = tk.Radiobutton(container.frame,
                    bd='4',
                    text=wrapped_text,
                    font=font,
                    width=width,
                    relief='raised',
                    fg=fg,
                    bg=bg,
                    activebackground=abg,
                    activeforeground=afg,
                    padx=2,
                    pady=2,
                    command=self.on_clicked,
                    indicator=indicator,
                    selectcolor=selectcolor,
                    variable=variable,
                    value=Radiobutton.button_counter)

        self.button.grid(row=container.row, column=container.column, sticky='w')

        for response in self.server.expand_server_cmds(self.response):
            base = cmd_base(response)
            if Server.k4_set_only_cmd(base, response):
                raise Exception("Set-only command: '{cmd}' not permitted in Radiobutton".format(cmd=self.response))
            if Server.k4_get_only_cmd(base):
                raise Exception("Get-only command: '{cmd}' not permitted in Radiobutton".format(cmd=self.response))
            response = response[len(base):]
            self.parameters[base] = response

        self.server.subscribe_cmds(self.response, self.on_response_received)

    def on_clicked(self):
        if self.cmd != None:
            self.server.expand_and_send_cmds(self.cmd)

    def compare_parameters(self, group, text):
        parameters = self.parameters
        for base in parameters.keys():
            dprint2('commpare {group}:{text} s: {s}, b: {b}'.format(group=group, text=text, s=self.server.k4_parameters.get(base, None), b=parameters[base]))
            if parameters[base] != self.server.k4_parameters.get(base, None):
                return False
        dprint2('Match')
        return True

    def on_response_received(self, response):
        if self.compare_parameters(self.group_id, self.text):
            self.button.select()
            if self.flashmS > 0:
                self.flashon()
        else:
            self.button.deselect()
            if self.flashmS > 0:
                self.flashoff()

    def flashon(self):
        Poll.add_poll(self.flashmS, self.flash)

    def flashoff(self):
        Poll.remove_poll(self.flashmS, self.flash)

    def flash(self):
        self.flashstate = not self.flashstate
        if self.flashstate:
            self.button.select()
        else:
            self.button.deselect()

class VFO(Widget):
    steps = [.001, .01, .1, 1, 10 ]
    texts = [ '1 Hz', '10 Hz', '100 Hz', '1 kHz', '10 kHz' ]
    step_to_index = {}
    text_to_index = {}

    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        if len(VFO.step_to_index) == 0:
            for i, step in enumerate(VFO.steps):
                VFO.step_to_index[step] = i

        if len(VFO.text_to_index) == 0:
            for i, text in enumerate(VFO.texts):
                VFO.text_to_index[text] = i

        self.AorB = config_info.get('AorB', 'A').upper()

        self.bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        abg = config_info.get('abg', Default.abg)
        vfo_font = config_info.get('font', container.button_font)
        step_spinbox = true_values(config_info.get('step_spinbox', 'false'))

        self.step = .1

        frame = tk.Frame(container.frame)

        font = tkFont.Font(family=vfo_font['family'], size=vfo_font['size'], weight=vfo_font['weight'])

        self.enter_frequency_wrapper = (Page.top.register(self.enter_frequency), '%P', '%V')
        self.vfo_sb = tk.Spinbox(
                frame,
                from_=100,
                to=54000,
                wrap=False,
                command=self.on_frequency_change,
                increment=self.step,
                font=font,
                width=11,
                repeatdelay=300,
                repeatinterval=1,
                format='%5.3f',
                justify='right',
                state='normal',
                cursor='hand2',
                fg=fg,
                bg=self.bg,
                )
        self.vfo_sb.grid(row=0, column=0, sticky='w')
        self.vfo_sb.bind('<Return>', self.set_frequency)
        self.vfo_sb.configure(validate='all', validatecommand=self.enter_frequency_wrapper)

        self.step_sb = tk.Spinbox(
                frame,
                command=self.on_step_sb_changed,
                values=tuple(VFO.texts),
                font=font,
                width=7,
                justify='right',
                state='readonly',
                fg=fg,
                bg=self.bg,
                readonlybackground=self.bg,
                activebackground=abg,
                )
        self.step_sb.delete(0, 'end')
        self.step_sb.insert(0, '100 Hz')

        self.step_cb_val = tk.StringVar()

        # Define the style for combobox widget
        style= ttk.Style()
        style.configure("TCombobox", background=self.bg, forground=fg, selectbackground=self.bg, selectforeground=fg)

        self.step_cb = ttk.Combobox(
                frame,
                textvar=self.step_cb_val,
                font=(vfo_font['family'], vfo_font['size']),
                values=VFO.texts,
                width=7,
                justify='right',
                state='readonly',
                )
        self.step_cb_val.trace('w', self.on_step_cb_changed)

        if step_spinbox:
            self.step_sb.grid(row=0, column=1, sticky='w')
        else:
            self.step_cb.grid(row=0, column=1, sticky='w')

        frame.grid(row=container.row, column=container.column, sticky='w')

        self.server.subscribe_cmds('F{vfo}'.format(vfo=self.AorB), self.on_frequency_received)
        step_cmd = 'VT'
        if self.AorB == 'B':
            step_cmd += '$'
        self.server.subscribe_cmds(step_cmd, self.on_step_received)

    def enter_frequency(self, p, v):
        try:
            float(p)
        except:
            return False

        if v == 'focusin' or v == 'key':
            self.vfo_sb.configure(bg='lightgray')
            return True
        elif v == 'focusout':
            return self.set_frequency()

    def set_frequency(self, arg=''):
        Page.top.focus()                # Remove focus from vfo_sb
        freq = float(self.vfo_sb.get())
        if freq < 100 or freq >= 54000:
            return False

        self.vfo_sb.configure(bg=self.bg)
        self.send_frequency()
        return True

    def on_frequency_change(self):
        freq = int(float(self.vfo_sb.get()) * 1000)
        mod = freq % int(self.step * 1000)
        freq -= mod
        if mod != 0:
            self.vfo_sb.delete(0, 'end')
            self.vfo_sb.insert(0, "{:5.3f}".format(float(freq)/1000))
        Poll.add_poll(50, self.send_frequency)

    def send_frequency(self):
        Poll.remove_poll(50, self.send_frequency)
        freq = int(float(self.vfo_sb.get()) * 1000)
        freq11 = "{:011d}".format(freq)
        cmd = "F{vfo}{freq};".format(vfo=self.AorB, freq=freq11)
        self.server.send_cmds(cmd)

    def on_frequency_received(self, response):
        self.vfo_sb.configure(bg=self.bg)
        freq_str = response_after_base(response)
        value  = "{:5.3f}".format(float(freq_str[0:11]) / 1000)
        self.vfo_sb.configure(validate='none')
        self.vfo_sb.delete(0, 'end')
        self.vfo_sb.insert(0, value)
        self.vfo_sb.configure(validate='all')

    def on_step_sb_changed(self):
        text = self.step_sb.get()
        self.set_step(text)

    def on_step_cb_changed(self, var, index, mode):
        text = self.step_cb_val.get()
        if text != '':
            self.set_step(text)

    def set_step(self, text):
        self.step = VFO.steps[VFO.text_to_index[text]]
        self.vfo_sb.config(increment=self.step)
        mode_index = self.current_mode_index()
        cmd = 'VT'
        if self.AorB == 'B':
            cmd += '$'
        cmd += str(VFO.step_to_index[self.step])
        cmd += self.current_mode_index()
        self.server.send_cmds(cmd + ';')

    def on_step_received(self, response):
        step_str = response_after_base(response)
        step_index = int(step_str[0])
        if step_index == 5:                             # Work around an apparent K4 bug
            cmd = 'VT'
            if self.AorB == 'B':
                cmd += '$'
            self.server.send_cmds(cmd + '2;')
            step_index = 2
        self.step = VFO.steps[step_index]
        self.vfo_sb.config(increment=self.step)
        text = VFO.texts[VFO.step_to_index[self.step]]
        self.step_sb.configure(state='normal')
        self.step_sb.delete(0, 'end')
        self.step_sb.insert(0, text)
        self.step_sb.configure(state='readonly')
        self.step_cb_val.set(text)

    def current_mode_index(self):
        cmd = 'MD'
        if self.AorB == 'B':
            cmd += '$'
        mode_parameter = self.server.k4_parameter(cmd)
        return mode_parameter[-1]

class Slider(Widget):
    def __init__(self, config_info, container):
        super().__init__(config_info, container)

        bg = config_info.get('bg', Default.bg)
        fg = config_info.get('fg', Default.fg)
        self.from_ = config_info['from']
        self.to = config_info['to']
        orient = config_info.get('orient', 'horizontal')
        width = config_info.get('width', 15)
        length = config_info.get('length', 15)
        self.increment = config_info.get('increment', 1.0)
        self.cmd = config_info['cmd']
        self.response = config_info['response']
        slider_font = config_info.get('font', container.button_font)

        font = tkFont.Font(family=slider_font['family'], size=slider_font['size'], weight=slider_font['weight'])

        self.value = tk.DoubleVar()
        self.value.set(0.0)
        self.previous_value = 0.0

        resolution=self.eval_value(self.increment, self.value.get())

        self.scale = tk.Scale(container.frame,
                         from_=self.from_,
                         to=self.to,
                         orient=orient,
                         resolution=resolution,
                         width=width,
                         length=length,
                         font=font,
                         bg=bg,
                         fg=fg,
                         variable=self.value,
                         command=self.value_changed)
        self.scale.grid(row=container.row, column=container.column, sticky='nw')

        cmd = self.eval_value(self.cmd, self.value.get())
        self.server.subscribe_cmds(cmd, self.on_response_received)

    def eval_value(self, s, value):
        return eval(s)

    def value_changed(self, event):
        value = self.value.get()
        next_value = value
        if self.previous_value < value:
            next_value = value + self.eval_value(self.increment, value)
        self.scale.configure(resolution=self.eval_value(self.increment, next_value))
        cmd = self.eval_value(self.cmd, value)
        self.server.send_cmds(cmd)
        self.previous_value = value

    def on_response_received(self, response):
        value = float(self.eval_value(self.response, response))
        self.value.set(value)
        self.scale.configure(resolution=self.eval_value(self.increment, value))
        self.previous_value = value

def cmd_base(cmd):
    ucmd = cmd.upper()
    base = ucmd[0:2]
    if base in Server.k4_long_cmd_bases:
        for long_base in Server.k4_long_cmd_bases[base]:
            if ucmd.startswith(long_base):
                base = long_base
                break
    if len(cmd) > len(base) and cmd[len(base)] == '$':
        base += '$'
    return base

def cmd_get_format(cmd):
    base = cmd_base(cmd)
    get_base = base
    if base == 'ML':
        get_base = cmd[0:3]
    elif base == 'BR':
        get_base = cmd[0:3]
    elif base == 'PK':
        get_base = cmd[0:4]
    return get_base + ';'

def response_after_base(response):
    i = len(cmd_base(response))
    return response[i:]

def true_values(v):
    if v == True:
        return True

    if not isinstance(v, str):
        return False

    v = v.lower()
    return v == 'true' or v == 'on' or v == '1' or v == 'yes'

def read_config(config_file_name):
    with open(config_file_name) as stream:
        try:
            config = yaml.safe_load(stream)
        except yaml.YAMLError as exc:
            print(exc)

        for config_info in config:
            item = config_info['item']
            if item == 'page':
                Page(config_info)
            elif item == 'server':
                Server(config_info)
            elif item == 'defaults':
                Default(config_info)
            else:
                raise Exception("Unexpected top level item '{item}' in '{filename}'.".format(item=item, filename=config_file_name))


class Poll:
    poll_callbacks = {}
    polls = {}
    top = None

    def __init__(self, top):
        Poll.top = top

    def poll(interval):
        for callback in tuple(Poll.poll_callbacks[interval]):
            callback()
        if len(Poll.poll_callbacks[interval]) == 0:
            del Poll.poll_callbacks[interval]
        else:
            Poll.top.after(interval, Poll.polls[interval])

    def add_poll(interval, callback):
        if interval not in Poll.poll_callbacks:
            Poll.poll_callbacks[interval] = []
            Poll.polls[interval] = lambda: Poll.poll(interval)
            Poll.top.after(interval, Poll.polls[interval])
        if not callback in Poll.poll_callbacks[interval]:
            Poll.poll_callbacks[interval].append(callback)

    def remove_poll(interval, callback):
        try:
            Poll.poll_callbacks[interval].remove(callback)
        except:
            pass

class Options():
    config_file = None
    verbose = 0
    debug = 0

    @staticmethod
    def Parse():
        parser = OptionParser(version=version)
        parser.add_option('--config', dest='config_file', default='k4macro.yaml',
                          help="use config file FILE", metavar="FILE")
        parser.add_option('-v', '--verbose', action='count', dest='verbose', default = 0,
                          help="output additional status messages")
        parser.add_option('-d', '--debug', action='count', dest='debug', default=0,
                          help="output debugging messages")
        (options, args) = parser.parse_args()

        Options.config_file = options.config_file
        Options.verbose = options.verbose
        Options.debug = options.debug
        if Options.debug > 0 and Options.verbose == 0:
            Options.verbose = Options.debug

        if len(args) != 0:
            parser.error("Unexpected argument '{arg}'".format(arg=args[0]))

def cleanup_and_exit():
    for server in Server.servers():
        server.close()

    quit()

def dprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def dprint1(*args, **kwargs):
    if Options.debug >= 1:
        print(*args, file=sys.stderr, **kwargs)

def dprint2(*args, **kwargs):
    if Options.debug >= 2:
        print(*args, file=sys.stderr, **kwargs)

def vprint1(*args, **kwargs):
    if Options.verbose >= 1:
        print(*args, **kwargs)

def vprint2(*args, **kwargs):
    if Options.verbose >= 2:
        print(*args, **kwargs)

def tprint(*args, **kwargs):
    print(*args, **kwargs)

def main():
    Options.Parse()

    top = tk.Tk()
    top.title('K4 Macro')
    top.protocol("WM_DELETE_WINDOW", cleanup_and_exit)
    Page.top = top
    Poll(top)

    read_config(Options.config_file)

    Page.show_page('main')

    top.mainloop()

main()

# vim: set expandtab ts=4 sw=4:
